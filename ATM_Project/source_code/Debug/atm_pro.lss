
atm_pro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000085d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000146  00800060  000085d0  00008664  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000689  008001a6  008001a6  000087aa  2**0
                  ALLOC
  3 .stab         00009fa8  00000000  00000000  000087ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000053b2  00000000  00000000  00012754  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  00017b06  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001ae  00000000  00000000  00017c86  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000224b  00000000  00000000  00017e34  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000011f1  00000000  00000000  0001a07f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001031  00000000  00000000  0001b270  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001a0  00000000  00000000  0001c2a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000030b  00000000  00000000  0001c444  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000095a  00000000  00000000  0001c74f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001d0a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 fe 12 	jmp	0x25fc	; 0x25fc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ed       	ldi	r30, 0xD0	; 208
      68:	f5 e8       	ldi	r31, 0x85	; 133
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3a       	cpi	r26, 0xA6	; 166
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a6 ea       	ldi	r26, 0xA6	; 166
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 32       	cpi	r26, 0x2F	; 47
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e0 3b 	call	0x77c0	; 0x77c0 <main>
      8a:	0c 94 e6 42 	jmp	0x85cc	; 0x85cc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__muldi3>:
      92:	a0 e3       	ldi	r26, 0x30	; 48
      94:	b0 e0       	ldi	r27, 0x00	; 0
      96:	ef e4       	ldi	r30, 0x4F	; 79
      98:	f0 e0       	ldi	r31, 0x00	; 0
      9a:	0c 94 9f 42 	jmp	0x853e	; 0x853e <__prologue_saves__>
      9e:	a8 e0       	ldi	r26, 0x08	; 8
      a0:	4e 01       	movw	r8, r28
      a2:	08 94       	sec
      a4:	81 1c       	adc	r8, r1
      a6:	91 1c       	adc	r9, r1
      a8:	f4 01       	movw	r30, r8
      aa:	ba 2f       	mov	r27, r26
      ac:	11 92       	st	Z+, r1
      ae:	ba 95       	dec	r27
      b0:	e9 f7       	brne	.-6      	; 0xac <__muldi3+0x1a>
      b2:	29 83       	std	Y+1, r18	; 0x01
      b4:	3a 83       	std	Y+2, r19	; 0x02
      b6:	4b 83       	std	Y+3, r20	; 0x03
      b8:	5c 83       	std	Y+4, r21	; 0x04
      ba:	6d 83       	std	Y+5, r22	; 0x05
      bc:	7e 83       	std	Y+6, r23	; 0x06
      be:	8f 83       	std	Y+7, r24	; 0x07
      c0:	98 87       	std	Y+8, r25	; 0x08
      c2:	ce 01       	movw	r24, r28
      c4:	09 96       	adiw	r24, 0x09	; 9
      c6:	fc 01       	movw	r30, r24
      c8:	11 92       	st	Z+, r1
      ca:	aa 95       	dec	r26
      cc:	e9 f7       	brne	.-6      	; 0xc8 <__muldi3+0x36>
      ce:	a9 86       	std	Y+9, r10	; 0x09
      d0:	ba 86       	std	Y+10, r11	; 0x0a
      d2:	cb 86       	std	Y+11, r12	; 0x0b
      d4:	dc 86       	std	Y+12, r13	; 0x0c
      d6:	ed 86       	std	Y+13, r14	; 0x0d
      d8:	fe 86       	std	Y+14, r15	; 0x0e
      da:	0f 87       	std	Y+15, r16	; 0x0f
      dc:	18 8b       	std	Y+16, r17	; 0x10
      de:	29 81       	ldd	r18, Y+1	; 0x01
      e0:	3a 81       	ldd	r19, Y+2	; 0x02
      e2:	4b 81       	ldd	r20, Y+3	; 0x03
      e4:	5c 81       	ldd	r21, Y+4	; 0x04
      e6:	2d a7       	std	Y+45, r18	; 0x2d
      e8:	3e a7       	std	Y+46, r19	; 0x2e
      ea:	4f a7       	std	Y+47, r20	; 0x2f
      ec:	58 ab       	std	Y+48, r21	; 0x30
      ee:	79 01       	movw	r14, r18
      f0:	8a 01       	movw	r16, r20
      f2:	8f ef       	ldi	r24, 0xFF	; 255
      f4:	9f ef       	ldi	r25, 0xFF	; 255
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b0 e0       	ldi	r27, 0x00	; 0
      fa:	e8 22       	and	r14, r24
      fc:	f9 22       	and	r15, r25
      fe:	0a 23       	and	r16, r26
     100:	1b 23       	and	r17, r27
     102:	1a 01       	movw	r2, r20
     104:	44 24       	eor	r4, r4
     106:	55 24       	eor	r5, r5
     108:	29 85       	ldd	r18, Y+9	; 0x09
     10a:	3a 85       	ldd	r19, Y+10	; 0x0a
     10c:	4b 85       	ldd	r20, Y+11	; 0x0b
     10e:	5c 85       	ldd	r21, Y+12	; 0x0c
     110:	29 a7       	std	Y+41, r18	; 0x29
     112:	3a a7       	std	Y+42, r19	; 0x2a
     114:	4b a7       	std	Y+43, r20	; 0x2b
     116:	5c a7       	std	Y+44, r21	; 0x2c
     118:	59 01       	movw	r10, r18
     11a:	6a 01       	movw	r12, r20
     11c:	a8 22       	and	r10, r24
     11e:	b9 22       	and	r11, r25
     120:	ca 22       	and	r12, r26
     122:	db 22       	and	r13, r27
     124:	3a 01       	movw	r6, r20
     126:	88 24       	eor	r8, r8
     128:	99 24       	eor	r9, r9
     12a:	c6 01       	movw	r24, r12
     12c:	b5 01       	movw	r22, r10
     12e:	a8 01       	movw	r20, r16
     130:	97 01       	movw	r18, r14
     132:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     136:	6d a3       	std	Y+37, r22	; 0x25
     138:	7e a3       	std	Y+38, r23	; 0x26
     13a:	8f a3       	std	Y+39, r24	; 0x27
     13c:	98 a7       	std	Y+40, r25	; 0x28
     13e:	c4 01       	movw	r24, r8
     140:	b3 01       	movw	r22, r6
     142:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     146:	69 a3       	std	Y+33, r22	; 0x21
     148:	7a a3       	std	Y+34, r23	; 0x22
     14a:	8b a3       	std	Y+35, r24	; 0x23
     14c:	9c a3       	std	Y+36, r25	; 0x24
     14e:	c6 01       	movw	r24, r12
     150:	b5 01       	movw	r22, r10
     152:	a2 01       	movw	r20, r4
     154:	91 01       	movw	r18, r2
     156:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     15a:	7b 01       	movw	r14, r22
     15c:	8c 01       	movw	r16, r24
     15e:	c4 01       	movw	r24, r8
     160:	b3 01       	movw	r22, r6
     162:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     166:	5b 01       	movw	r10, r22
     168:	6c 01       	movw	r12, r24
     16a:	89 a1       	ldd	r24, Y+33	; 0x21
     16c:	9a a1       	ldd	r25, Y+34	; 0x22
     16e:	ab a1       	ldd	r26, Y+35	; 0x23
     170:	bc a1       	ldd	r27, Y+36	; 0x24
     172:	8e 0d       	add	r24, r14
     174:	9f 1d       	adc	r25, r15
     176:	a0 1f       	adc	r26, r16
     178:	b1 1f       	adc	r27, r17
     17a:	89 a3       	std	Y+33, r24	; 0x21
     17c:	9a a3       	std	Y+34, r25	; 0x22
     17e:	ab a3       	std	Y+35, r26	; 0x23
     180:	bc a3       	std	Y+36, r27	; 0x24
     182:	2d a1       	ldd	r18, Y+37	; 0x25
     184:	3e a1       	ldd	r19, Y+38	; 0x26
     186:	4f a1       	ldd	r20, Y+39	; 0x27
     188:	58 a5       	ldd	r21, Y+40	; 0x28
     18a:	ca 01       	movw	r24, r20
     18c:	aa 27       	eor	r26, r26
     18e:	bb 27       	eor	r27, r27
     190:	29 a1       	ldd	r18, Y+33	; 0x21
     192:	3a a1       	ldd	r19, Y+34	; 0x22
     194:	4b a1       	ldd	r20, Y+35	; 0x23
     196:	5c a1       	ldd	r21, Y+36	; 0x24
     198:	28 0f       	add	r18, r24
     19a:	39 1f       	adc	r19, r25
     19c:	4a 1f       	adc	r20, r26
     19e:	5b 1f       	adc	r21, r27
     1a0:	29 a3       	std	Y+33, r18	; 0x21
     1a2:	3a a3       	std	Y+34, r19	; 0x22
     1a4:	4b a3       	std	Y+35, r20	; 0x23
     1a6:	5c a3       	std	Y+36, r21	; 0x24
     1a8:	2e 15       	cp	r18, r14
     1aa:	3f 05       	cpc	r19, r15
     1ac:	40 07       	cpc	r20, r16
     1ae:	51 07       	cpc	r21, r17
     1b0:	40 f4       	brcc	.+16     	; 0x1c2 <__muldi3+0x130>
     1b2:	80 e0       	ldi	r24, 0x00	; 0
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	a1 e0       	ldi	r26, 0x01	; 1
     1b8:	b0 e0       	ldi	r27, 0x00	; 0
     1ba:	a8 0e       	add	r10, r24
     1bc:	b9 1e       	adc	r11, r25
     1be:	ca 1e       	adc	r12, r26
     1c0:	db 1e       	adc	r13, r27
     1c2:	89 a1       	ldd	r24, Y+33	; 0x21
     1c4:	9a a1       	ldd	r25, Y+34	; 0x22
     1c6:	ab a1       	ldd	r26, Y+35	; 0x23
     1c8:	bc a1       	ldd	r27, Y+36	; 0x24
     1ca:	9d 01       	movw	r18, r26
     1cc:	44 27       	eor	r20, r20
     1ce:	55 27       	eor	r21, r21
     1d0:	2a 0d       	add	r18, r10
     1d2:	3b 1d       	adc	r19, r11
     1d4:	4c 1d       	adc	r20, r12
     1d6:	5d 1d       	adc	r21, r13
     1d8:	2d 8f       	std	Y+29, r18	; 0x1d
     1da:	3e 8f       	std	Y+30, r19	; 0x1e
     1dc:	4f 8f       	std	Y+31, r20	; 0x1f
     1de:	58 a3       	std	Y+32, r21	; 0x20
     1e0:	6c 01       	movw	r12, r24
     1e2:	bb 24       	eor	r11, r11
     1e4:	aa 24       	eor	r10, r10
     1e6:	8d a1       	ldd	r24, Y+37	; 0x25
     1e8:	9e a1       	ldd	r25, Y+38	; 0x26
     1ea:	af a1       	ldd	r26, Y+39	; 0x27
     1ec:	b8 a5       	ldd	r27, Y+40	; 0x28
     1ee:	a0 70       	andi	r26, 0x00	; 0
     1f0:	b0 70       	andi	r27, 0x00	; 0
     1f2:	a8 0e       	add	r10, r24
     1f4:	b9 1e       	adc	r11, r25
     1f6:	ca 1e       	adc	r12, r26
     1f8:	db 1e       	adc	r13, r27
     1fa:	a9 8e       	std	Y+25, r10	; 0x19
     1fc:	ba 8e       	std	Y+26, r11	; 0x1a
     1fe:	cb 8e       	std	Y+27, r12	; 0x1b
     200:	dc 8e       	std	Y+28, r13	; 0x1c
     202:	9a 8c       	ldd	r9, Y+26	; 0x1a
     204:	8b 8c       	ldd	r8, Y+27	; 0x1b
     206:	7c 8c       	ldd	r7, Y+28	; 0x1c
     208:	9e 8d       	ldd	r25, Y+30	; 0x1e
     20a:	6f 8d       	ldd	r22, Y+31	; 0x1f
     20c:	78 a1       	ldd	r23, Y+32	; 0x20
     20e:	fe 01       	movw	r30, r28
     210:	71 96       	adiw	r30, 0x11	; 17
     212:	88 e0       	ldi	r24, 0x08	; 8
     214:	df 01       	movw	r26, r30
     216:	1d 92       	st	X+, r1
     218:	8a 95       	dec	r24
     21a:	e9 f7       	brne	.-6      	; 0x216 <__muldi3+0x184>
     21c:	2d 8b       	std	Y+21, r18	; 0x15
     21e:	9e 8b       	std	Y+22, r25	; 0x16
     220:	6f 8b       	std	Y+23, r22	; 0x17
     222:	78 8f       	std	Y+24, r23	; 0x18
     224:	2d 85       	ldd	r18, Y+13	; 0x0d
     226:	3e 85       	ldd	r19, Y+14	; 0x0e
     228:	4f 85       	ldd	r20, Y+15	; 0x0f
     22a:	58 89       	ldd	r21, Y+16	; 0x10
     22c:	6d a5       	ldd	r22, Y+45	; 0x2d
     22e:	7e a5       	ldd	r23, Y+46	; 0x2e
     230:	8f a5       	ldd	r24, Y+47	; 0x2f
     232:	98 a9       	ldd	r25, Y+48	; 0x30
     234:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     238:	7b 01       	movw	r14, r22
     23a:	8c 01       	movw	r16, r24
     23c:	2d 81       	ldd	r18, Y+5	; 0x05
     23e:	3e 81       	ldd	r19, Y+6	; 0x06
     240:	4f 81       	ldd	r20, Y+7	; 0x07
     242:	58 85       	ldd	r21, Y+8	; 0x08
     244:	69 a5       	ldd	r22, Y+41	; 0x29
     246:	7a a5       	ldd	r23, Y+42	; 0x2a
     248:	8b a5       	ldd	r24, Y+43	; 0x2b
     24a:	9c a5       	ldd	r25, Y+44	; 0x2c
     24c:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
     250:	e6 0e       	add	r14, r22
     252:	f7 1e       	adc	r15, r23
     254:	08 1f       	adc	r16, r24
     256:	19 1f       	adc	r17, r25
     258:	6d 89       	ldd	r22, Y+21	; 0x15
     25a:	7e 89       	ldd	r23, Y+22	; 0x16
     25c:	8f 89       	ldd	r24, Y+23	; 0x17
     25e:	98 8d       	ldd	r25, Y+24	; 0x18
     260:	6e 0d       	add	r22, r14
     262:	7f 1d       	adc	r23, r15
     264:	80 1f       	adc	r24, r16
     266:	91 1f       	adc	r25, r17
     268:	6d 8b       	std	Y+21, r22	; 0x15
     26a:	7e 8b       	std	Y+22, r23	; 0x16
     26c:	8f 8b       	std	Y+23, r24	; 0x17
     26e:	98 8f       	std	Y+24, r25	; 0x18
     270:	ee 89       	ldd	r30, Y+22	; 0x16
     272:	2a 2d       	mov	r18, r10
     274:	39 2d       	mov	r19, r9
     276:	48 2d       	mov	r20, r8
     278:	57 2d       	mov	r21, r7
     27a:	7e 2f       	mov	r23, r30
     27c:	8f 89       	ldd	r24, Y+23	; 0x17
     27e:	98 8d       	ldd	r25, Y+24	; 0x18
     280:	e0 96       	adiw	r28, 0x30	; 48
     282:	e2 e1       	ldi	r30, 0x12	; 18
     284:	0c 94 bb 42 	jmp	0x8576	; 0x8576 <__epilogue_restores__>

00000288 <__fixunssfsi>:
     288:	ef 92       	push	r14
     28a:	ff 92       	push	r15
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	7b 01       	movw	r14, r22
     292:	8c 01       	movw	r16, r24
     294:	20 e0       	ldi	r18, 0x00	; 0
     296:	30 e0       	ldi	r19, 0x00	; 0
     298:	40 e0       	ldi	r20, 0x00	; 0
     29a:	5f e4       	ldi	r21, 0x4F	; 79
     29c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__gesf2>
     2a0:	88 23       	and	r24, r24
     2a2:	8c f0       	brlt	.+34     	; 0x2c6 <__fixunssfsi+0x3e>
     2a4:	c8 01       	movw	r24, r16
     2a6:	b7 01       	movw	r22, r14
     2a8:	20 e0       	ldi	r18, 0x00	; 0
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	40 e0       	ldi	r20, 0x00	; 0
     2ae:	5f e4       	ldi	r21, 0x4F	; 79
     2b0:	0e 94 bc 02 	call	0x578	; 0x578 <__subsf3>
     2b4:	0e 94 50 05 	call	0xaa0	; 0xaa0 <__fixsfsi>
     2b8:	9b 01       	movw	r18, r22
     2ba:	ac 01       	movw	r20, r24
     2bc:	20 50       	subi	r18, 0x00	; 0
     2be:	30 40       	sbci	r19, 0x00	; 0
     2c0:	40 40       	sbci	r20, 0x00	; 0
     2c2:	50 48       	sbci	r21, 0x80	; 128
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <__fixunssfsi+0x4a>
     2c6:	c8 01       	movw	r24, r16
     2c8:	b7 01       	movw	r22, r14
     2ca:	0e 94 50 05 	call	0xaa0	; 0xaa0 <__fixsfsi>
     2ce:	9b 01       	movw	r18, r22
     2d0:	ac 01       	movw	r20, r24
     2d2:	b9 01       	movw	r22, r18
     2d4:	ca 01       	movw	r24, r20
     2d6:	1f 91       	pop	r17
     2d8:	0f 91       	pop	r16
     2da:	ff 90       	pop	r15
     2dc:	ef 90       	pop	r14
     2de:	08 95       	ret

000002e0 <_fpadd_parts>:
     2e0:	a0 e0       	ldi	r26, 0x00	; 0
     2e2:	b0 e0       	ldi	r27, 0x00	; 0
     2e4:	e6 e7       	ldi	r30, 0x76	; 118
     2e6:	f1 e0       	ldi	r31, 0x01	; 1
     2e8:	0c 94 9f 42 	jmp	0x853e	; 0x853e <__prologue_saves__>
     2ec:	dc 01       	movw	r26, r24
     2ee:	2b 01       	movw	r4, r22
     2f0:	fa 01       	movw	r30, r20
     2f2:	9c 91       	ld	r25, X
     2f4:	92 30       	cpi	r25, 0x02	; 2
     2f6:	08 f4       	brcc	.+2      	; 0x2fa <_fpadd_parts+0x1a>
     2f8:	39 c1       	rjmp	.+626    	; 0x56c <_fpadd_parts+0x28c>
     2fa:	eb 01       	movw	r28, r22
     2fc:	88 81       	ld	r24, Y
     2fe:	82 30       	cpi	r24, 0x02	; 2
     300:	08 f4       	brcc	.+2      	; 0x304 <_fpadd_parts+0x24>
     302:	33 c1       	rjmp	.+614    	; 0x56a <_fpadd_parts+0x28a>
     304:	94 30       	cpi	r25, 0x04	; 4
     306:	69 f4       	brne	.+26     	; 0x322 <_fpadd_parts+0x42>
     308:	84 30       	cpi	r24, 0x04	; 4
     30a:	09 f0       	breq	.+2      	; 0x30e <_fpadd_parts+0x2e>
     30c:	2f c1       	rjmp	.+606    	; 0x56c <_fpadd_parts+0x28c>
     30e:	11 96       	adiw	r26, 0x01	; 1
     310:	9c 91       	ld	r25, X
     312:	11 97       	sbiw	r26, 0x01	; 1
     314:	89 81       	ldd	r24, Y+1	; 0x01
     316:	98 17       	cp	r25, r24
     318:	09 f4       	brne	.+2      	; 0x31c <_fpadd_parts+0x3c>
     31a:	28 c1       	rjmp	.+592    	; 0x56c <_fpadd_parts+0x28c>
     31c:	a2 ee       	ldi	r26, 0xE2	; 226
     31e:	b0 e0       	ldi	r27, 0x00	; 0
     320:	25 c1       	rjmp	.+586    	; 0x56c <_fpadd_parts+0x28c>
     322:	84 30       	cpi	r24, 0x04	; 4
     324:	09 f4       	brne	.+2      	; 0x328 <_fpadd_parts+0x48>
     326:	21 c1       	rjmp	.+578    	; 0x56a <_fpadd_parts+0x28a>
     328:	82 30       	cpi	r24, 0x02	; 2
     32a:	a9 f4       	brne	.+42     	; 0x356 <_fpadd_parts+0x76>
     32c:	92 30       	cpi	r25, 0x02	; 2
     32e:	09 f0       	breq	.+2      	; 0x332 <_fpadd_parts+0x52>
     330:	1d c1       	rjmp	.+570    	; 0x56c <_fpadd_parts+0x28c>
     332:	9a 01       	movw	r18, r20
     334:	ad 01       	movw	r20, r26
     336:	88 e0       	ldi	r24, 0x08	; 8
     338:	ea 01       	movw	r28, r20
     33a:	09 90       	ld	r0, Y+
     33c:	ae 01       	movw	r20, r28
     33e:	e9 01       	movw	r28, r18
     340:	09 92       	st	Y+, r0
     342:	9e 01       	movw	r18, r28
     344:	81 50       	subi	r24, 0x01	; 1
     346:	c1 f7       	brne	.-16     	; 0x338 <_fpadd_parts+0x58>
     348:	e2 01       	movw	r28, r4
     34a:	89 81       	ldd	r24, Y+1	; 0x01
     34c:	11 96       	adiw	r26, 0x01	; 1
     34e:	9c 91       	ld	r25, X
     350:	89 23       	and	r24, r25
     352:	81 83       	std	Z+1, r24	; 0x01
     354:	08 c1       	rjmp	.+528    	; 0x566 <_fpadd_parts+0x286>
     356:	92 30       	cpi	r25, 0x02	; 2
     358:	09 f4       	brne	.+2      	; 0x35c <_fpadd_parts+0x7c>
     35a:	07 c1       	rjmp	.+526    	; 0x56a <_fpadd_parts+0x28a>
     35c:	12 96       	adiw	r26, 0x02	; 2
     35e:	2d 90       	ld	r2, X+
     360:	3c 90       	ld	r3, X
     362:	13 97       	sbiw	r26, 0x03	; 3
     364:	eb 01       	movw	r28, r22
     366:	8a 81       	ldd	r24, Y+2	; 0x02
     368:	9b 81       	ldd	r25, Y+3	; 0x03
     36a:	14 96       	adiw	r26, 0x04	; 4
     36c:	ad 90       	ld	r10, X+
     36e:	bd 90       	ld	r11, X+
     370:	cd 90       	ld	r12, X+
     372:	dc 90       	ld	r13, X
     374:	17 97       	sbiw	r26, 0x07	; 7
     376:	ec 80       	ldd	r14, Y+4	; 0x04
     378:	fd 80       	ldd	r15, Y+5	; 0x05
     37a:	0e 81       	ldd	r16, Y+6	; 0x06
     37c:	1f 81       	ldd	r17, Y+7	; 0x07
     37e:	91 01       	movw	r18, r2
     380:	28 1b       	sub	r18, r24
     382:	39 0b       	sbc	r19, r25
     384:	b9 01       	movw	r22, r18
     386:	37 ff       	sbrs	r19, 7
     388:	04 c0       	rjmp	.+8      	; 0x392 <_fpadd_parts+0xb2>
     38a:	66 27       	eor	r22, r22
     38c:	77 27       	eor	r23, r23
     38e:	62 1b       	sub	r22, r18
     390:	73 0b       	sbc	r23, r19
     392:	60 32       	cpi	r22, 0x20	; 32
     394:	71 05       	cpc	r23, r1
     396:	0c f0       	brlt	.+2      	; 0x39a <_fpadd_parts+0xba>
     398:	61 c0       	rjmp	.+194    	; 0x45c <_fpadd_parts+0x17c>
     39a:	12 16       	cp	r1, r18
     39c:	13 06       	cpc	r1, r19
     39e:	6c f5       	brge	.+90     	; 0x3fa <_fpadd_parts+0x11a>
     3a0:	37 01       	movw	r6, r14
     3a2:	48 01       	movw	r8, r16
     3a4:	06 2e       	mov	r0, r22
     3a6:	04 c0       	rjmp	.+8      	; 0x3b0 <_fpadd_parts+0xd0>
     3a8:	96 94       	lsr	r9
     3aa:	87 94       	ror	r8
     3ac:	77 94       	ror	r7
     3ae:	67 94       	ror	r6
     3b0:	0a 94       	dec	r0
     3b2:	d2 f7       	brpl	.-12     	; 0x3a8 <_fpadd_parts+0xc8>
     3b4:	21 e0       	ldi	r18, 0x01	; 1
     3b6:	30 e0       	ldi	r19, 0x00	; 0
     3b8:	40 e0       	ldi	r20, 0x00	; 0
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	04 c0       	rjmp	.+8      	; 0x3c6 <_fpadd_parts+0xe6>
     3be:	22 0f       	add	r18, r18
     3c0:	33 1f       	adc	r19, r19
     3c2:	44 1f       	adc	r20, r20
     3c4:	55 1f       	adc	r21, r21
     3c6:	6a 95       	dec	r22
     3c8:	d2 f7       	brpl	.-12     	; 0x3be <_fpadd_parts+0xde>
     3ca:	21 50       	subi	r18, 0x01	; 1
     3cc:	30 40       	sbci	r19, 0x00	; 0
     3ce:	40 40       	sbci	r20, 0x00	; 0
     3d0:	50 40       	sbci	r21, 0x00	; 0
     3d2:	2e 21       	and	r18, r14
     3d4:	3f 21       	and	r19, r15
     3d6:	40 23       	and	r20, r16
     3d8:	51 23       	and	r21, r17
     3da:	21 15       	cp	r18, r1
     3dc:	31 05       	cpc	r19, r1
     3de:	41 05       	cpc	r20, r1
     3e0:	51 05       	cpc	r21, r1
     3e2:	21 f0       	breq	.+8      	; 0x3ec <_fpadd_parts+0x10c>
     3e4:	21 e0       	ldi	r18, 0x01	; 1
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	50 e0       	ldi	r21, 0x00	; 0
     3ec:	79 01       	movw	r14, r18
     3ee:	8a 01       	movw	r16, r20
     3f0:	e6 28       	or	r14, r6
     3f2:	f7 28       	or	r15, r7
     3f4:	08 29       	or	r16, r8
     3f6:	19 29       	or	r17, r9
     3f8:	3c c0       	rjmp	.+120    	; 0x472 <_fpadd_parts+0x192>
     3fa:	23 2b       	or	r18, r19
     3fc:	d1 f1       	breq	.+116    	; 0x472 <_fpadd_parts+0x192>
     3fe:	26 0e       	add	r2, r22
     400:	37 1e       	adc	r3, r23
     402:	35 01       	movw	r6, r10
     404:	46 01       	movw	r8, r12
     406:	06 2e       	mov	r0, r22
     408:	04 c0       	rjmp	.+8      	; 0x412 <_fpadd_parts+0x132>
     40a:	96 94       	lsr	r9
     40c:	87 94       	ror	r8
     40e:	77 94       	ror	r7
     410:	67 94       	ror	r6
     412:	0a 94       	dec	r0
     414:	d2 f7       	brpl	.-12     	; 0x40a <_fpadd_parts+0x12a>
     416:	21 e0       	ldi	r18, 0x01	; 1
     418:	30 e0       	ldi	r19, 0x00	; 0
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	50 e0       	ldi	r21, 0x00	; 0
     41e:	04 c0       	rjmp	.+8      	; 0x428 <_fpadd_parts+0x148>
     420:	22 0f       	add	r18, r18
     422:	33 1f       	adc	r19, r19
     424:	44 1f       	adc	r20, r20
     426:	55 1f       	adc	r21, r21
     428:	6a 95       	dec	r22
     42a:	d2 f7       	brpl	.-12     	; 0x420 <_fpadd_parts+0x140>
     42c:	21 50       	subi	r18, 0x01	; 1
     42e:	30 40       	sbci	r19, 0x00	; 0
     430:	40 40       	sbci	r20, 0x00	; 0
     432:	50 40       	sbci	r21, 0x00	; 0
     434:	2a 21       	and	r18, r10
     436:	3b 21       	and	r19, r11
     438:	4c 21       	and	r20, r12
     43a:	5d 21       	and	r21, r13
     43c:	21 15       	cp	r18, r1
     43e:	31 05       	cpc	r19, r1
     440:	41 05       	cpc	r20, r1
     442:	51 05       	cpc	r21, r1
     444:	21 f0       	breq	.+8      	; 0x44e <_fpadd_parts+0x16e>
     446:	21 e0       	ldi	r18, 0x01	; 1
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	40 e0       	ldi	r20, 0x00	; 0
     44c:	50 e0       	ldi	r21, 0x00	; 0
     44e:	59 01       	movw	r10, r18
     450:	6a 01       	movw	r12, r20
     452:	a6 28       	or	r10, r6
     454:	b7 28       	or	r11, r7
     456:	c8 28       	or	r12, r8
     458:	d9 28       	or	r13, r9
     45a:	0b c0       	rjmp	.+22     	; 0x472 <_fpadd_parts+0x192>
     45c:	82 15       	cp	r24, r2
     45e:	93 05       	cpc	r25, r3
     460:	2c f0       	brlt	.+10     	; 0x46c <_fpadd_parts+0x18c>
     462:	1c 01       	movw	r2, r24
     464:	aa 24       	eor	r10, r10
     466:	bb 24       	eor	r11, r11
     468:	65 01       	movw	r12, r10
     46a:	03 c0       	rjmp	.+6      	; 0x472 <_fpadd_parts+0x192>
     46c:	ee 24       	eor	r14, r14
     46e:	ff 24       	eor	r15, r15
     470:	87 01       	movw	r16, r14
     472:	11 96       	adiw	r26, 0x01	; 1
     474:	9c 91       	ld	r25, X
     476:	d2 01       	movw	r26, r4
     478:	11 96       	adiw	r26, 0x01	; 1
     47a:	8c 91       	ld	r24, X
     47c:	98 17       	cp	r25, r24
     47e:	09 f4       	brne	.+2      	; 0x482 <_fpadd_parts+0x1a2>
     480:	45 c0       	rjmp	.+138    	; 0x50c <_fpadd_parts+0x22c>
     482:	99 23       	and	r25, r25
     484:	39 f0       	breq	.+14     	; 0x494 <_fpadd_parts+0x1b4>
     486:	a8 01       	movw	r20, r16
     488:	97 01       	movw	r18, r14
     48a:	2a 19       	sub	r18, r10
     48c:	3b 09       	sbc	r19, r11
     48e:	4c 09       	sbc	r20, r12
     490:	5d 09       	sbc	r21, r13
     492:	06 c0       	rjmp	.+12     	; 0x4a0 <_fpadd_parts+0x1c0>
     494:	a6 01       	movw	r20, r12
     496:	95 01       	movw	r18, r10
     498:	2e 19       	sub	r18, r14
     49a:	3f 09       	sbc	r19, r15
     49c:	40 0b       	sbc	r20, r16
     49e:	51 0b       	sbc	r21, r17
     4a0:	57 fd       	sbrc	r21, 7
     4a2:	08 c0       	rjmp	.+16     	; 0x4b4 <_fpadd_parts+0x1d4>
     4a4:	11 82       	std	Z+1, r1	; 0x01
     4a6:	33 82       	std	Z+3, r3	; 0x03
     4a8:	22 82       	std	Z+2, r2	; 0x02
     4aa:	24 83       	std	Z+4, r18	; 0x04
     4ac:	35 83       	std	Z+5, r19	; 0x05
     4ae:	46 83       	std	Z+6, r20	; 0x06
     4b0:	57 83       	std	Z+7, r21	; 0x07
     4b2:	1d c0       	rjmp	.+58     	; 0x4ee <_fpadd_parts+0x20e>
     4b4:	81 e0       	ldi	r24, 0x01	; 1
     4b6:	81 83       	std	Z+1, r24	; 0x01
     4b8:	33 82       	std	Z+3, r3	; 0x03
     4ba:	22 82       	std	Z+2, r2	; 0x02
     4bc:	88 27       	eor	r24, r24
     4be:	99 27       	eor	r25, r25
     4c0:	dc 01       	movw	r26, r24
     4c2:	82 1b       	sub	r24, r18
     4c4:	93 0b       	sbc	r25, r19
     4c6:	a4 0b       	sbc	r26, r20
     4c8:	b5 0b       	sbc	r27, r21
     4ca:	84 83       	std	Z+4, r24	; 0x04
     4cc:	95 83       	std	Z+5, r25	; 0x05
     4ce:	a6 83       	std	Z+6, r26	; 0x06
     4d0:	b7 83       	std	Z+7, r27	; 0x07
     4d2:	0d c0       	rjmp	.+26     	; 0x4ee <_fpadd_parts+0x20e>
     4d4:	22 0f       	add	r18, r18
     4d6:	33 1f       	adc	r19, r19
     4d8:	44 1f       	adc	r20, r20
     4da:	55 1f       	adc	r21, r21
     4dc:	24 83       	std	Z+4, r18	; 0x04
     4de:	35 83       	std	Z+5, r19	; 0x05
     4e0:	46 83       	std	Z+6, r20	; 0x06
     4e2:	57 83       	std	Z+7, r21	; 0x07
     4e4:	82 81       	ldd	r24, Z+2	; 0x02
     4e6:	93 81       	ldd	r25, Z+3	; 0x03
     4e8:	01 97       	sbiw	r24, 0x01	; 1
     4ea:	93 83       	std	Z+3, r25	; 0x03
     4ec:	82 83       	std	Z+2, r24	; 0x02
     4ee:	24 81       	ldd	r18, Z+4	; 0x04
     4f0:	35 81       	ldd	r19, Z+5	; 0x05
     4f2:	46 81       	ldd	r20, Z+6	; 0x06
     4f4:	57 81       	ldd	r21, Z+7	; 0x07
     4f6:	da 01       	movw	r26, r20
     4f8:	c9 01       	movw	r24, r18
     4fa:	01 97       	sbiw	r24, 0x01	; 1
     4fc:	a1 09       	sbc	r26, r1
     4fe:	b1 09       	sbc	r27, r1
     500:	8f 5f       	subi	r24, 0xFF	; 255
     502:	9f 4f       	sbci	r25, 0xFF	; 255
     504:	af 4f       	sbci	r26, 0xFF	; 255
     506:	bf 43       	sbci	r27, 0x3F	; 63
     508:	28 f3       	brcs	.-54     	; 0x4d4 <_fpadd_parts+0x1f4>
     50a:	0b c0       	rjmp	.+22     	; 0x522 <_fpadd_parts+0x242>
     50c:	91 83       	std	Z+1, r25	; 0x01
     50e:	33 82       	std	Z+3, r3	; 0x03
     510:	22 82       	std	Z+2, r2	; 0x02
     512:	ea 0c       	add	r14, r10
     514:	fb 1c       	adc	r15, r11
     516:	0c 1d       	adc	r16, r12
     518:	1d 1d       	adc	r17, r13
     51a:	e4 82       	std	Z+4, r14	; 0x04
     51c:	f5 82       	std	Z+5, r15	; 0x05
     51e:	06 83       	std	Z+6, r16	; 0x06
     520:	17 83       	std	Z+7, r17	; 0x07
     522:	83 e0       	ldi	r24, 0x03	; 3
     524:	80 83       	st	Z, r24
     526:	24 81       	ldd	r18, Z+4	; 0x04
     528:	35 81       	ldd	r19, Z+5	; 0x05
     52a:	46 81       	ldd	r20, Z+6	; 0x06
     52c:	57 81       	ldd	r21, Z+7	; 0x07
     52e:	57 ff       	sbrs	r21, 7
     530:	1a c0       	rjmp	.+52     	; 0x566 <_fpadd_parts+0x286>
     532:	c9 01       	movw	r24, r18
     534:	aa 27       	eor	r26, r26
     536:	97 fd       	sbrc	r25, 7
     538:	a0 95       	com	r26
     53a:	ba 2f       	mov	r27, r26
     53c:	81 70       	andi	r24, 0x01	; 1
     53e:	90 70       	andi	r25, 0x00	; 0
     540:	a0 70       	andi	r26, 0x00	; 0
     542:	b0 70       	andi	r27, 0x00	; 0
     544:	56 95       	lsr	r21
     546:	47 95       	ror	r20
     548:	37 95       	ror	r19
     54a:	27 95       	ror	r18
     54c:	82 2b       	or	r24, r18
     54e:	93 2b       	or	r25, r19
     550:	a4 2b       	or	r26, r20
     552:	b5 2b       	or	r27, r21
     554:	84 83       	std	Z+4, r24	; 0x04
     556:	95 83       	std	Z+5, r25	; 0x05
     558:	a6 83       	std	Z+6, r26	; 0x06
     55a:	b7 83       	std	Z+7, r27	; 0x07
     55c:	82 81       	ldd	r24, Z+2	; 0x02
     55e:	93 81       	ldd	r25, Z+3	; 0x03
     560:	01 96       	adiw	r24, 0x01	; 1
     562:	93 83       	std	Z+3, r25	; 0x03
     564:	82 83       	std	Z+2, r24	; 0x02
     566:	df 01       	movw	r26, r30
     568:	01 c0       	rjmp	.+2      	; 0x56c <_fpadd_parts+0x28c>
     56a:	d2 01       	movw	r26, r4
     56c:	cd 01       	movw	r24, r26
     56e:	cd b7       	in	r28, 0x3d	; 61
     570:	de b7       	in	r29, 0x3e	; 62
     572:	e2 e1       	ldi	r30, 0x12	; 18
     574:	0c 94 bb 42 	jmp	0x8576	; 0x8576 <__epilogue_restores__>

00000578 <__subsf3>:
     578:	a0 e2       	ldi	r26, 0x20	; 32
     57a:	b0 e0       	ldi	r27, 0x00	; 0
     57c:	e2 ec       	ldi	r30, 0xC2	; 194
     57e:	f2 e0       	ldi	r31, 0x02	; 2
     580:	0c 94 ab 42 	jmp	0x8556	; 0x8556 <__prologue_saves__+0x18>
     584:	69 83       	std	Y+1, r22	; 0x01
     586:	7a 83       	std	Y+2, r23	; 0x02
     588:	8b 83       	std	Y+3, r24	; 0x03
     58a:	9c 83       	std	Y+4, r25	; 0x04
     58c:	2d 83       	std	Y+5, r18	; 0x05
     58e:	3e 83       	std	Y+6, r19	; 0x06
     590:	4f 83       	std	Y+7, r20	; 0x07
     592:	58 87       	std	Y+8, r21	; 0x08
     594:	e9 e0       	ldi	r30, 0x09	; 9
     596:	ee 2e       	mov	r14, r30
     598:	f1 2c       	mov	r15, r1
     59a:	ec 0e       	add	r14, r28
     59c:	fd 1e       	adc	r15, r29
     59e:	ce 01       	movw	r24, r28
     5a0:	01 96       	adiw	r24, 0x01	; 1
     5a2:	b7 01       	movw	r22, r14
     5a4:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     5a8:	8e 01       	movw	r16, r28
     5aa:	0f 5e       	subi	r16, 0xEF	; 239
     5ac:	1f 4f       	sbci	r17, 0xFF	; 255
     5ae:	ce 01       	movw	r24, r28
     5b0:	05 96       	adiw	r24, 0x05	; 5
     5b2:	b8 01       	movw	r22, r16
     5b4:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     5b8:	8a 89       	ldd	r24, Y+18	; 0x12
     5ba:	91 e0       	ldi	r25, 0x01	; 1
     5bc:	89 27       	eor	r24, r25
     5be:	8a 8b       	std	Y+18, r24	; 0x12
     5c0:	c7 01       	movw	r24, r14
     5c2:	b8 01       	movw	r22, r16
     5c4:	ae 01       	movw	r20, r28
     5c6:	47 5e       	subi	r20, 0xE7	; 231
     5c8:	5f 4f       	sbci	r21, 0xFF	; 255
     5ca:	0e 94 70 01 	call	0x2e0	; 0x2e0 <_fpadd_parts>
     5ce:	0e 94 a4 05 	call	0xb48	; 0xb48 <__pack_f>
     5d2:	a0 96       	adiw	r28, 0x20	; 32
     5d4:	e6 e0       	ldi	r30, 0x06	; 6
     5d6:	0c 94 c7 42 	jmp	0x858e	; 0x858e <__epilogue_restores__+0x18>

000005da <__addsf3>:
     5da:	a0 e2       	ldi	r26, 0x20	; 32
     5dc:	b0 e0       	ldi	r27, 0x00	; 0
     5de:	e3 ef       	ldi	r30, 0xF3	; 243
     5e0:	f2 e0       	ldi	r31, 0x02	; 2
     5e2:	0c 94 ab 42 	jmp	0x8556	; 0x8556 <__prologue_saves__+0x18>
     5e6:	69 83       	std	Y+1, r22	; 0x01
     5e8:	7a 83       	std	Y+2, r23	; 0x02
     5ea:	8b 83       	std	Y+3, r24	; 0x03
     5ec:	9c 83       	std	Y+4, r25	; 0x04
     5ee:	2d 83       	std	Y+5, r18	; 0x05
     5f0:	3e 83       	std	Y+6, r19	; 0x06
     5f2:	4f 83       	std	Y+7, r20	; 0x07
     5f4:	58 87       	std	Y+8, r21	; 0x08
     5f6:	f9 e0       	ldi	r31, 0x09	; 9
     5f8:	ef 2e       	mov	r14, r31
     5fa:	f1 2c       	mov	r15, r1
     5fc:	ec 0e       	add	r14, r28
     5fe:	fd 1e       	adc	r15, r29
     600:	ce 01       	movw	r24, r28
     602:	01 96       	adiw	r24, 0x01	; 1
     604:	b7 01       	movw	r22, r14
     606:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     60a:	8e 01       	movw	r16, r28
     60c:	0f 5e       	subi	r16, 0xEF	; 239
     60e:	1f 4f       	sbci	r17, 0xFF	; 255
     610:	ce 01       	movw	r24, r28
     612:	05 96       	adiw	r24, 0x05	; 5
     614:	b8 01       	movw	r22, r16
     616:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     61a:	c7 01       	movw	r24, r14
     61c:	b8 01       	movw	r22, r16
     61e:	ae 01       	movw	r20, r28
     620:	47 5e       	subi	r20, 0xE7	; 231
     622:	5f 4f       	sbci	r21, 0xFF	; 255
     624:	0e 94 70 01 	call	0x2e0	; 0x2e0 <_fpadd_parts>
     628:	0e 94 a4 05 	call	0xb48	; 0xb48 <__pack_f>
     62c:	a0 96       	adiw	r28, 0x20	; 32
     62e:	e6 e0       	ldi	r30, 0x06	; 6
     630:	0c 94 c7 42 	jmp	0x858e	; 0x858e <__epilogue_restores__+0x18>

00000634 <__mulsf3>:
     634:	a0 e2       	ldi	r26, 0x20	; 32
     636:	b0 e0       	ldi	r27, 0x00	; 0
     638:	e0 e2       	ldi	r30, 0x20	; 32
     63a:	f3 e0       	ldi	r31, 0x03	; 3
     63c:	0c 94 9f 42 	jmp	0x853e	; 0x853e <__prologue_saves__>
     640:	69 83       	std	Y+1, r22	; 0x01
     642:	7a 83       	std	Y+2, r23	; 0x02
     644:	8b 83       	std	Y+3, r24	; 0x03
     646:	9c 83       	std	Y+4, r25	; 0x04
     648:	2d 83       	std	Y+5, r18	; 0x05
     64a:	3e 83       	std	Y+6, r19	; 0x06
     64c:	4f 83       	std	Y+7, r20	; 0x07
     64e:	58 87       	std	Y+8, r21	; 0x08
     650:	ce 01       	movw	r24, r28
     652:	01 96       	adiw	r24, 0x01	; 1
     654:	be 01       	movw	r22, r28
     656:	67 5f       	subi	r22, 0xF7	; 247
     658:	7f 4f       	sbci	r23, 0xFF	; 255
     65a:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     65e:	ce 01       	movw	r24, r28
     660:	05 96       	adiw	r24, 0x05	; 5
     662:	be 01       	movw	r22, r28
     664:	6f 5e       	subi	r22, 0xEF	; 239
     666:	7f 4f       	sbci	r23, 0xFF	; 255
     668:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     66c:	99 85       	ldd	r25, Y+9	; 0x09
     66e:	92 30       	cpi	r25, 0x02	; 2
     670:	88 f0       	brcs	.+34     	; 0x694 <__mulsf3+0x60>
     672:	89 89       	ldd	r24, Y+17	; 0x11
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	c8 f0       	brcs	.+50     	; 0x6aa <__mulsf3+0x76>
     678:	94 30       	cpi	r25, 0x04	; 4
     67a:	19 f4       	brne	.+6      	; 0x682 <__mulsf3+0x4e>
     67c:	82 30       	cpi	r24, 0x02	; 2
     67e:	51 f4       	brne	.+20     	; 0x694 <__mulsf3+0x60>
     680:	04 c0       	rjmp	.+8      	; 0x68a <__mulsf3+0x56>
     682:	84 30       	cpi	r24, 0x04	; 4
     684:	29 f4       	brne	.+10     	; 0x690 <__mulsf3+0x5c>
     686:	92 30       	cpi	r25, 0x02	; 2
     688:	81 f4       	brne	.+32     	; 0x6aa <__mulsf3+0x76>
     68a:	82 ee       	ldi	r24, 0xE2	; 226
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	c6 c0       	rjmp	.+396    	; 0x81c <__mulsf3+0x1e8>
     690:	92 30       	cpi	r25, 0x02	; 2
     692:	49 f4       	brne	.+18     	; 0x6a6 <__mulsf3+0x72>
     694:	20 e0       	ldi	r18, 0x00	; 0
     696:	9a 85       	ldd	r25, Y+10	; 0x0a
     698:	8a 89       	ldd	r24, Y+18	; 0x12
     69a:	98 13       	cpse	r25, r24
     69c:	21 e0       	ldi	r18, 0x01	; 1
     69e:	2a 87       	std	Y+10, r18	; 0x0a
     6a0:	ce 01       	movw	r24, r28
     6a2:	09 96       	adiw	r24, 0x09	; 9
     6a4:	bb c0       	rjmp	.+374    	; 0x81c <__mulsf3+0x1e8>
     6a6:	82 30       	cpi	r24, 0x02	; 2
     6a8:	49 f4       	brne	.+18     	; 0x6bc <__mulsf3+0x88>
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	9a 85       	ldd	r25, Y+10	; 0x0a
     6ae:	8a 89       	ldd	r24, Y+18	; 0x12
     6b0:	98 13       	cpse	r25, r24
     6b2:	21 e0       	ldi	r18, 0x01	; 1
     6b4:	2a 8b       	std	Y+18, r18	; 0x12
     6b6:	ce 01       	movw	r24, r28
     6b8:	41 96       	adiw	r24, 0x11	; 17
     6ba:	b0 c0       	rjmp	.+352    	; 0x81c <__mulsf3+0x1e8>
     6bc:	2d 84       	ldd	r2, Y+13	; 0x0d
     6be:	3e 84       	ldd	r3, Y+14	; 0x0e
     6c0:	4f 84       	ldd	r4, Y+15	; 0x0f
     6c2:	58 88       	ldd	r5, Y+16	; 0x10
     6c4:	6d 88       	ldd	r6, Y+21	; 0x15
     6c6:	7e 88       	ldd	r7, Y+22	; 0x16
     6c8:	8f 88       	ldd	r8, Y+23	; 0x17
     6ca:	98 8c       	ldd	r9, Y+24	; 0x18
     6cc:	ee 24       	eor	r14, r14
     6ce:	ff 24       	eor	r15, r15
     6d0:	87 01       	movw	r16, r14
     6d2:	aa 24       	eor	r10, r10
     6d4:	bb 24       	eor	r11, r11
     6d6:	65 01       	movw	r12, r10
     6d8:	40 e0       	ldi	r20, 0x00	; 0
     6da:	50 e0       	ldi	r21, 0x00	; 0
     6dc:	60 e0       	ldi	r22, 0x00	; 0
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	e0 e0       	ldi	r30, 0x00	; 0
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	c1 01       	movw	r24, r2
     6e6:	81 70       	andi	r24, 0x01	; 1
     6e8:	90 70       	andi	r25, 0x00	; 0
     6ea:	89 2b       	or	r24, r25
     6ec:	e9 f0       	breq	.+58     	; 0x728 <__mulsf3+0xf4>
     6ee:	e6 0c       	add	r14, r6
     6f0:	f7 1c       	adc	r15, r7
     6f2:	08 1d       	adc	r16, r8
     6f4:	19 1d       	adc	r17, r9
     6f6:	9a 01       	movw	r18, r20
     6f8:	ab 01       	movw	r20, r22
     6fa:	2a 0d       	add	r18, r10
     6fc:	3b 1d       	adc	r19, r11
     6fe:	4c 1d       	adc	r20, r12
     700:	5d 1d       	adc	r21, r13
     702:	80 e0       	ldi	r24, 0x00	; 0
     704:	90 e0       	ldi	r25, 0x00	; 0
     706:	a0 e0       	ldi	r26, 0x00	; 0
     708:	b0 e0       	ldi	r27, 0x00	; 0
     70a:	e6 14       	cp	r14, r6
     70c:	f7 04       	cpc	r15, r7
     70e:	08 05       	cpc	r16, r8
     710:	19 05       	cpc	r17, r9
     712:	20 f4       	brcc	.+8      	; 0x71c <__mulsf3+0xe8>
     714:	81 e0       	ldi	r24, 0x01	; 1
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	a0 e0       	ldi	r26, 0x00	; 0
     71a:	b0 e0       	ldi	r27, 0x00	; 0
     71c:	ba 01       	movw	r22, r20
     71e:	a9 01       	movw	r20, r18
     720:	48 0f       	add	r20, r24
     722:	59 1f       	adc	r21, r25
     724:	6a 1f       	adc	r22, r26
     726:	7b 1f       	adc	r23, r27
     728:	aa 0c       	add	r10, r10
     72a:	bb 1c       	adc	r11, r11
     72c:	cc 1c       	adc	r12, r12
     72e:	dd 1c       	adc	r13, r13
     730:	97 fe       	sbrs	r9, 7
     732:	08 c0       	rjmp	.+16     	; 0x744 <__mulsf3+0x110>
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	a0 e0       	ldi	r26, 0x00	; 0
     73a:	b0 e0       	ldi	r27, 0x00	; 0
     73c:	a8 2a       	or	r10, r24
     73e:	b9 2a       	or	r11, r25
     740:	ca 2a       	or	r12, r26
     742:	db 2a       	or	r13, r27
     744:	31 96       	adiw	r30, 0x01	; 1
     746:	e0 32       	cpi	r30, 0x20	; 32
     748:	f1 05       	cpc	r31, r1
     74a:	49 f0       	breq	.+18     	; 0x75e <__mulsf3+0x12a>
     74c:	66 0c       	add	r6, r6
     74e:	77 1c       	adc	r7, r7
     750:	88 1c       	adc	r8, r8
     752:	99 1c       	adc	r9, r9
     754:	56 94       	lsr	r5
     756:	47 94       	ror	r4
     758:	37 94       	ror	r3
     75a:	27 94       	ror	r2
     75c:	c3 cf       	rjmp	.-122    	; 0x6e4 <__mulsf3+0xb0>
     75e:	fa 85       	ldd	r31, Y+10	; 0x0a
     760:	ea 89       	ldd	r30, Y+18	; 0x12
     762:	2b 89       	ldd	r18, Y+19	; 0x13
     764:	3c 89       	ldd	r19, Y+20	; 0x14
     766:	8b 85       	ldd	r24, Y+11	; 0x0b
     768:	9c 85       	ldd	r25, Y+12	; 0x0c
     76a:	28 0f       	add	r18, r24
     76c:	39 1f       	adc	r19, r25
     76e:	2e 5f       	subi	r18, 0xFE	; 254
     770:	3f 4f       	sbci	r19, 0xFF	; 255
     772:	17 c0       	rjmp	.+46     	; 0x7a2 <__mulsf3+0x16e>
     774:	ca 01       	movw	r24, r20
     776:	81 70       	andi	r24, 0x01	; 1
     778:	90 70       	andi	r25, 0x00	; 0
     77a:	89 2b       	or	r24, r25
     77c:	61 f0       	breq	.+24     	; 0x796 <__mulsf3+0x162>
     77e:	16 95       	lsr	r17
     780:	07 95       	ror	r16
     782:	f7 94       	ror	r15
     784:	e7 94       	ror	r14
     786:	80 e0       	ldi	r24, 0x00	; 0
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	a0 e0       	ldi	r26, 0x00	; 0
     78c:	b0 e8       	ldi	r27, 0x80	; 128
     78e:	e8 2a       	or	r14, r24
     790:	f9 2a       	or	r15, r25
     792:	0a 2b       	or	r16, r26
     794:	1b 2b       	or	r17, r27
     796:	76 95       	lsr	r23
     798:	67 95       	ror	r22
     79a:	57 95       	ror	r21
     79c:	47 95       	ror	r20
     79e:	2f 5f       	subi	r18, 0xFF	; 255
     7a0:	3f 4f       	sbci	r19, 0xFF	; 255
     7a2:	77 fd       	sbrc	r23, 7
     7a4:	e7 cf       	rjmp	.-50     	; 0x774 <__mulsf3+0x140>
     7a6:	0c c0       	rjmp	.+24     	; 0x7c0 <__mulsf3+0x18c>
     7a8:	44 0f       	add	r20, r20
     7aa:	55 1f       	adc	r21, r21
     7ac:	66 1f       	adc	r22, r22
     7ae:	77 1f       	adc	r23, r23
     7b0:	17 fd       	sbrc	r17, 7
     7b2:	41 60       	ori	r20, 0x01	; 1
     7b4:	ee 0c       	add	r14, r14
     7b6:	ff 1c       	adc	r15, r15
     7b8:	00 1f       	adc	r16, r16
     7ba:	11 1f       	adc	r17, r17
     7bc:	21 50       	subi	r18, 0x01	; 1
     7be:	30 40       	sbci	r19, 0x00	; 0
     7c0:	40 30       	cpi	r20, 0x00	; 0
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	59 07       	cpc	r21, r25
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	69 07       	cpc	r22, r25
     7ca:	90 e4       	ldi	r25, 0x40	; 64
     7cc:	79 07       	cpc	r23, r25
     7ce:	60 f3       	brcs	.-40     	; 0x7a8 <__mulsf3+0x174>
     7d0:	2b 8f       	std	Y+27, r18	; 0x1b
     7d2:	3c 8f       	std	Y+28, r19	; 0x1c
     7d4:	db 01       	movw	r26, r22
     7d6:	ca 01       	movw	r24, r20
     7d8:	8f 77       	andi	r24, 0x7F	; 127
     7da:	90 70       	andi	r25, 0x00	; 0
     7dc:	a0 70       	andi	r26, 0x00	; 0
     7de:	b0 70       	andi	r27, 0x00	; 0
     7e0:	80 34       	cpi	r24, 0x40	; 64
     7e2:	91 05       	cpc	r25, r1
     7e4:	a1 05       	cpc	r26, r1
     7e6:	b1 05       	cpc	r27, r1
     7e8:	61 f4       	brne	.+24     	; 0x802 <__mulsf3+0x1ce>
     7ea:	47 fd       	sbrc	r20, 7
     7ec:	0a c0       	rjmp	.+20     	; 0x802 <__mulsf3+0x1ce>
     7ee:	e1 14       	cp	r14, r1
     7f0:	f1 04       	cpc	r15, r1
     7f2:	01 05       	cpc	r16, r1
     7f4:	11 05       	cpc	r17, r1
     7f6:	29 f0       	breq	.+10     	; 0x802 <__mulsf3+0x1ce>
     7f8:	40 5c       	subi	r20, 0xC0	; 192
     7fa:	5f 4f       	sbci	r21, 0xFF	; 255
     7fc:	6f 4f       	sbci	r22, 0xFF	; 255
     7fe:	7f 4f       	sbci	r23, 0xFF	; 255
     800:	40 78       	andi	r20, 0x80	; 128
     802:	1a 8e       	std	Y+26, r1	; 0x1a
     804:	fe 17       	cp	r31, r30
     806:	11 f0       	breq	.+4      	; 0x80c <__mulsf3+0x1d8>
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	8a 8f       	std	Y+26, r24	; 0x1a
     80c:	4d 8f       	std	Y+29, r20	; 0x1d
     80e:	5e 8f       	std	Y+30, r21	; 0x1e
     810:	6f 8f       	std	Y+31, r22	; 0x1f
     812:	78 a3       	std	Y+32, r23	; 0x20
     814:	83 e0       	ldi	r24, 0x03	; 3
     816:	89 8f       	std	Y+25, r24	; 0x19
     818:	ce 01       	movw	r24, r28
     81a:	49 96       	adiw	r24, 0x19	; 25
     81c:	0e 94 a4 05 	call	0xb48	; 0xb48 <__pack_f>
     820:	a0 96       	adiw	r28, 0x20	; 32
     822:	e2 e1       	ldi	r30, 0x12	; 18
     824:	0c 94 bb 42 	jmp	0x8576	; 0x8576 <__epilogue_restores__>

00000828 <__divsf3>:
     828:	a8 e1       	ldi	r26, 0x18	; 24
     82a:	b0 e0       	ldi	r27, 0x00	; 0
     82c:	ea e1       	ldi	r30, 0x1A	; 26
     82e:	f4 e0       	ldi	r31, 0x04	; 4
     830:	0c 94 a7 42 	jmp	0x854e	; 0x854e <__prologue_saves__+0x10>
     834:	69 83       	std	Y+1, r22	; 0x01
     836:	7a 83       	std	Y+2, r23	; 0x02
     838:	8b 83       	std	Y+3, r24	; 0x03
     83a:	9c 83       	std	Y+4, r25	; 0x04
     83c:	2d 83       	std	Y+5, r18	; 0x05
     83e:	3e 83       	std	Y+6, r19	; 0x06
     840:	4f 83       	std	Y+7, r20	; 0x07
     842:	58 87       	std	Y+8, r21	; 0x08
     844:	b9 e0       	ldi	r27, 0x09	; 9
     846:	eb 2e       	mov	r14, r27
     848:	f1 2c       	mov	r15, r1
     84a:	ec 0e       	add	r14, r28
     84c:	fd 1e       	adc	r15, r29
     84e:	ce 01       	movw	r24, r28
     850:	01 96       	adiw	r24, 0x01	; 1
     852:	b7 01       	movw	r22, r14
     854:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     858:	8e 01       	movw	r16, r28
     85a:	0f 5e       	subi	r16, 0xEF	; 239
     85c:	1f 4f       	sbci	r17, 0xFF	; 255
     85e:	ce 01       	movw	r24, r28
     860:	05 96       	adiw	r24, 0x05	; 5
     862:	b8 01       	movw	r22, r16
     864:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     868:	29 85       	ldd	r18, Y+9	; 0x09
     86a:	22 30       	cpi	r18, 0x02	; 2
     86c:	08 f4       	brcc	.+2      	; 0x870 <__stack+0x11>
     86e:	7e c0       	rjmp	.+252    	; 0x96c <__stack+0x10d>
     870:	39 89       	ldd	r19, Y+17	; 0x11
     872:	32 30       	cpi	r19, 0x02	; 2
     874:	10 f4       	brcc	.+4      	; 0x87a <__stack+0x1b>
     876:	b8 01       	movw	r22, r16
     878:	7c c0       	rjmp	.+248    	; 0x972 <__stack+0x113>
     87a:	8a 85       	ldd	r24, Y+10	; 0x0a
     87c:	9a 89       	ldd	r25, Y+18	; 0x12
     87e:	89 27       	eor	r24, r25
     880:	8a 87       	std	Y+10, r24	; 0x0a
     882:	24 30       	cpi	r18, 0x04	; 4
     884:	11 f0       	breq	.+4      	; 0x88a <__stack+0x2b>
     886:	22 30       	cpi	r18, 0x02	; 2
     888:	31 f4       	brne	.+12     	; 0x896 <__stack+0x37>
     88a:	23 17       	cp	r18, r19
     88c:	09 f0       	breq	.+2      	; 0x890 <__stack+0x31>
     88e:	6e c0       	rjmp	.+220    	; 0x96c <__stack+0x10d>
     890:	62 ee       	ldi	r22, 0xE2	; 226
     892:	70 e0       	ldi	r23, 0x00	; 0
     894:	6e c0       	rjmp	.+220    	; 0x972 <__stack+0x113>
     896:	34 30       	cpi	r19, 0x04	; 4
     898:	39 f4       	brne	.+14     	; 0x8a8 <__stack+0x49>
     89a:	1d 86       	std	Y+13, r1	; 0x0d
     89c:	1e 86       	std	Y+14, r1	; 0x0e
     89e:	1f 86       	std	Y+15, r1	; 0x0f
     8a0:	18 8a       	std	Y+16, r1	; 0x10
     8a2:	1c 86       	std	Y+12, r1	; 0x0c
     8a4:	1b 86       	std	Y+11, r1	; 0x0b
     8a6:	04 c0       	rjmp	.+8      	; 0x8b0 <__stack+0x51>
     8a8:	32 30       	cpi	r19, 0x02	; 2
     8aa:	21 f4       	brne	.+8      	; 0x8b4 <__stack+0x55>
     8ac:	84 e0       	ldi	r24, 0x04	; 4
     8ae:	89 87       	std	Y+9, r24	; 0x09
     8b0:	b7 01       	movw	r22, r14
     8b2:	5f c0       	rjmp	.+190    	; 0x972 <__stack+0x113>
     8b4:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b6:	3c 85       	ldd	r19, Y+12	; 0x0c
     8b8:	8b 89       	ldd	r24, Y+19	; 0x13
     8ba:	9c 89       	ldd	r25, Y+20	; 0x14
     8bc:	28 1b       	sub	r18, r24
     8be:	39 0b       	sbc	r19, r25
     8c0:	3c 87       	std	Y+12, r19	; 0x0c
     8c2:	2b 87       	std	Y+11, r18	; 0x0b
     8c4:	ed 84       	ldd	r14, Y+13	; 0x0d
     8c6:	fe 84       	ldd	r15, Y+14	; 0x0e
     8c8:	0f 85       	ldd	r16, Y+15	; 0x0f
     8ca:	18 89       	ldd	r17, Y+16	; 0x10
     8cc:	ad 88       	ldd	r10, Y+21	; 0x15
     8ce:	be 88       	ldd	r11, Y+22	; 0x16
     8d0:	cf 88       	ldd	r12, Y+23	; 0x17
     8d2:	d8 8c       	ldd	r13, Y+24	; 0x18
     8d4:	ea 14       	cp	r14, r10
     8d6:	fb 04       	cpc	r15, r11
     8d8:	0c 05       	cpc	r16, r12
     8da:	1d 05       	cpc	r17, r13
     8dc:	40 f4       	brcc	.+16     	; 0x8ee <__stack+0x8f>
     8de:	ee 0c       	add	r14, r14
     8e0:	ff 1c       	adc	r15, r15
     8e2:	00 1f       	adc	r16, r16
     8e4:	11 1f       	adc	r17, r17
     8e6:	21 50       	subi	r18, 0x01	; 1
     8e8:	30 40       	sbci	r19, 0x00	; 0
     8ea:	3c 87       	std	Y+12, r19	; 0x0c
     8ec:	2b 87       	std	Y+11, r18	; 0x0b
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	30 e0       	ldi	r19, 0x00	; 0
     8f2:	40 e0       	ldi	r20, 0x00	; 0
     8f4:	50 e0       	ldi	r21, 0x00	; 0
     8f6:	80 e0       	ldi	r24, 0x00	; 0
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	b0 e4       	ldi	r27, 0x40	; 64
     8fe:	60 e0       	ldi	r22, 0x00	; 0
     900:	70 e0       	ldi	r23, 0x00	; 0
     902:	ea 14       	cp	r14, r10
     904:	fb 04       	cpc	r15, r11
     906:	0c 05       	cpc	r16, r12
     908:	1d 05       	cpc	r17, r13
     90a:	40 f0       	brcs	.+16     	; 0x91c <__stack+0xbd>
     90c:	28 2b       	or	r18, r24
     90e:	39 2b       	or	r19, r25
     910:	4a 2b       	or	r20, r26
     912:	5b 2b       	or	r21, r27
     914:	ea 18       	sub	r14, r10
     916:	fb 08       	sbc	r15, r11
     918:	0c 09       	sbc	r16, r12
     91a:	1d 09       	sbc	r17, r13
     91c:	b6 95       	lsr	r27
     91e:	a7 95       	ror	r26
     920:	97 95       	ror	r25
     922:	87 95       	ror	r24
     924:	ee 0c       	add	r14, r14
     926:	ff 1c       	adc	r15, r15
     928:	00 1f       	adc	r16, r16
     92a:	11 1f       	adc	r17, r17
     92c:	6f 5f       	subi	r22, 0xFF	; 255
     92e:	7f 4f       	sbci	r23, 0xFF	; 255
     930:	6f 31       	cpi	r22, 0x1F	; 31
     932:	71 05       	cpc	r23, r1
     934:	31 f7       	brne	.-52     	; 0x902 <__stack+0xa3>
     936:	da 01       	movw	r26, r20
     938:	c9 01       	movw	r24, r18
     93a:	8f 77       	andi	r24, 0x7F	; 127
     93c:	90 70       	andi	r25, 0x00	; 0
     93e:	a0 70       	andi	r26, 0x00	; 0
     940:	b0 70       	andi	r27, 0x00	; 0
     942:	80 34       	cpi	r24, 0x40	; 64
     944:	91 05       	cpc	r25, r1
     946:	a1 05       	cpc	r26, r1
     948:	b1 05       	cpc	r27, r1
     94a:	61 f4       	brne	.+24     	; 0x964 <__stack+0x105>
     94c:	27 fd       	sbrc	r18, 7
     94e:	0a c0       	rjmp	.+20     	; 0x964 <__stack+0x105>
     950:	e1 14       	cp	r14, r1
     952:	f1 04       	cpc	r15, r1
     954:	01 05       	cpc	r16, r1
     956:	11 05       	cpc	r17, r1
     958:	29 f0       	breq	.+10     	; 0x964 <__stack+0x105>
     95a:	20 5c       	subi	r18, 0xC0	; 192
     95c:	3f 4f       	sbci	r19, 0xFF	; 255
     95e:	4f 4f       	sbci	r20, 0xFF	; 255
     960:	5f 4f       	sbci	r21, 0xFF	; 255
     962:	20 78       	andi	r18, 0x80	; 128
     964:	2d 87       	std	Y+13, r18	; 0x0d
     966:	3e 87       	std	Y+14, r19	; 0x0e
     968:	4f 87       	std	Y+15, r20	; 0x0f
     96a:	58 8b       	std	Y+16, r21	; 0x10
     96c:	be 01       	movw	r22, r28
     96e:	67 5f       	subi	r22, 0xF7	; 247
     970:	7f 4f       	sbci	r23, 0xFF	; 255
     972:	cb 01       	movw	r24, r22
     974:	0e 94 a4 05 	call	0xb48	; 0xb48 <__pack_f>
     978:	68 96       	adiw	r28, 0x18	; 24
     97a:	ea e0       	ldi	r30, 0x0A	; 10
     97c:	0c 94 c3 42 	jmp	0x8586	; 0x8586 <__epilogue_restores__+0x10>

00000980 <__gtsf2>:
     980:	a8 e1       	ldi	r26, 0x18	; 24
     982:	b0 e0       	ldi	r27, 0x00	; 0
     984:	e6 ec       	ldi	r30, 0xC6	; 198
     986:	f4 e0       	ldi	r31, 0x04	; 4
     988:	0c 94 ab 42 	jmp	0x8556	; 0x8556 <__prologue_saves__+0x18>
     98c:	69 83       	std	Y+1, r22	; 0x01
     98e:	7a 83       	std	Y+2, r23	; 0x02
     990:	8b 83       	std	Y+3, r24	; 0x03
     992:	9c 83       	std	Y+4, r25	; 0x04
     994:	2d 83       	std	Y+5, r18	; 0x05
     996:	3e 83       	std	Y+6, r19	; 0x06
     998:	4f 83       	std	Y+7, r20	; 0x07
     99a:	58 87       	std	Y+8, r21	; 0x08
     99c:	89 e0       	ldi	r24, 0x09	; 9
     99e:	e8 2e       	mov	r14, r24
     9a0:	f1 2c       	mov	r15, r1
     9a2:	ec 0e       	add	r14, r28
     9a4:	fd 1e       	adc	r15, r29
     9a6:	ce 01       	movw	r24, r28
     9a8:	01 96       	adiw	r24, 0x01	; 1
     9aa:	b7 01       	movw	r22, r14
     9ac:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     9b0:	8e 01       	movw	r16, r28
     9b2:	0f 5e       	subi	r16, 0xEF	; 239
     9b4:	1f 4f       	sbci	r17, 0xFF	; 255
     9b6:	ce 01       	movw	r24, r28
     9b8:	05 96       	adiw	r24, 0x05	; 5
     9ba:	b8 01       	movw	r22, r16
     9bc:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     9c0:	89 85       	ldd	r24, Y+9	; 0x09
     9c2:	82 30       	cpi	r24, 0x02	; 2
     9c4:	40 f0       	brcs	.+16     	; 0x9d6 <__gtsf2+0x56>
     9c6:	89 89       	ldd	r24, Y+17	; 0x11
     9c8:	82 30       	cpi	r24, 0x02	; 2
     9ca:	28 f0       	brcs	.+10     	; 0x9d6 <__gtsf2+0x56>
     9cc:	c7 01       	movw	r24, r14
     9ce:	b8 01       	movw	r22, r16
     9d0:	0e 94 f1 06 	call	0xde2	; 0xde2 <__fpcmp_parts_f>
     9d4:	01 c0       	rjmp	.+2      	; 0x9d8 <__gtsf2+0x58>
     9d6:	8f ef       	ldi	r24, 0xFF	; 255
     9d8:	68 96       	adiw	r28, 0x18	; 24
     9da:	e6 e0       	ldi	r30, 0x06	; 6
     9dc:	0c 94 c7 42 	jmp	0x858e	; 0x858e <__epilogue_restores__+0x18>

000009e0 <__gesf2>:
     9e0:	a8 e1       	ldi	r26, 0x18	; 24
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	e6 ef       	ldi	r30, 0xF6	; 246
     9e6:	f4 e0       	ldi	r31, 0x04	; 4
     9e8:	0c 94 ab 42 	jmp	0x8556	; 0x8556 <__prologue_saves__+0x18>
     9ec:	69 83       	std	Y+1, r22	; 0x01
     9ee:	7a 83       	std	Y+2, r23	; 0x02
     9f0:	8b 83       	std	Y+3, r24	; 0x03
     9f2:	9c 83       	std	Y+4, r25	; 0x04
     9f4:	2d 83       	std	Y+5, r18	; 0x05
     9f6:	3e 83       	std	Y+6, r19	; 0x06
     9f8:	4f 83       	std	Y+7, r20	; 0x07
     9fa:	58 87       	std	Y+8, r21	; 0x08
     9fc:	89 e0       	ldi	r24, 0x09	; 9
     9fe:	e8 2e       	mov	r14, r24
     a00:	f1 2c       	mov	r15, r1
     a02:	ec 0e       	add	r14, r28
     a04:	fd 1e       	adc	r15, r29
     a06:	ce 01       	movw	r24, r28
     a08:	01 96       	adiw	r24, 0x01	; 1
     a0a:	b7 01       	movw	r22, r14
     a0c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     a10:	8e 01       	movw	r16, r28
     a12:	0f 5e       	subi	r16, 0xEF	; 239
     a14:	1f 4f       	sbci	r17, 0xFF	; 255
     a16:	ce 01       	movw	r24, r28
     a18:	05 96       	adiw	r24, 0x05	; 5
     a1a:	b8 01       	movw	r22, r16
     a1c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     a20:	89 85       	ldd	r24, Y+9	; 0x09
     a22:	82 30       	cpi	r24, 0x02	; 2
     a24:	40 f0       	brcs	.+16     	; 0xa36 <__gesf2+0x56>
     a26:	89 89       	ldd	r24, Y+17	; 0x11
     a28:	82 30       	cpi	r24, 0x02	; 2
     a2a:	28 f0       	brcs	.+10     	; 0xa36 <__gesf2+0x56>
     a2c:	c7 01       	movw	r24, r14
     a2e:	b8 01       	movw	r22, r16
     a30:	0e 94 f1 06 	call	0xde2	; 0xde2 <__fpcmp_parts_f>
     a34:	01 c0       	rjmp	.+2      	; 0xa38 <__gesf2+0x58>
     a36:	8f ef       	ldi	r24, 0xFF	; 255
     a38:	68 96       	adiw	r28, 0x18	; 24
     a3a:	e6 e0       	ldi	r30, 0x06	; 6
     a3c:	0c 94 c7 42 	jmp	0x858e	; 0x858e <__epilogue_restores__+0x18>

00000a40 <__ltsf2>:
     a40:	a8 e1       	ldi	r26, 0x18	; 24
     a42:	b0 e0       	ldi	r27, 0x00	; 0
     a44:	e6 e2       	ldi	r30, 0x26	; 38
     a46:	f5 e0       	ldi	r31, 0x05	; 5
     a48:	0c 94 ab 42 	jmp	0x8556	; 0x8556 <__prologue_saves__+0x18>
     a4c:	69 83       	std	Y+1, r22	; 0x01
     a4e:	7a 83       	std	Y+2, r23	; 0x02
     a50:	8b 83       	std	Y+3, r24	; 0x03
     a52:	9c 83       	std	Y+4, r25	; 0x04
     a54:	2d 83       	std	Y+5, r18	; 0x05
     a56:	3e 83       	std	Y+6, r19	; 0x06
     a58:	4f 83       	std	Y+7, r20	; 0x07
     a5a:	58 87       	std	Y+8, r21	; 0x08
     a5c:	89 e0       	ldi	r24, 0x09	; 9
     a5e:	e8 2e       	mov	r14, r24
     a60:	f1 2c       	mov	r15, r1
     a62:	ec 0e       	add	r14, r28
     a64:	fd 1e       	adc	r15, r29
     a66:	ce 01       	movw	r24, r28
     a68:	01 96       	adiw	r24, 0x01	; 1
     a6a:	b7 01       	movw	r22, r14
     a6c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     a70:	8e 01       	movw	r16, r28
     a72:	0f 5e       	subi	r16, 0xEF	; 239
     a74:	1f 4f       	sbci	r17, 0xFF	; 255
     a76:	ce 01       	movw	r24, r28
     a78:	05 96       	adiw	r24, 0x05	; 5
     a7a:	b8 01       	movw	r22, r16
     a7c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     a80:	89 85       	ldd	r24, Y+9	; 0x09
     a82:	82 30       	cpi	r24, 0x02	; 2
     a84:	40 f0       	brcs	.+16     	; 0xa96 <__ltsf2+0x56>
     a86:	89 89       	ldd	r24, Y+17	; 0x11
     a88:	82 30       	cpi	r24, 0x02	; 2
     a8a:	28 f0       	brcs	.+10     	; 0xa96 <__ltsf2+0x56>
     a8c:	c7 01       	movw	r24, r14
     a8e:	b8 01       	movw	r22, r16
     a90:	0e 94 f1 06 	call	0xde2	; 0xde2 <__fpcmp_parts_f>
     a94:	01 c0       	rjmp	.+2      	; 0xa98 <__ltsf2+0x58>
     a96:	81 e0       	ldi	r24, 0x01	; 1
     a98:	68 96       	adiw	r28, 0x18	; 24
     a9a:	e6 e0       	ldi	r30, 0x06	; 6
     a9c:	0c 94 c7 42 	jmp	0x858e	; 0x858e <__epilogue_restores__+0x18>

00000aa0 <__fixsfsi>:
     aa0:	ac e0       	ldi	r26, 0x0C	; 12
     aa2:	b0 e0       	ldi	r27, 0x00	; 0
     aa4:	e6 e5       	ldi	r30, 0x56	; 86
     aa6:	f5 e0       	ldi	r31, 0x05	; 5
     aa8:	0c 94 af 42 	jmp	0x855e	; 0x855e <__prologue_saves__+0x20>
     aac:	69 83       	std	Y+1, r22	; 0x01
     aae:	7a 83       	std	Y+2, r23	; 0x02
     ab0:	8b 83       	std	Y+3, r24	; 0x03
     ab2:	9c 83       	std	Y+4, r25	; 0x04
     ab4:	ce 01       	movw	r24, r28
     ab6:	01 96       	adiw	r24, 0x01	; 1
     ab8:	be 01       	movw	r22, r28
     aba:	6b 5f       	subi	r22, 0xFB	; 251
     abc:	7f 4f       	sbci	r23, 0xFF	; 255
     abe:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__unpack_f>
     ac2:	8d 81       	ldd	r24, Y+5	; 0x05
     ac4:	82 30       	cpi	r24, 0x02	; 2
     ac6:	61 f1       	breq	.+88     	; 0xb20 <__fixsfsi+0x80>
     ac8:	82 30       	cpi	r24, 0x02	; 2
     aca:	50 f1       	brcs	.+84     	; 0xb20 <__fixsfsi+0x80>
     acc:	84 30       	cpi	r24, 0x04	; 4
     ace:	21 f4       	brne	.+8      	; 0xad8 <__fixsfsi+0x38>
     ad0:	8e 81       	ldd	r24, Y+6	; 0x06
     ad2:	88 23       	and	r24, r24
     ad4:	51 f1       	breq	.+84     	; 0xb2a <__fixsfsi+0x8a>
     ad6:	2e c0       	rjmp	.+92     	; 0xb34 <__fixsfsi+0x94>
     ad8:	2f 81       	ldd	r18, Y+7	; 0x07
     ada:	38 85       	ldd	r19, Y+8	; 0x08
     adc:	37 fd       	sbrc	r19, 7
     ade:	20 c0       	rjmp	.+64     	; 0xb20 <__fixsfsi+0x80>
     ae0:	6e 81       	ldd	r22, Y+6	; 0x06
     ae2:	2f 31       	cpi	r18, 0x1F	; 31
     ae4:	31 05       	cpc	r19, r1
     ae6:	1c f0       	brlt	.+6      	; 0xaee <__fixsfsi+0x4e>
     ae8:	66 23       	and	r22, r22
     aea:	f9 f0       	breq	.+62     	; 0xb2a <__fixsfsi+0x8a>
     aec:	23 c0       	rjmp	.+70     	; 0xb34 <__fixsfsi+0x94>
     aee:	8e e1       	ldi	r24, 0x1E	; 30
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	82 1b       	sub	r24, r18
     af4:	93 0b       	sbc	r25, r19
     af6:	29 85       	ldd	r18, Y+9	; 0x09
     af8:	3a 85       	ldd	r19, Y+10	; 0x0a
     afa:	4b 85       	ldd	r20, Y+11	; 0x0b
     afc:	5c 85       	ldd	r21, Y+12	; 0x0c
     afe:	04 c0       	rjmp	.+8      	; 0xb08 <__fixsfsi+0x68>
     b00:	56 95       	lsr	r21
     b02:	47 95       	ror	r20
     b04:	37 95       	ror	r19
     b06:	27 95       	ror	r18
     b08:	8a 95       	dec	r24
     b0a:	d2 f7       	brpl	.-12     	; 0xb00 <__fixsfsi+0x60>
     b0c:	66 23       	and	r22, r22
     b0e:	b1 f0       	breq	.+44     	; 0xb3c <__fixsfsi+0x9c>
     b10:	50 95       	com	r21
     b12:	40 95       	com	r20
     b14:	30 95       	com	r19
     b16:	21 95       	neg	r18
     b18:	3f 4f       	sbci	r19, 0xFF	; 255
     b1a:	4f 4f       	sbci	r20, 0xFF	; 255
     b1c:	5f 4f       	sbci	r21, 0xFF	; 255
     b1e:	0e c0       	rjmp	.+28     	; 0xb3c <__fixsfsi+0x9c>
     b20:	20 e0       	ldi	r18, 0x00	; 0
     b22:	30 e0       	ldi	r19, 0x00	; 0
     b24:	40 e0       	ldi	r20, 0x00	; 0
     b26:	50 e0       	ldi	r21, 0x00	; 0
     b28:	09 c0       	rjmp	.+18     	; 0xb3c <__fixsfsi+0x9c>
     b2a:	2f ef       	ldi	r18, 0xFF	; 255
     b2c:	3f ef       	ldi	r19, 0xFF	; 255
     b2e:	4f ef       	ldi	r20, 0xFF	; 255
     b30:	5f e7       	ldi	r21, 0x7F	; 127
     b32:	04 c0       	rjmp	.+8      	; 0xb3c <__fixsfsi+0x9c>
     b34:	20 e0       	ldi	r18, 0x00	; 0
     b36:	30 e0       	ldi	r19, 0x00	; 0
     b38:	40 e0       	ldi	r20, 0x00	; 0
     b3a:	50 e8       	ldi	r21, 0x80	; 128
     b3c:	b9 01       	movw	r22, r18
     b3e:	ca 01       	movw	r24, r20
     b40:	2c 96       	adiw	r28, 0x0c	; 12
     b42:	e2 e0       	ldi	r30, 0x02	; 2
     b44:	0c 94 cb 42 	jmp	0x8596	; 0x8596 <__epilogue_restores__+0x20>

00000b48 <__pack_f>:
     b48:	df 92       	push	r13
     b4a:	ef 92       	push	r14
     b4c:	ff 92       	push	r15
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	fc 01       	movw	r30, r24
     b54:	e4 80       	ldd	r14, Z+4	; 0x04
     b56:	f5 80       	ldd	r15, Z+5	; 0x05
     b58:	06 81       	ldd	r16, Z+6	; 0x06
     b5a:	17 81       	ldd	r17, Z+7	; 0x07
     b5c:	d1 80       	ldd	r13, Z+1	; 0x01
     b5e:	80 81       	ld	r24, Z
     b60:	82 30       	cpi	r24, 0x02	; 2
     b62:	48 f4       	brcc	.+18     	; 0xb76 <__pack_f+0x2e>
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	a0 e1       	ldi	r26, 0x10	; 16
     b6a:	b0 e0       	ldi	r27, 0x00	; 0
     b6c:	e8 2a       	or	r14, r24
     b6e:	f9 2a       	or	r15, r25
     b70:	0a 2b       	or	r16, r26
     b72:	1b 2b       	or	r17, r27
     b74:	a5 c0       	rjmp	.+330    	; 0xcc0 <__pack_f+0x178>
     b76:	84 30       	cpi	r24, 0x04	; 4
     b78:	09 f4       	brne	.+2      	; 0xb7c <__pack_f+0x34>
     b7a:	9f c0       	rjmp	.+318    	; 0xcba <__pack_f+0x172>
     b7c:	82 30       	cpi	r24, 0x02	; 2
     b7e:	21 f4       	brne	.+8      	; 0xb88 <__pack_f+0x40>
     b80:	ee 24       	eor	r14, r14
     b82:	ff 24       	eor	r15, r15
     b84:	87 01       	movw	r16, r14
     b86:	05 c0       	rjmp	.+10     	; 0xb92 <__pack_f+0x4a>
     b88:	e1 14       	cp	r14, r1
     b8a:	f1 04       	cpc	r15, r1
     b8c:	01 05       	cpc	r16, r1
     b8e:	11 05       	cpc	r17, r1
     b90:	19 f4       	brne	.+6      	; 0xb98 <__pack_f+0x50>
     b92:	e0 e0       	ldi	r30, 0x00	; 0
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	96 c0       	rjmp	.+300    	; 0xcc4 <__pack_f+0x17c>
     b98:	62 81       	ldd	r22, Z+2	; 0x02
     b9a:	73 81       	ldd	r23, Z+3	; 0x03
     b9c:	9f ef       	ldi	r25, 0xFF	; 255
     b9e:	62 38       	cpi	r22, 0x82	; 130
     ba0:	79 07       	cpc	r23, r25
     ba2:	0c f0       	brlt	.+2      	; 0xba6 <__pack_f+0x5e>
     ba4:	5b c0       	rjmp	.+182    	; 0xc5c <__pack_f+0x114>
     ba6:	22 e8       	ldi	r18, 0x82	; 130
     ba8:	3f ef       	ldi	r19, 0xFF	; 255
     baa:	26 1b       	sub	r18, r22
     bac:	37 0b       	sbc	r19, r23
     bae:	2a 31       	cpi	r18, 0x1A	; 26
     bb0:	31 05       	cpc	r19, r1
     bb2:	2c f0       	brlt	.+10     	; 0xbbe <__pack_f+0x76>
     bb4:	20 e0       	ldi	r18, 0x00	; 0
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	40 e0       	ldi	r20, 0x00	; 0
     bba:	50 e0       	ldi	r21, 0x00	; 0
     bbc:	2a c0       	rjmp	.+84     	; 0xc12 <__pack_f+0xca>
     bbe:	b8 01       	movw	r22, r16
     bc0:	a7 01       	movw	r20, r14
     bc2:	02 2e       	mov	r0, r18
     bc4:	04 c0       	rjmp	.+8      	; 0xbce <__pack_f+0x86>
     bc6:	76 95       	lsr	r23
     bc8:	67 95       	ror	r22
     bca:	57 95       	ror	r21
     bcc:	47 95       	ror	r20
     bce:	0a 94       	dec	r0
     bd0:	d2 f7       	brpl	.-12     	; 0xbc6 <__pack_f+0x7e>
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	a0 e0       	ldi	r26, 0x00	; 0
     bd8:	b0 e0       	ldi	r27, 0x00	; 0
     bda:	04 c0       	rjmp	.+8      	; 0xbe4 <__pack_f+0x9c>
     bdc:	88 0f       	add	r24, r24
     bde:	99 1f       	adc	r25, r25
     be0:	aa 1f       	adc	r26, r26
     be2:	bb 1f       	adc	r27, r27
     be4:	2a 95       	dec	r18
     be6:	d2 f7       	brpl	.-12     	; 0xbdc <__pack_f+0x94>
     be8:	01 97       	sbiw	r24, 0x01	; 1
     bea:	a1 09       	sbc	r26, r1
     bec:	b1 09       	sbc	r27, r1
     bee:	8e 21       	and	r24, r14
     bf0:	9f 21       	and	r25, r15
     bf2:	a0 23       	and	r26, r16
     bf4:	b1 23       	and	r27, r17
     bf6:	00 97       	sbiw	r24, 0x00	; 0
     bf8:	a1 05       	cpc	r26, r1
     bfa:	b1 05       	cpc	r27, r1
     bfc:	21 f0       	breq	.+8      	; 0xc06 <__pack_f+0xbe>
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	a0 e0       	ldi	r26, 0x00	; 0
     c04:	b0 e0       	ldi	r27, 0x00	; 0
     c06:	9a 01       	movw	r18, r20
     c08:	ab 01       	movw	r20, r22
     c0a:	28 2b       	or	r18, r24
     c0c:	39 2b       	or	r19, r25
     c0e:	4a 2b       	or	r20, r26
     c10:	5b 2b       	or	r21, r27
     c12:	da 01       	movw	r26, r20
     c14:	c9 01       	movw	r24, r18
     c16:	8f 77       	andi	r24, 0x7F	; 127
     c18:	90 70       	andi	r25, 0x00	; 0
     c1a:	a0 70       	andi	r26, 0x00	; 0
     c1c:	b0 70       	andi	r27, 0x00	; 0
     c1e:	80 34       	cpi	r24, 0x40	; 64
     c20:	91 05       	cpc	r25, r1
     c22:	a1 05       	cpc	r26, r1
     c24:	b1 05       	cpc	r27, r1
     c26:	39 f4       	brne	.+14     	; 0xc36 <__pack_f+0xee>
     c28:	27 ff       	sbrs	r18, 7
     c2a:	09 c0       	rjmp	.+18     	; 0xc3e <__pack_f+0xf6>
     c2c:	20 5c       	subi	r18, 0xC0	; 192
     c2e:	3f 4f       	sbci	r19, 0xFF	; 255
     c30:	4f 4f       	sbci	r20, 0xFF	; 255
     c32:	5f 4f       	sbci	r21, 0xFF	; 255
     c34:	04 c0       	rjmp	.+8      	; 0xc3e <__pack_f+0xf6>
     c36:	21 5c       	subi	r18, 0xC1	; 193
     c38:	3f 4f       	sbci	r19, 0xFF	; 255
     c3a:	4f 4f       	sbci	r20, 0xFF	; 255
     c3c:	5f 4f       	sbci	r21, 0xFF	; 255
     c3e:	e0 e0       	ldi	r30, 0x00	; 0
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	20 30       	cpi	r18, 0x00	; 0
     c44:	a0 e0       	ldi	r26, 0x00	; 0
     c46:	3a 07       	cpc	r19, r26
     c48:	a0 e0       	ldi	r26, 0x00	; 0
     c4a:	4a 07       	cpc	r20, r26
     c4c:	a0 e4       	ldi	r26, 0x40	; 64
     c4e:	5a 07       	cpc	r21, r26
     c50:	10 f0       	brcs	.+4      	; 0xc56 <__pack_f+0x10e>
     c52:	e1 e0       	ldi	r30, 0x01	; 1
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	79 01       	movw	r14, r18
     c58:	8a 01       	movw	r16, r20
     c5a:	27 c0       	rjmp	.+78     	; 0xcaa <__pack_f+0x162>
     c5c:	60 38       	cpi	r22, 0x80	; 128
     c5e:	71 05       	cpc	r23, r1
     c60:	64 f5       	brge	.+88     	; 0xcba <__pack_f+0x172>
     c62:	fb 01       	movw	r30, r22
     c64:	e1 58       	subi	r30, 0x81	; 129
     c66:	ff 4f       	sbci	r31, 0xFF	; 255
     c68:	d8 01       	movw	r26, r16
     c6a:	c7 01       	movw	r24, r14
     c6c:	8f 77       	andi	r24, 0x7F	; 127
     c6e:	90 70       	andi	r25, 0x00	; 0
     c70:	a0 70       	andi	r26, 0x00	; 0
     c72:	b0 70       	andi	r27, 0x00	; 0
     c74:	80 34       	cpi	r24, 0x40	; 64
     c76:	91 05       	cpc	r25, r1
     c78:	a1 05       	cpc	r26, r1
     c7a:	b1 05       	cpc	r27, r1
     c7c:	39 f4       	brne	.+14     	; 0xc8c <__pack_f+0x144>
     c7e:	e7 fe       	sbrs	r14, 7
     c80:	0d c0       	rjmp	.+26     	; 0xc9c <__pack_f+0x154>
     c82:	80 e4       	ldi	r24, 0x40	; 64
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	a0 e0       	ldi	r26, 0x00	; 0
     c88:	b0 e0       	ldi	r27, 0x00	; 0
     c8a:	04 c0       	rjmp	.+8      	; 0xc94 <__pack_f+0x14c>
     c8c:	8f e3       	ldi	r24, 0x3F	; 63
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	a0 e0       	ldi	r26, 0x00	; 0
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	e8 0e       	add	r14, r24
     c96:	f9 1e       	adc	r15, r25
     c98:	0a 1f       	adc	r16, r26
     c9a:	1b 1f       	adc	r17, r27
     c9c:	17 ff       	sbrs	r17, 7
     c9e:	05 c0       	rjmp	.+10     	; 0xcaa <__pack_f+0x162>
     ca0:	16 95       	lsr	r17
     ca2:	07 95       	ror	r16
     ca4:	f7 94       	ror	r15
     ca6:	e7 94       	ror	r14
     ca8:	31 96       	adiw	r30, 0x01	; 1
     caa:	87 e0       	ldi	r24, 0x07	; 7
     cac:	16 95       	lsr	r17
     cae:	07 95       	ror	r16
     cb0:	f7 94       	ror	r15
     cb2:	e7 94       	ror	r14
     cb4:	8a 95       	dec	r24
     cb6:	d1 f7       	brne	.-12     	; 0xcac <__pack_f+0x164>
     cb8:	05 c0       	rjmp	.+10     	; 0xcc4 <__pack_f+0x17c>
     cba:	ee 24       	eor	r14, r14
     cbc:	ff 24       	eor	r15, r15
     cbe:	87 01       	movw	r16, r14
     cc0:	ef ef       	ldi	r30, 0xFF	; 255
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	6e 2f       	mov	r22, r30
     cc6:	67 95       	ror	r22
     cc8:	66 27       	eor	r22, r22
     cca:	67 95       	ror	r22
     ccc:	90 2f       	mov	r25, r16
     cce:	9f 77       	andi	r25, 0x7F	; 127
     cd0:	d7 94       	ror	r13
     cd2:	dd 24       	eor	r13, r13
     cd4:	d7 94       	ror	r13
     cd6:	8e 2f       	mov	r24, r30
     cd8:	86 95       	lsr	r24
     cda:	49 2f       	mov	r20, r25
     cdc:	46 2b       	or	r20, r22
     cde:	58 2f       	mov	r21, r24
     ce0:	5d 29       	or	r21, r13
     ce2:	b7 01       	movw	r22, r14
     ce4:	ca 01       	movw	r24, r20
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	df 90       	pop	r13
     cf0:	08 95       	ret

00000cf2 <__unpack_f>:
     cf2:	fc 01       	movw	r30, r24
     cf4:	db 01       	movw	r26, r22
     cf6:	40 81       	ld	r20, Z
     cf8:	51 81       	ldd	r21, Z+1	; 0x01
     cfa:	22 81       	ldd	r18, Z+2	; 0x02
     cfc:	62 2f       	mov	r22, r18
     cfe:	6f 77       	andi	r22, 0x7F	; 127
     d00:	70 e0       	ldi	r23, 0x00	; 0
     d02:	22 1f       	adc	r18, r18
     d04:	22 27       	eor	r18, r18
     d06:	22 1f       	adc	r18, r18
     d08:	93 81       	ldd	r25, Z+3	; 0x03
     d0a:	89 2f       	mov	r24, r25
     d0c:	88 0f       	add	r24, r24
     d0e:	82 2b       	or	r24, r18
     d10:	28 2f       	mov	r18, r24
     d12:	30 e0       	ldi	r19, 0x00	; 0
     d14:	99 1f       	adc	r25, r25
     d16:	99 27       	eor	r25, r25
     d18:	99 1f       	adc	r25, r25
     d1a:	11 96       	adiw	r26, 0x01	; 1
     d1c:	9c 93       	st	X, r25
     d1e:	11 97       	sbiw	r26, 0x01	; 1
     d20:	21 15       	cp	r18, r1
     d22:	31 05       	cpc	r19, r1
     d24:	a9 f5       	brne	.+106    	; 0xd90 <__unpack_f+0x9e>
     d26:	41 15       	cp	r20, r1
     d28:	51 05       	cpc	r21, r1
     d2a:	61 05       	cpc	r22, r1
     d2c:	71 05       	cpc	r23, r1
     d2e:	11 f4       	brne	.+4      	; 0xd34 <__unpack_f+0x42>
     d30:	82 e0       	ldi	r24, 0x02	; 2
     d32:	37 c0       	rjmp	.+110    	; 0xda2 <__unpack_f+0xb0>
     d34:	82 e8       	ldi	r24, 0x82	; 130
     d36:	9f ef       	ldi	r25, 0xFF	; 255
     d38:	13 96       	adiw	r26, 0x03	; 3
     d3a:	9c 93       	st	X, r25
     d3c:	8e 93       	st	-X, r24
     d3e:	12 97       	sbiw	r26, 0x02	; 2
     d40:	9a 01       	movw	r18, r20
     d42:	ab 01       	movw	r20, r22
     d44:	67 e0       	ldi	r22, 0x07	; 7
     d46:	22 0f       	add	r18, r18
     d48:	33 1f       	adc	r19, r19
     d4a:	44 1f       	adc	r20, r20
     d4c:	55 1f       	adc	r21, r21
     d4e:	6a 95       	dec	r22
     d50:	d1 f7       	brne	.-12     	; 0xd46 <__unpack_f+0x54>
     d52:	83 e0       	ldi	r24, 0x03	; 3
     d54:	8c 93       	st	X, r24
     d56:	0d c0       	rjmp	.+26     	; 0xd72 <__unpack_f+0x80>
     d58:	22 0f       	add	r18, r18
     d5a:	33 1f       	adc	r19, r19
     d5c:	44 1f       	adc	r20, r20
     d5e:	55 1f       	adc	r21, r21
     d60:	12 96       	adiw	r26, 0x02	; 2
     d62:	8d 91       	ld	r24, X+
     d64:	9c 91       	ld	r25, X
     d66:	13 97       	sbiw	r26, 0x03	; 3
     d68:	01 97       	sbiw	r24, 0x01	; 1
     d6a:	13 96       	adiw	r26, 0x03	; 3
     d6c:	9c 93       	st	X, r25
     d6e:	8e 93       	st	-X, r24
     d70:	12 97       	sbiw	r26, 0x02	; 2
     d72:	20 30       	cpi	r18, 0x00	; 0
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	38 07       	cpc	r19, r24
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	48 07       	cpc	r20, r24
     d7c:	80 e4       	ldi	r24, 0x40	; 64
     d7e:	58 07       	cpc	r21, r24
     d80:	58 f3       	brcs	.-42     	; 0xd58 <__unpack_f+0x66>
     d82:	14 96       	adiw	r26, 0x04	; 4
     d84:	2d 93       	st	X+, r18
     d86:	3d 93       	st	X+, r19
     d88:	4d 93       	st	X+, r20
     d8a:	5c 93       	st	X, r21
     d8c:	17 97       	sbiw	r26, 0x07	; 7
     d8e:	08 95       	ret
     d90:	2f 3f       	cpi	r18, 0xFF	; 255
     d92:	31 05       	cpc	r19, r1
     d94:	79 f4       	brne	.+30     	; 0xdb4 <__unpack_f+0xc2>
     d96:	41 15       	cp	r20, r1
     d98:	51 05       	cpc	r21, r1
     d9a:	61 05       	cpc	r22, r1
     d9c:	71 05       	cpc	r23, r1
     d9e:	19 f4       	brne	.+6      	; 0xda6 <__unpack_f+0xb4>
     da0:	84 e0       	ldi	r24, 0x04	; 4
     da2:	8c 93       	st	X, r24
     da4:	08 95       	ret
     da6:	64 ff       	sbrs	r22, 4
     da8:	03 c0       	rjmp	.+6      	; 0xdb0 <__unpack_f+0xbe>
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	8c 93       	st	X, r24
     dae:	12 c0       	rjmp	.+36     	; 0xdd4 <__unpack_f+0xe2>
     db0:	1c 92       	st	X, r1
     db2:	10 c0       	rjmp	.+32     	; 0xdd4 <__unpack_f+0xe2>
     db4:	2f 57       	subi	r18, 0x7F	; 127
     db6:	30 40       	sbci	r19, 0x00	; 0
     db8:	13 96       	adiw	r26, 0x03	; 3
     dba:	3c 93       	st	X, r19
     dbc:	2e 93       	st	-X, r18
     dbe:	12 97       	sbiw	r26, 0x02	; 2
     dc0:	83 e0       	ldi	r24, 0x03	; 3
     dc2:	8c 93       	st	X, r24
     dc4:	87 e0       	ldi	r24, 0x07	; 7
     dc6:	44 0f       	add	r20, r20
     dc8:	55 1f       	adc	r21, r21
     dca:	66 1f       	adc	r22, r22
     dcc:	77 1f       	adc	r23, r23
     dce:	8a 95       	dec	r24
     dd0:	d1 f7       	brne	.-12     	; 0xdc6 <__unpack_f+0xd4>
     dd2:	70 64       	ori	r23, 0x40	; 64
     dd4:	14 96       	adiw	r26, 0x04	; 4
     dd6:	4d 93       	st	X+, r20
     dd8:	5d 93       	st	X+, r21
     dda:	6d 93       	st	X+, r22
     ddc:	7c 93       	st	X, r23
     dde:	17 97       	sbiw	r26, 0x07	; 7
     de0:	08 95       	ret

00000de2 <__fpcmp_parts_f>:
     de2:	1f 93       	push	r17
     de4:	dc 01       	movw	r26, r24
     de6:	fb 01       	movw	r30, r22
     de8:	9c 91       	ld	r25, X
     dea:	92 30       	cpi	r25, 0x02	; 2
     dec:	08 f4       	brcc	.+2      	; 0xdf0 <__fpcmp_parts_f+0xe>
     dee:	47 c0       	rjmp	.+142    	; 0xe7e <__fpcmp_parts_f+0x9c>
     df0:	80 81       	ld	r24, Z
     df2:	82 30       	cpi	r24, 0x02	; 2
     df4:	08 f4       	brcc	.+2      	; 0xdf8 <__fpcmp_parts_f+0x16>
     df6:	43 c0       	rjmp	.+134    	; 0xe7e <__fpcmp_parts_f+0x9c>
     df8:	94 30       	cpi	r25, 0x04	; 4
     dfa:	51 f4       	brne	.+20     	; 0xe10 <__fpcmp_parts_f+0x2e>
     dfc:	11 96       	adiw	r26, 0x01	; 1
     dfe:	1c 91       	ld	r17, X
     e00:	84 30       	cpi	r24, 0x04	; 4
     e02:	99 f5       	brne	.+102    	; 0xe6a <__fpcmp_parts_f+0x88>
     e04:	81 81       	ldd	r24, Z+1	; 0x01
     e06:	68 2f       	mov	r22, r24
     e08:	70 e0       	ldi	r23, 0x00	; 0
     e0a:	61 1b       	sub	r22, r17
     e0c:	71 09       	sbc	r23, r1
     e0e:	3f c0       	rjmp	.+126    	; 0xe8e <__fpcmp_parts_f+0xac>
     e10:	84 30       	cpi	r24, 0x04	; 4
     e12:	21 f0       	breq	.+8      	; 0xe1c <__fpcmp_parts_f+0x3a>
     e14:	92 30       	cpi	r25, 0x02	; 2
     e16:	31 f4       	brne	.+12     	; 0xe24 <__fpcmp_parts_f+0x42>
     e18:	82 30       	cpi	r24, 0x02	; 2
     e1a:	b9 f1       	breq	.+110    	; 0xe8a <__fpcmp_parts_f+0xa8>
     e1c:	81 81       	ldd	r24, Z+1	; 0x01
     e1e:	88 23       	and	r24, r24
     e20:	89 f1       	breq	.+98     	; 0xe84 <__fpcmp_parts_f+0xa2>
     e22:	2d c0       	rjmp	.+90     	; 0xe7e <__fpcmp_parts_f+0x9c>
     e24:	11 96       	adiw	r26, 0x01	; 1
     e26:	1c 91       	ld	r17, X
     e28:	11 97       	sbiw	r26, 0x01	; 1
     e2a:	82 30       	cpi	r24, 0x02	; 2
     e2c:	f1 f0       	breq	.+60     	; 0xe6a <__fpcmp_parts_f+0x88>
     e2e:	81 81       	ldd	r24, Z+1	; 0x01
     e30:	18 17       	cp	r17, r24
     e32:	d9 f4       	brne	.+54     	; 0xe6a <__fpcmp_parts_f+0x88>
     e34:	12 96       	adiw	r26, 0x02	; 2
     e36:	2d 91       	ld	r18, X+
     e38:	3c 91       	ld	r19, X
     e3a:	13 97       	sbiw	r26, 0x03	; 3
     e3c:	82 81       	ldd	r24, Z+2	; 0x02
     e3e:	93 81       	ldd	r25, Z+3	; 0x03
     e40:	82 17       	cp	r24, r18
     e42:	93 07       	cpc	r25, r19
     e44:	94 f0       	brlt	.+36     	; 0xe6a <__fpcmp_parts_f+0x88>
     e46:	28 17       	cp	r18, r24
     e48:	39 07       	cpc	r19, r25
     e4a:	bc f0       	brlt	.+46     	; 0xe7a <__fpcmp_parts_f+0x98>
     e4c:	14 96       	adiw	r26, 0x04	; 4
     e4e:	8d 91       	ld	r24, X+
     e50:	9d 91       	ld	r25, X+
     e52:	0d 90       	ld	r0, X+
     e54:	bc 91       	ld	r27, X
     e56:	a0 2d       	mov	r26, r0
     e58:	24 81       	ldd	r18, Z+4	; 0x04
     e5a:	35 81       	ldd	r19, Z+5	; 0x05
     e5c:	46 81       	ldd	r20, Z+6	; 0x06
     e5e:	57 81       	ldd	r21, Z+7	; 0x07
     e60:	28 17       	cp	r18, r24
     e62:	39 07       	cpc	r19, r25
     e64:	4a 07       	cpc	r20, r26
     e66:	5b 07       	cpc	r21, r27
     e68:	18 f4       	brcc	.+6      	; 0xe70 <__fpcmp_parts_f+0x8e>
     e6a:	11 23       	and	r17, r17
     e6c:	41 f0       	breq	.+16     	; 0xe7e <__fpcmp_parts_f+0x9c>
     e6e:	0a c0       	rjmp	.+20     	; 0xe84 <__fpcmp_parts_f+0xa2>
     e70:	82 17       	cp	r24, r18
     e72:	93 07       	cpc	r25, r19
     e74:	a4 07       	cpc	r26, r20
     e76:	b5 07       	cpc	r27, r21
     e78:	40 f4       	brcc	.+16     	; 0xe8a <__fpcmp_parts_f+0xa8>
     e7a:	11 23       	and	r17, r17
     e7c:	19 f0       	breq	.+6      	; 0xe84 <__fpcmp_parts_f+0xa2>
     e7e:	61 e0       	ldi	r22, 0x01	; 1
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	05 c0       	rjmp	.+10     	; 0xe8e <__fpcmp_parts_f+0xac>
     e84:	6f ef       	ldi	r22, 0xFF	; 255
     e86:	7f ef       	ldi	r23, 0xFF	; 255
     e88:	02 c0       	rjmp	.+4      	; 0xe8e <__fpcmp_parts_f+0xac>
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	cb 01       	movw	r24, r22
     e90:	1f 91       	pop	r17
     e92:	08 95       	ret

00000e94 <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
     e94:	df 93       	push	r29
     e96:	cf 93       	push	r28
     e98:	00 d0       	rcall	.+0      	; 0xe9a <MDIO_Error_State_SetPinDirection+0x6>
     e9a:	00 d0       	rcall	.+0      	; 0xe9c <MDIO_Error_State_SetPinDirection+0x8>
     e9c:	00 d0       	rcall	.+0      	; 0xe9e <MDIO_Error_State_SetPinDirection+0xa>
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	8a 83       	std	Y+2, r24	; 0x02
     ea4:	6b 83       	std	Y+3, r22	; 0x03
     ea6:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     eac:	8a 81       	ldd	r24, Y+2	; 0x02
     eae:	88 30       	cpi	r24, 0x08	; 8
     eb0:	08 f0       	brcs	.+2      	; 0xeb4 <MDIO_Error_State_SetPinDirection+0x20>
     eb2:	e8 c0       	rjmp	.+464    	; 0x1084 <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
     eb4:	8b 81       	ldd	r24, Y+3	; 0x03
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	3e 83       	std	Y+6, r19	; 0x06
     ebc:	2d 83       	std	Y+5, r18	; 0x05
     ebe:	8d 81       	ldd	r24, Y+5	; 0x05
     ec0:	9e 81       	ldd	r25, Y+6	; 0x06
     ec2:	81 30       	cpi	r24, 0x01	; 1
     ec4:	91 05       	cpc	r25, r1
     ec6:	09 f4       	brne	.+2      	; 0xeca <MDIO_Error_State_SetPinDirection+0x36>
     ec8:	48 c0       	rjmp	.+144    	; 0xf5a <MDIO_Error_State_SetPinDirection+0xc6>
     eca:	2d 81       	ldd	r18, Y+5	; 0x05
     ecc:	3e 81       	ldd	r19, Y+6	; 0x06
     ece:	22 30       	cpi	r18, 0x02	; 2
     ed0:	31 05       	cpc	r19, r1
     ed2:	2c f4       	brge	.+10     	; 0xede <MDIO_Error_State_SetPinDirection+0x4a>
     ed4:	8d 81       	ldd	r24, Y+5	; 0x05
     ed6:	9e 81       	ldd	r25, Y+6	; 0x06
     ed8:	00 97       	sbiw	r24, 0x00	; 0
     eda:	71 f0       	breq	.+28     	; 0xef8 <MDIO_Error_State_SetPinDirection+0x64>
     edc:	d1 c0       	rjmp	.+418    	; 0x1080 <MDIO_Error_State_SetPinDirection+0x1ec>
     ede:	2d 81       	ldd	r18, Y+5	; 0x05
     ee0:	3e 81       	ldd	r19, Y+6	; 0x06
     ee2:	22 30       	cpi	r18, 0x02	; 2
     ee4:	31 05       	cpc	r19, r1
     ee6:	09 f4       	brne	.+2      	; 0xeea <MDIO_Error_State_SetPinDirection+0x56>
     ee8:	69 c0       	rjmp	.+210    	; 0xfbc <MDIO_Error_State_SetPinDirection+0x128>
     eea:	8d 81       	ldd	r24, Y+5	; 0x05
     eec:	9e 81       	ldd	r25, Y+6	; 0x06
     eee:	83 30       	cpi	r24, 0x03	; 3
     ef0:	91 05       	cpc	r25, r1
     ef2:	09 f4       	brne	.+2      	; 0xef6 <MDIO_Error_State_SetPinDirection+0x62>
     ef4:	94 c0       	rjmp	.+296    	; 0x101e <MDIO_Error_State_SetPinDirection+0x18a>
     ef6:	c4 c0       	rjmp	.+392    	; 0x1080 <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     ef8:	8c 81       	ldd	r24, Y+4	; 0x04
     efa:	81 30       	cpi	r24, 0x01	; 1
     efc:	a1 f4       	brne	.+40     	; 0xf26 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
     efe:	aa e3       	ldi	r26, 0x3A	; 58
     f00:	b0 e0       	ldi	r27, 0x00	; 0
     f02:	ea e3       	ldi	r30, 0x3A	; 58
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	80 81       	ld	r24, Z
     f08:	48 2f       	mov	r20, r24
     f0a:	8a 81       	ldd	r24, Y+2	; 0x02
     f0c:	28 2f       	mov	r18, r24
     f0e:	30 e0       	ldi	r19, 0x00	; 0
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	02 2e       	mov	r0, r18
     f16:	02 c0       	rjmp	.+4      	; 0xf1c <MDIO_Error_State_SetPinDirection+0x88>
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	0a 94       	dec	r0
     f1e:	e2 f7       	brpl	.-8      	; 0xf18 <MDIO_Error_State_SetPinDirection+0x84>
     f20:	84 2b       	or	r24, r20
     f22:	8c 93       	st	X, r24
     f24:	b0 c0       	rjmp	.+352    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     f26:	8c 81       	ldd	r24, Y+4	; 0x04
     f28:	88 23       	and	r24, r24
     f2a:	a9 f4       	brne	.+42     	; 0xf56 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
     f2c:	aa e3       	ldi	r26, 0x3A	; 58
     f2e:	b0 e0       	ldi	r27, 0x00	; 0
     f30:	ea e3       	ldi	r30, 0x3A	; 58
     f32:	f0 e0       	ldi	r31, 0x00	; 0
     f34:	80 81       	ld	r24, Z
     f36:	48 2f       	mov	r20, r24
     f38:	8a 81       	ldd	r24, Y+2	; 0x02
     f3a:	28 2f       	mov	r18, r24
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	02 2e       	mov	r0, r18
     f44:	02 c0       	rjmp	.+4      	; 0xf4a <MDIO_Error_State_SetPinDirection+0xb6>
     f46:	88 0f       	add	r24, r24
     f48:	99 1f       	adc	r25, r25
     f4a:	0a 94       	dec	r0
     f4c:	e2 f7       	brpl	.-8      	; 0xf46 <MDIO_Error_State_SetPinDirection+0xb2>
     f4e:	80 95       	com	r24
     f50:	84 23       	and	r24, r20
     f52:	8c 93       	st	X, r24
     f54:	98 c0       	rjmp	.+304    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     f56:	19 82       	std	Y+1, r1	; 0x01
     f58:	96 c0       	rjmp	.+300    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     f5a:	8c 81       	ldd	r24, Y+4	; 0x04
     f5c:	81 30       	cpi	r24, 0x01	; 1
     f5e:	a1 f4       	brne	.+40     	; 0xf88 <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
     f60:	a7 e3       	ldi	r26, 0x37	; 55
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	e7 e3       	ldi	r30, 0x37	; 55
     f66:	f0 e0       	ldi	r31, 0x00	; 0
     f68:	80 81       	ld	r24, Z
     f6a:	48 2f       	mov	r20, r24
     f6c:	8a 81       	ldd	r24, Y+2	; 0x02
     f6e:	28 2f       	mov	r18, r24
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	02 2e       	mov	r0, r18
     f78:	02 c0       	rjmp	.+4      	; 0xf7e <MDIO_Error_State_SetPinDirection+0xea>
     f7a:	88 0f       	add	r24, r24
     f7c:	99 1f       	adc	r25, r25
     f7e:	0a 94       	dec	r0
     f80:	e2 f7       	brpl	.-8      	; 0xf7a <MDIO_Error_State_SetPinDirection+0xe6>
     f82:	84 2b       	or	r24, r20
     f84:	8c 93       	st	X, r24
     f86:	7f c0       	rjmp	.+254    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     f88:	8c 81       	ldd	r24, Y+4	; 0x04
     f8a:	88 23       	and	r24, r24
     f8c:	a9 f4       	brne	.+42     	; 0xfb8 <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
     f8e:	a7 e3       	ldi	r26, 0x37	; 55
     f90:	b0 e0       	ldi	r27, 0x00	; 0
     f92:	e7 e3       	ldi	r30, 0x37	; 55
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	80 81       	ld	r24, Z
     f98:	48 2f       	mov	r20, r24
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	28 2f       	mov	r18, r24
     f9e:	30 e0       	ldi	r19, 0x00	; 0
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	02 2e       	mov	r0, r18
     fa6:	02 c0       	rjmp	.+4      	; 0xfac <MDIO_Error_State_SetPinDirection+0x118>
     fa8:	88 0f       	add	r24, r24
     faa:	99 1f       	adc	r25, r25
     fac:	0a 94       	dec	r0
     fae:	e2 f7       	brpl	.-8      	; 0xfa8 <MDIO_Error_State_SetPinDirection+0x114>
     fb0:	80 95       	com	r24
     fb2:	84 23       	and	r24, r20
     fb4:	8c 93       	st	X, r24
     fb6:	67 c0       	rjmp	.+206    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     fb8:	19 82       	std	Y+1, r1	; 0x01
     fba:	65 c0       	rjmp	.+202    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     fbc:	8c 81       	ldd	r24, Y+4	; 0x04
     fbe:	81 30       	cpi	r24, 0x01	; 1
     fc0:	a1 f4       	brne	.+40     	; 0xfea <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
     fc2:	a4 e3       	ldi	r26, 0x34	; 52
     fc4:	b0 e0       	ldi	r27, 0x00	; 0
     fc6:	e4 e3       	ldi	r30, 0x34	; 52
     fc8:	f0 e0       	ldi	r31, 0x00	; 0
     fca:	80 81       	ld	r24, Z
     fcc:	48 2f       	mov	r20, r24
     fce:	8a 81       	ldd	r24, Y+2	; 0x02
     fd0:	28 2f       	mov	r18, r24
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	81 e0       	ldi	r24, 0x01	; 1
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	02 2e       	mov	r0, r18
     fda:	02 c0       	rjmp	.+4      	; 0xfe0 <MDIO_Error_State_SetPinDirection+0x14c>
     fdc:	88 0f       	add	r24, r24
     fde:	99 1f       	adc	r25, r25
     fe0:	0a 94       	dec	r0
     fe2:	e2 f7       	brpl	.-8      	; 0xfdc <MDIO_Error_State_SetPinDirection+0x148>
     fe4:	84 2b       	or	r24, r20
     fe6:	8c 93       	st	X, r24
     fe8:	4e c0       	rjmp	.+156    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     fea:	8c 81       	ldd	r24, Y+4	; 0x04
     fec:	88 23       	and	r24, r24
     fee:	a9 f4       	brne	.+42     	; 0x101a <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
     ff0:	a4 e3       	ldi	r26, 0x34	; 52
     ff2:	b0 e0       	ldi	r27, 0x00	; 0
     ff4:	e4 e3       	ldi	r30, 0x34	; 52
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	48 2f       	mov	r20, r24
     ffc:	8a 81       	ldd	r24, Y+2	; 0x02
     ffe:	28 2f       	mov	r18, r24
    1000:	30 e0       	ldi	r19, 0x00	; 0
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	02 2e       	mov	r0, r18
    1008:	02 c0       	rjmp	.+4      	; 0x100e <MDIO_Error_State_SetPinDirection+0x17a>
    100a:	88 0f       	add	r24, r24
    100c:	99 1f       	adc	r25, r25
    100e:	0a 94       	dec	r0
    1010:	e2 f7       	brpl	.-8      	; 0x100a <MDIO_Error_State_SetPinDirection+0x176>
    1012:	80 95       	com	r24
    1014:	84 23       	and	r24, r20
    1016:	8c 93       	st	X, r24
    1018:	36 c0       	rjmp	.+108    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    101a:	19 82       	std	Y+1, r1	; 0x01
    101c:	34 c0       	rjmp	.+104    	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    101e:	8c 81       	ldd	r24, Y+4	; 0x04
    1020:	81 30       	cpi	r24, 0x01	; 1
    1022:	a1 f4       	brne	.+40     	; 0x104c <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
    1024:	a1 e3       	ldi	r26, 0x31	; 49
    1026:	b0 e0       	ldi	r27, 0x00	; 0
    1028:	e1 e3       	ldi	r30, 0x31	; 49
    102a:	f0 e0       	ldi	r31, 0x00	; 0
    102c:	80 81       	ld	r24, Z
    102e:	48 2f       	mov	r20, r24
    1030:	8a 81       	ldd	r24, Y+2	; 0x02
    1032:	28 2f       	mov	r18, r24
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	02 2e       	mov	r0, r18
    103c:	02 c0       	rjmp	.+4      	; 0x1042 <MDIO_Error_State_SetPinDirection+0x1ae>
    103e:	88 0f       	add	r24, r24
    1040:	99 1f       	adc	r25, r25
    1042:	0a 94       	dec	r0
    1044:	e2 f7       	brpl	.-8      	; 0x103e <MDIO_Error_State_SetPinDirection+0x1aa>
    1046:	84 2b       	or	r24, r20
    1048:	8c 93       	st	X, r24
    104a:	1d c0       	rjmp	.+58     	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    104c:	8c 81       	ldd	r24, Y+4	; 0x04
    104e:	88 23       	and	r24, r24
    1050:	a9 f4       	brne	.+42     	; 0x107c <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
    1052:	a1 e3       	ldi	r26, 0x31	; 49
    1054:	b0 e0       	ldi	r27, 0x00	; 0
    1056:	e1 e3       	ldi	r30, 0x31	; 49
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	80 81       	ld	r24, Z
    105c:	48 2f       	mov	r20, r24
    105e:	8a 81       	ldd	r24, Y+2	; 0x02
    1060:	28 2f       	mov	r18, r24
    1062:	30 e0       	ldi	r19, 0x00	; 0
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	02 2e       	mov	r0, r18
    106a:	02 c0       	rjmp	.+4      	; 0x1070 <MDIO_Error_State_SetPinDirection+0x1dc>
    106c:	88 0f       	add	r24, r24
    106e:	99 1f       	adc	r25, r25
    1070:	0a 94       	dec	r0
    1072:	e2 f7       	brpl	.-8      	; 0x106c <MDIO_Error_State_SetPinDirection+0x1d8>
    1074:	80 95       	com	r24
    1076:	84 23       	and	r24, r20
    1078:	8c 93       	st	X, r24
    107a:	05 c0       	rjmp	.+10     	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    107c:	19 82       	std	Y+1, r1	; 0x01
    107e:	03 c0       	rjmp	.+6      	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1080:	19 82       	std	Y+1, r1	; 0x01
    1082:	01 c0       	rjmp	.+2      	; 0x1086 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1084:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1086:	89 81       	ldd	r24, Y+1	; 0x01
}
    1088:	26 96       	adiw	r28, 0x06	; 6
    108a:	0f b6       	in	r0, 0x3f	; 63
    108c:	f8 94       	cli
    108e:	de bf       	out	0x3e, r29	; 62
    1090:	0f be       	out	0x3f, r0	; 63
    1092:	cd bf       	out	0x3d, r28	; 61
    1094:	cf 91       	pop	r28
    1096:	df 91       	pop	r29
    1098:	08 95       	ret

0000109a <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
    109a:	df 93       	push	r29
    109c:	cf 93       	push	r28
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <MDIO_Error_State_SetPortDirection+0x6>
    10a0:	00 d0       	rcall	.+0      	; 0x10a2 <MDIO_Error_State_SetPortDirection+0x8>
    10a2:	0f 92       	push	r0
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	8a 83       	std	Y+2, r24	; 0x02
    10aa:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
    10b0:	8b 81       	ldd	r24, Y+3	; 0x03
    10b2:	8f 3f       	cpi	r24, 0xFF	; 255
    10b4:	19 f0       	breq	.+6      	; 0x10bc <MDIO_Error_State_SetPortDirection+0x22>
    10b6:	8b 81       	ldd	r24, Y+3	; 0x03
    10b8:	88 23       	and	r24, r24
    10ba:	a9 f5       	brne	.+106    	; 0x1126 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
    10bc:	8a 81       	ldd	r24, Y+2	; 0x02
    10be:	28 2f       	mov	r18, r24
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	3d 83       	std	Y+5, r19	; 0x05
    10c4:	2c 83       	std	Y+4, r18	; 0x04
    10c6:	8c 81       	ldd	r24, Y+4	; 0x04
    10c8:	9d 81       	ldd	r25, Y+5	; 0x05
    10ca:	81 30       	cpi	r24, 0x01	; 1
    10cc:	91 05       	cpc	r25, r1
    10ce:	d1 f0       	breq	.+52     	; 0x1104 <MDIO_Error_State_SetPortDirection+0x6a>
    10d0:	2c 81       	ldd	r18, Y+4	; 0x04
    10d2:	3d 81       	ldd	r19, Y+5	; 0x05
    10d4:	22 30       	cpi	r18, 0x02	; 2
    10d6:	31 05       	cpc	r19, r1
    10d8:	2c f4       	brge	.+10     	; 0x10e4 <MDIO_Error_State_SetPortDirection+0x4a>
    10da:	8c 81       	ldd	r24, Y+4	; 0x04
    10dc:	9d 81       	ldd	r25, Y+5	; 0x05
    10de:	00 97       	sbiw	r24, 0x00	; 0
    10e0:	61 f0       	breq	.+24     	; 0x10fa <MDIO_Error_State_SetPortDirection+0x60>
    10e2:	1f c0       	rjmp	.+62     	; 0x1122 <MDIO_Error_State_SetPortDirection+0x88>
    10e4:	2c 81       	ldd	r18, Y+4	; 0x04
    10e6:	3d 81       	ldd	r19, Y+5	; 0x05
    10e8:	22 30       	cpi	r18, 0x02	; 2
    10ea:	31 05       	cpc	r19, r1
    10ec:	81 f0       	breq	.+32     	; 0x110e <MDIO_Error_State_SetPortDirection+0x74>
    10ee:	8c 81       	ldd	r24, Y+4	; 0x04
    10f0:	9d 81       	ldd	r25, Y+5	; 0x05
    10f2:	83 30       	cpi	r24, 0x03	; 3
    10f4:	91 05       	cpc	r25, r1
    10f6:	81 f0       	breq	.+32     	; 0x1118 <MDIO_Error_State_SetPortDirection+0x7e>
    10f8:	14 c0       	rjmp	.+40     	; 0x1122 <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
    10fa:	ea e3       	ldi	r30, 0x3A	; 58
    10fc:	f0 e0       	ldi	r31, 0x00	; 0
    10fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1100:	80 83       	st	Z, r24
    1102:	12 c0       	rjmp	.+36     	; 0x1128 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
    1104:	e7 e3       	ldi	r30, 0x37	; 55
    1106:	f0 e0       	ldi	r31, 0x00	; 0
    1108:	8b 81       	ldd	r24, Y+3	; 0x03
    110a:	80 83       	st	Z, r24
    110c:	0d c0       	rjmp	.+26     	; 0x1128 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    110e:	e4 e3       	ldi	r30, 0x34	; 52
    1110:	f0 e0       	ldi	r31, 0x00	; 0
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	80 83       	st	Z, r24
    1116:	08 c0       	rjmp	.+16     	; 0x1128 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    1118:	e1 e3       	ldi	r30, 0x31	; 49
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	8b 81       	ldd	r24, Y+3	; 0x03
    111e:	80 83       	st	Z, r24
    1120:	03 c0       	rjmp	.+6      	; 0x1128 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1122:	19 82       	std	Y+1, r1	; 0x01
    1124:	01 c0       	rjmp	.+2      	; 0x1128 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1126:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    1128:	89 81       	ldd	r24, Y+1	; 0x01
}
    112a:	0f 90       	pop	r0
    112c:	0f 90       	pop	r0
    112e:	0f 90       	pop	r0
    1130:	0f 90       	pop	r0
    1132:	0f 90       	pop	r0
    1134:	cf 91       	pop	r28
    1136:	df 91       	pop	r29
    1138:	08 95       	ret

0000113a <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    113a:	df 93       	push	r29
    113c:	cf 93       	push	r28
    113e:	00 d0       	rcall	.+0      	; 0x1140 <MDIO_Error_State_SetPinValue+0x6>
    1140:	00 d0       	rcall	.+0      	; 0x1142 <MDIO_Error_State_SetPinValue+0x8>
    1142:	00 d0       	rcall	.+0      	; 0x1144 <MDIO_Error_State_SetPinValue+0xa>
    1144:	cd b7       	in	r28, 0x3d	; 61
    1146:	de b7       	in	r29, 0x3e	; 62
    1148:	8a 83       	std	Y+2, r24	; 0x02
    114a:	6b 83       	std	Y+3, r22	; 0x03
    114c:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1152:	8a 81       	ldd	r24, Y+2	; 0x02
    1154:	88 30       	cpi	r24, 0x08	; 8
    1156:	08 f0       	brcs	.+2      	; 0x115a <MDIO_Error_State_SetPinValue+0x20>
    1158:	e8 c0       	rjmp	.+464    	; 0x132a <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	3e 83       	std	Y+6, r19	; 0x06
    1162:	2d 83       	std	Y+5, r18	; 0x05
    1164:	8d 81       	ldd	r24, Y+5	; 0x05
    1166:	9e 81       	ldd	r25, Y+6	; 0x06
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	91 05       	cpc	r25, r1
    116c:	09 f4       	brne	.+2      	; 0x1170 <MDIO_Error_State_SetPinValue+0x36>
    116e:	48 c0       	rjmp	.+144    	; 0x1200 <MDIO_Error_State_SetPinValue+0xc6>
    1170:	2d 81       	ldd	r18, Y+5	; 0x05
    1172:	3e 81       	ldd	r19, Y+6	; 0x06
    1174:	22 30       	cpi	r18, 0x02	; 2
    1176:	31 05       	cpc	r19, r1
    1178:	2c f4       	brge	.+10     	; 0x1184 <MDIO_Error_State_SetPinValue+0x4a>
    117a:	8d 81       	ldd	r24, Y+5	; 0x05
    117c:	9e 81       	ldd	r25, Y+6	; 0x06
    117e:	00 97       	sbiw	r24, 0x00	; 0
    1180:	71 f0       	breq	.+28     	; 0x119e <MDIO_Error_State_SetPinValue+0x64>
    1182:	d1 c0       	rjmp	.+418    	; 0x1326 <MDIO_Error_State_SetPinValue+0x1ec>
    1184:	2d 81       	ldd	r18, Y+5	; 0x05
    1186:	3e 81       	ldd	r19, Y+6	; 0x06
    1188:	22 30       	cpi	r18, 0x02	; 2
    118a:	31 05       	cpc	r19, r1
    118c:	09 f4       	brne	.+2      	; 0x1190 <MDIO_Error_State_SetPinValue+0x56>
    118e:	69 c0       	rjmp	.+210    	; 0x1262 <MDIO_Error_State_SetPinValue+0x128>
    1190:	8d 81       	ldd	r24, Y+5	; 0x05
    1192:	9e 81       	ldd	r25, Y+6	; 0x06
    1194:	83 30       	cpi	r24, 0x03	; 3
    1196:	91 05       	cpc	r25, r1
    1198:	09 f4       	brne	.+2      	; 0x119c <MDIO_Error_State_SetPinValue+0x62>
    119a:	94 c0       	rjmp	.+296    	; 0x12c4 <MDIO_Error_State_SetPinValue+0x18a>
    119c:	c4 c0       	rjmp	.+392    	; 0x1326 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    119e:	8c 81       	ldd	r24, Y+4	; 0x04
    11a0:	81 30       	cpi	r24, 0x01	; 1
    11a2:	a1 f4       	brne	.+40     	; 0x11cc <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    11a4:	ab e3       	ldi	r26, 0x3B	; 59
    11a6:	b0 e0       	ldi	r27, 0x00	; 0
    11a8:	eb e3       	ldi	r30, 0x3B	; 59
    11aa:	f0 e0       	ldi	r31, 0x00	; 0
    11ac:	80 81       	ld	r24, Z
    11ae:	48 2f       	mov	r20, r24
    11b0:	8a 81       	ldd	r24, Y+2	; 0x02
    11b2:	28 2f       	mov	r18, r24
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	02 2e       	mov	r0, r18
    11bc:	02 c0       	rjmp	.+4      	; 0x11c2 <MDIO_Error_State_SetPinValue+0x88>
    11be:	88 0f       	add	r24, r24
    11c0:	99 1f       	adc	r25, r25
    11c2:	0a 94       	dec	r0
    11c4:	e2 f7       	brpl	.-8      	; 0x11be <MDIO_Error_State_SetPinValue+0x84>
    11c6:	84 2b       	or	r24, r20
    11c8:	8c 93       	st	X, r24
    11ca:	b0 c0       	rjmp	.+352    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    11cc:	8c 81       	ldd	r24, Y+4	; 0x04
    11ce:	88 23       	and	r24, r24
    11d0:	a9 f4       	brne	.+42     	; 0x11fc <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    11d2:	ab e3       	ldi	r26, 0x3B	; 59
    11d4:	b0 e0       	ldi	r27, 0x00	; 0
    11d6:	eb e3       	ldi	r30, 0x3B	; 59
    11d8:	f0 e0       	ldi	r31, 0x00	; 0
    11da:	80 81       	ld	r24, Z
    11dc:	48 2f       	mov	r20, r24
    11de:	8a 81       	ldd	r24, Y+2	; 0x02
    11e0:	28 2f       	mov	r18, r24
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	02 2e       	mov	r0, r18
    11ea:	02 c0       	rjmp	.+4      	; 0x11f0 <MDIO_Error_State_SetPinValue+0xb6>
    11ec:	88 0f       	add	r24, r24
    11ee:	99 1f       	adc	r25, r25
    11f0:	0a 94       	dec	r0
    11f2:	e2 f7       	brpl	.-8      	; 0x11ec <MDIO_Error_State_SetPinValue+0xb2>
    11f4:	80 95       	com	r24
    11f6:	84 23       	and	r24, r20
    11f8:	8c 93       	st	X, r24
    11fa:	98 c0       	rjmp	.+304    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11fc:	19 82       	std	Y+1, r1	; 0x01
    11fe:	96 c0       	rjmp	.+300    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    1200:	8c 81       	ldd	r24, Y+4	; 0x04
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	a1 f4       	brne	.+40     	; 0x122e <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    1206:	a8 e3       	ldi	r26, 0x38	; 56
    1208:	b0 e0       	ldi	r27, 0x00	; 0
    120a:	e8 e3       	ldi	r30, 0x38	; 56
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	48 2f       	mov	r20, r24
    1212:	8a 81       	ldd	r24, Y+2	; 0x02
    1214:	28 2f       	mov	r18, r24
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	81 e0       	ldi	r24, 0x01	; 1
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	02 2e       	mov	r0, r18
    121e:	02 c0       	rjmp	.+4      	; 0x1224 <MDIO_Error_State_SetPinValue+0xea>
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	0a 94       	dec	r0
    1226:	e2 f7       	brpl	.-8      	; 0x1220 <MDIO_Error_State_SetPinValue+0xe6>
    1228:	84 2b       	or	r24, r20
    122a:	8c 93       	st	X, r24
    122c:	7f c0       	rjmp	.+254    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    122e:	8c 81       	ldd	r24, Y+4	; 0x04
    1230:	88 23       	and	r24, r24
    1232:	a9 f4       	brne	.+42     	; 0x125e <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    1234:	a8 e3       	ldi	r26, 0x38	; 56
    1236:	b0 e0       	ldi	r27, 0x00	; 0
    1238:	e8 e3       	ldi	r30, 0x38	; 56
    123a:	f0 e0       	ldi	r31, 0x00	; 0
    123c:	80 81       	ld	r24, Z
    123e:	48 2f       	mov	r20, r24
    1240:	8a 81       	ldd	r24, Y+2	; 0x02
    1242:	28 2f       	mov	r18, r24
    1244:	30 e0       	ldi	r19, 0x00	; 0
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	02 2e       	mov	r0, r18
    124c:	02 c0       	rjmp	.+4      	; 0x1252 <MDIO_Error_State_SetPinValue+0x118>
    124e:	88 0f       	add	r24, r24
    1250:	99 1f       	adc	r25, r25
    1252:	0a 94       	dec	r0
    1254:	e2 f7       	brpl	.-8      	; 0x124e <MDIO_Error_State_SetPinValue+0x114>
    1256:	80 95       	com	r24
    1258:	84 23       	and	r24, r20
    125a:	8c 93       	st	X, r24
    125c:	67 c0       	rjmp	.+206    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    125e:	19 82       	std	Y+1, r1	; 0x01
    1260:	65 c0       	rjmp	.+202    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    1262:	8c 81       	ldd	r24, Y+4	; 0x04
    1264:	81 30       	cpi	r24, 0x01	; 1
    1266:	a1 f4       	brne	.+40     	; 0x1290 <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    1268:	a5 e3       	ldi	r26, 0x35	; 53
    126a:	b0 e0       	ldi	r27, 0x00	; 0
    126c:	e5 e3       	ldi	r30, 0x35	; 53
    126e:	f0 e0       	ldi	r31, 0x00	; 0
    1270:	80 81       	ld	r24, Z
    1272:	48 2f       	mov	r20, r24
    1274:	8a 81       	ldd	r24, Y+2	; 0x02
    1276:	28 2f       	mov	r18, r24
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	02 2e       	mov	r0, r18
    1280:	02 c0       	rjmp	.+4      	; 0x1286 <MDIO_Error_State_SetPinValue+0x14c>
    1282:	88 0f       	add	r24, r24
    1284:	99 1f       	adc	r25, r25
    1286:	0a 94       	dec	r0
    1288:	e2 f7       	brpl	.-8      	; 0x1282 <MDIO_Error_State_SetPinValue+0x148>
    128a:	84 2b       	or	r24, r20
    128c:	8c 93       	st	X, r24
    128e:	4e c0       	rjmp	.+156    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1290:	8c 81       	ldd	r24, Y+4	; 0x04
    1292:	88 23       	and	r24, r24
    1294:	a9 f4       	brne	.+42     	; 0x12c0 <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    1296:	a5 e3       	ldi	r26, 0x35	; 53
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	e5 e3       	ldi	r30, 0x35	; 53
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	48 2f       	mov	r20, r24
    12a2:	8a 81       	ldd	r24, Y+2	; 0x02
    12a4:	28 2f       	mov	r18, r24
    12a6:	30 e0       	ldi	r19, 0x00	; 0
    12a8:	81 e0       	ldi	r24, 0x01	; 1
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	02 2e       	mov	r0, r18
    12ae:	02 c0       	rjmp	.+4      	; 0x12b4 <MDIO_Error_State_SetPinValue+0x17a>
    12b0:	88 0f       	add	r24, r24
    12b2:	99 1f       	adc	r25, r25
    12b4:	0a 94       	dec	r0
    12b6:	e2 f7       	brpl	.-8      	; 0x12b0 <MDIO_Error_State_SetPinValue+0x176>
    12b8:	80 95       	com	r24
    12ba:	84 23       	and	r24, r20
    12bc:	8c 93       	st	X, r24
    12be:	36 c0       	rjmp	.+108    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    12c0:	19 82       	std	Y+1, r1	; 0x01
    12c2:	34 c0       	rjmp	.+104    	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    12c4:	8c 81       	ldd	r24, Y+4	; 0x04
    12c6:	81 30       	cpi	r24, 0x01	; 1
    12c8:	a1 f4       	brne	.+40     	; 0x12f2 <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    12ca:	a2 e3       	ldi	r26, 0x32	; 50
    12cc:	b0 e0       	ldi	r27, 0x00	; 0
    12ce:	e2 e3       	ldi	r30, 0x32	; 50
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	80 81       	ld	r24, Z
    12d4:	48 2f       	mov	r20, r24
    12d6:	8a 81       	ldd	r24, Y+2	; 0x02
    12d8:	28 2f       	mov	r18, r24
    12da:	30 e0       	ldi	r19, 0x00	; 0
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	02 2e       	mov	r0, r18
    12e2:	02 c0       	rjmp	.+4      	; 0x12e8 <MDIO_Error_State_SetPinValue+0x1ae>
    12e4:	88 0f       	add	r24, r24
    12e6:	99 1f       	adc	r25, r25
    12e8:	0a 94       	dec	r0
    12ea:	e2 f7       	brpl	.-8      	; 0x12e4 <MDIO_Error_State_SetPinValue+0x1aa>
    12ec:	84 2b       	or	r24, r20
    12ee:	8c 93       	st	X, r24
    12f0:	1d c0       	rjmp	.+58     	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    12f2:	8c 81       	ldd	r24, Y+4	; 0x04
    12f4:	88 23       	and	r24, r24
    12f6:	a9 f4       	brne	.+42     	; 0x1322 <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    12f8:	a2 e3       	ldi	r26, 0x32	; 50
    12fa:	b0 e0       	ldi	r27, 0x00	; 0
    12fc:	e2 e3       	ldi	r30, 0x32	; 50
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	80 81       	ld	r24, Z
    1302:	48 2f       	mov	r20, r24
    1304:	8a 81       	ldd	r24, Y+2	; 0x02
    1306:	28 2f       	mov	r18, r24
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	02 2e       	mov	r0, r18
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <MDIO_Error_State_SetPinValue+0x1dc>
    1312:	88 0f       	add	r24, r24
    1314:	99 1f       	adc	r25, r25
    1316:	0a 94       	dec	r0
    1318:	e2 f7       	brpl	.-8      	; 0x1312 <MDIO_Error_State_SetPinValue+0x1d8>
    131a:	80 95       	com	r24
    131c:	84 23       	and	r24, r20
    131e:	8c 93       	st	X, r24
    1320:	05 c0       	rjmp	.+10     	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1322:	19 82       	std	Y+1, r1	; 0x01
    1324:	03 c0       	rjmp	.+6      	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1326:	19 82       	std	Y+1, r1	; 0x01
    1328:	01 c0       	rjmp	.+2      	; 0x132c <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    132a:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    132c:	89 81       	ldd	r24, Y+1	; 0x01
}
    132e:	26 96       	adiw	r28, 0x06	; 6
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	08 95       	ret

00001340 <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    1340:	df 93       	push	r29
    1342:	cf 93       	push	r28
    1344:	00 d0       	rcall	.+0      	; 0x1346 <MDIO_Error_State_SetPortValue+0x6>
    1346:	00 d0       	rcall	.+0      	; 0x1348 <MDIO_Error_State_SetPortValue+0x8>
    1348:	0f 92       	push	r0
    134a:	cd b7       	in	r28, 0x3d	; 61
    134c:	de b7       	in	r29, 0x3e	; 62
    134e:	8a 83       	std	Y+2, r24	; 0x02
    1350:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    1356:	8a 81       	ldd	r24, Y+2	; 0x02
    1358:	28 2f       	mov	r18, r24
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	3d 83       	std	Y+5, r19	; 0x05
    135e:	2c 83       	std	Y+4, r18	; 0x04
    1360:	8c 81       	ldd	r24, Y+4	; 0x04
    1362:	9d 81       	ldd	r25, Y+5	; 0x05
    1364:	81 30       	cpi	r24, 0x01	; 1
    1366:	91 05       	cpc	r25, r1
    1368:	d1 f0       	breq	.+52     	; 0x139e <MDIO_Error_State_SetPortValue+0x5e>
    136a:	2c 81       	ldd	r18, Y+4	; 0x04
    136c:	3d 81       	ldd	r19, Y+5	; 0x05
    136e:	22 30       	cpi	r18, 0x02	; 2
    1370:	31 05       	cpc	r19, r1
    1372:	2c f4       	brge	.+10     	; 0x137e <MDIO_Error_State_SetPortValue+0x3e>
    1374:	8c 81       	ldd	r24, Y+4	; 0x04
    1376:	9d 81       	ldd	r25, Y+5	; 0x05
    1378:	00 97       	sbiw	r24, 0x00	; 0
    137a:	61 f0       	breq	.+24     	; 0x1394 <MDIO_Error_State_SetPortValue+0x54>
    137c:	1f c0       	rjmp	.+62     	; 0x13bc <MDIO_Error_State_SetPortValue+0x7c>
    137e:	2c 81       	ldd	r18, Y+4	; 0x04
    1380:	3d 81       	ldd	r19, Y+5	; 0x05
    1382:	22 30       	cpi	r18, 0x02	; 2
    1384:	31 05       	cpc	r19, r1
    1386:	81 f0       	breq	.+32     	; 0x13a8 <MDIO_Error_State_SetPortValue+0x68>
    1388:	8c 81       	ldd	r24, Y+4	; 0x04
    138a:	9d 81       	ldd	r25, Y+5	; 0x05
    138c:	83 30       	cpi	r24, 0x03	; 3
    138e:	91 05       	cpc	r25, r1
    1390:	81 f0       	breq	.+32     	; 0x13b2 <MDIO_Error_State_SetPortValue+0x72>
    1392:	14 c0       	rjmp	.+40     	; 0x13bc <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    1394:	eb e3       	ldi	r30, 0x3B	; 59
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	8b 81       	ldd	r24, Y+3	; 0x03
    139a:	80 83       	st	Z, r24
    139c:	10 c0       	rjmp	.+32     	; 0x13be <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    139e:	e8 e3       	ldi	r30, 0x38	; 56
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	8b 81       	ldd	r24, Y+3	; 0x03
    13a4:	80 83       	st	Z, r24
    13a6:	0b c0       	rjmp	.+22     	; 0x13be <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    13a8:	e5 e3       	ldi	r30, 0x35	; 53
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	80 83       	st	Z, r24
    13b0:	06 c0       	rjmp	.+12     	; 0x13be <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    13b2:	e2 e3       	ldi	r30, 0x32	; 50
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	8b 81       	ldd	r24, Y+3	; 0x03
    13b8:	80 83       	st	Z, r24
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    13bc:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    13be:	89 81       	ldd	r24, Y+1	; 0x01
}
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	cf 91       	pop	r28
    13cc:	df 91       	pop	r29
    13ce:	08 95       	ret

000013d0 <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    13d0:	df 93       	push	r29
    13d2:	cf 93       	push	r28
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
    13d8:	27 97       	sbiw	r28, 0x07	; 7
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	de bf       	out	0x3e, r29	; 62
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	cd bf       	out	0x3d, r28	; 61
    13e4:	8a 83       	std	Y+2, r24	; 0x02
    13e6:	6b 83       	std	Y+3, r22	; 0x03
    13e8:	5d 83       	std	Y+5, r21	; 0x05
    13ea:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    13f0:	8a 81       	ldd	r24, Y+2	; 0x02
    13f2:	88 30       	cpi	r24, 0x08	; 8
    13f4:	08 f0       	brcs	.+2      	; 0x13f8 <MDIO_Error_State_GetPinValue+0x28>
    13f6:	79 c0       	rjmp	.+242    	; 0x14ea <MDIO_Error_State_GetPinValue+0x11a>
    13f8:	8c 81       	ldd	r24, Y+4	; 0x04
    13fa:	9d 81       	ldd	r25, Y+5	; 0x05
    13fc:	81 30       	cpi	r24, 0x01	; 1
    13fe:	91 05       	cpc	r25, r1
    1400:	09 f4       	brne	.+2      	; 0x1404 <MDIO_Error_State_GetPinValue+0x34>
    1402:	73 c0       	rjmp	.+230    	; 0x14ea <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    1404:	8b 81       	ldd	r24, Y+3	; 0x03
    1406:	28 2f       	mov	r18, r24
    1408:	30 e0       	ldi	r19, 0x00	; 0
    140a:	3f 83       	std	Y+7, r19	; 0x07
    140c:	2e 83       	std	Y+6, r18	; 0x06
    140e:	4e 81       	ldd	r20, Y+6	; 0x06
    1410:	5f 81       	ldd	r21, Y+7	; 0x07
    1412:	41 30       	cpi	r20, 0x01	; 1
    1414:	51 05       	cpc	r21, r1
    1416:	59 f1       	breq	.+86     	; 0x146e <MDIO_Error_State_GetPinValue+0x9e>
    1418:	8e 81       	ldd	r24, Y+6	; 0x06
    141a:	9f 81       	ldd	r25, Y+7	; 0x07
    141c:	82 30       	cpi	r24, 0x02	; 2
    141e:	91 05       	cpc	r25, r1
    1420:	34 f4       	brge	.+12     	; 0x142e <MDIO_Error_State_GetPinValue+0x5e>
    1422:	2e 81       	ldd	r18, Y+6	; 0x06
    1424:	3f 81       	ldd	r19, Y+7	; 0x07
    1426:	21 15       	cp	r18, r1
    1428:	31 05       	cpc	r19, r1
    142a:	69 f0       	breq	.+26     	; 0x1446 <MDIO_Error_State_GetPinValue+0x76>
    142c:	5c c0       	rjmp	.+184    	; 0x14e6 <MDIO_Error_State_GetPinValue+0x116>
    142e:	4e 81       	ldd	r20, Y+6	; 0x06
    1430:	5f 81       	ldd	r21, Y+7	; 0x07
    1432:	42 30       	cpi	r20, 0x02	; 2
    1434:	51 05       	cpc	r21, r1
    1436:	79 f1       	breq	.+94     	; 0x1496 <MDIO_Error_State_GetPinValue+0xc6>
    1438:	8e 81       	ldd	r24, Y+6	; 0x06
    143a:	9f 81       	ldd	r25, Y+7	; 0x07
    143c:	83 30       	cpi	r24, 0x03	; 3
    143e:	91 05       	cpc	r25, r1
    1440:	09 f4       	brne	.+2      	; 0x1444 <MDIO_Error_State_GetPinValue+0x74>
    1442:	3d c0       	rjmp	.+122    	; 0x14be <MDIO_Error_State_GetPinValue+0xee>
    1444:	50 c0       	rjmp	.+160    	; 0x14e6 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    1446:	e9 e3       	ldi	r30, 0x39	; 57
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	80 81       	ld	r24, Z
    144c:	28 2f       	mov	r18, r24
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	88 2f       	mov	r24, r24
    1454:	90 e0       	ldi	r25, 0x00	; 0
    1456:	a9 01       	movw	r20, r18
    1458:	02 c0       	rjmp	.+4      	; 0x145e <MDIO_Error_State_GetPinValue+0x8e>
    145a:	55 95       	asr	r21
    145c:	47 95       	ror	r20
    145e:	8a 95       	dec	r24
    1460:	e2 f7       	brpl	.-8      	; 0x145a <MDIO_Error_State_GetPinValue+0x8a>
    1462:	ca 01       	movw	r24, r20
    1464:	81 70       	andi	r24, 0x01	; 1
    1466:	ec 81       	ldd	r30, Y+4	; 0x04
    1468:	fd 81       	ldd	r31, Y+5	; 0x05
    146a:	80 83       	st	Z, r24
    146c:	3f c0       	rjmp	.+126    	; 0x14ec <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    146e:	e6 e3       	ldi	r30, 0x36	; 54
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	80 81       	ld	r24, Z
    1474:	28 2f       	mov	r18, r24
    1476:	30 e0       	ldi	r19, 0x00	; 0
    1478:	8a 81       	ldd	r24, Y+2	; 0x02
    147a:	88 2f       	mov	r24, r24
    147c:	90 e0       	ldi	r25, 0x00	; 0
    147e:	a9 01       	movw	r20, r18
    1480:	02 c0       	rjmp	.+4      	; 0x1486 <MDIO_Error_State_GetPinValue+0xb6>
    1482:	55 95       	asr	r21
    1484:	47 95       	ror	r20
    1486:	8a 95       	dec	r24
    1488:	e2 f7       	brpl	.-8      	; 0x1482 <MDIO_Error_State_GetPinValue+0xb2>
    148a:	ca 01       	movw	r24, r20
    148c:	81 70       	andi	r24, 0x01	; 1
    148e:	ec 81       	ldd	r30, Y+4	; 0x04
    1490:	fd 81       	ldd	r31, Y+5	; 0x05
    1492:	80 83       	st	Z, r24
    1494:	2b c0       	rjmp	.+86     	; 0x14ec <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1496:	e3 e3       	ldi	r30, 0x33	; 51
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	28 2f       	mov	r18, r24
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	8a 81       	ldd	r24, Y+2	; 0x02
    14a2:	88 2f       	mov	r24, r24
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	a9 01       	movw	r20, r18
    14a8:	02 c0       	rjmp	.+4      	; 0x14ae <MDIO_Error_State_GetPinValue+0xde>
    14aa:	55 95       	asr	r21
    14ac:	47 95       	ror	r20
    14ae:	8a 95       	dec	r24
    14b0:	e2 f7       	brpl	.-8      	; 0x14aa <MDIO_Error_State_GetPinValue+0xda>
    14b2:	ca 01       	movw	r24, r20
    14b4:	81 70       	andi	r24, 0x01	; 1
    14b6:	ec 81       	ldd	r30, Y+4	; 0x04
    14b8:	fd 81       	ldd	r31, Y+5	; 0x05
    14ba:	80 83       	st	Z, r24
    14bc:	17 c0       	rjmp	.+46     	; 0x14ec <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    14be:	e0 e3       	ldi	r30, 0x30	; 48
    14c0:	f0 e0       	ldi	r31, 0x00	; 0
    14c2:	80 81       	ld	r24, Z
    14c4:	28 2f       	mov	r18, r24
    14c6:	30 e0       	ldi	r19, 0x00	; 0
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	88 2f       	mov	r24, r24
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	a9 01       	movw	r20, r18
    14d0:	02 c0       	rjmp	.+4      	; 0x14d6 <MDIO_Error_State_GetPinValue+0x106>
    14d2:	55 95       	asr	r21
    14d4:	47 95       	ror	r20
    14d6:	8a 95       	dec	r24
    14d8:	e2 f7       	brpl	.-8      	; 0x14d2 <MDIO_Error_State_GetPinValue+0x102>
    14da:	ca 01       	movw	r24, r20
    14dc:	81 70       	andi	r24, 0x01	; 1
    14de:	ec 81       	ldd	r30, Y+4	; 0x04
    14e0:	fd 81       	ldd	r31, Y+5	; 0x05
    14e2:	80 83       	st	Z, r24
    14e4:	03 c0       	rjmp	.+6      	; 0x14ec <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    14e6:	19 82       	std	Y+1, r1	; 0x01
    14e8:	01 c0       	rjmp	.+2      	; 0x14ec <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    14ea:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    14ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    14ee:	27 96       	adiw	r28, 0x07	; 7
    14f0:	0f b6       	in	r0, 0x3f	; 63
    14f2:	f8 94       	cli
    14f4:	de bf       	out	0x3e, r29	; 62
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	cd bf       	out	0x3d, r28	; 61
    14fa:	cf 91       	pop	r28
    14fc:	df 91       	pop	r29
    14fe:	08 95       	ret

00001500 <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    1500:	df 93       	push	r29
    1502:	cf 93       	push	r28
    1504:	00 d0       	rcall	.+0      	; 0x1506 <MDIO_Error_State_SetNippleValue+0x6>
    1506:	00 d0       	rcall	.+0      	; 0x1508 <MDIO_Error_State_SetNippleValue+0x8>
    1508:	00 d0       	rcall	.+0      	; 0x150a <MDIO_Error_State_SetNippleValue+0xa>
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
    150e:	8a 83       	std	Y+2, r24	; 0x02
    1510:	6b 83       	std	Y+3, r22	; 0x03
    1512:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    1518:	8a 81       	ldd	r24, Y+2	; 0x02
    151a:	85 30       	cpi	r24, 0x05	; 5
    151c:	08 f0       	brcs	.+2      	; 0x1520 <MDIO_Error_State_SetNippleValue+0x20>
    151e:	97 c0       	rjmp	.+302    	; 0x164e <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    1520:	8b 81       	ldd	r24, Y+3	; 0x03
    1522:	28 2f       	mov	r18, r24
    1524:	30 e0       	ldi	r19, 0x00	; 0
    1526:	3e 83       	std	Y+6, r19	; 0x06
    1528:	2d 83       	std	Y+5, r18	; 0x05
    152a:	8d 81       	ldd	r24, Y+5	; 0x05
    152c:	9e 81       	ldd	r25, Y+6	; 0x06
    152e:	81 30       	cpi	r24, 0x01	; 1
    1530:	91 05       	cpc	r25, r1
    1532:	a1 f1       	breq	.+104    	; 0x159c <MDIO_Error_State_SetNippleValue+0x9c>
    1534:	2d 81       	ldd	r18, Y+5	; 0x05
    1536:	3e 81       	ldd	r19, Y+6	; 0x06
    1538:	22 30       	cpi	r18, 0x02	; 2
    153a:	31 05       	cpc	r19, r1
    153c:	2c f4       	brge	.+10     	; 0x1548 <MDIO_Error_State_SetNippleValue+0x48>
    153e:	8d 81       	ldd	r24, Y+5	; 0x05
    1540:	9e 81       	ldd	r25, Y+6	; 0x06
    1542:	00 97       	sbiw	r24, 0x00	; 0
    1544:	71 f0       	breq	.+28     	; 0x1562 <MDIO_Error_State_SetNippleValue+0x62>
    1546:	81 c0       	rjmp	.+258    	; 0x164a <MDIO_Error_State_SetNippleValue+0x14a>
    1548:	2d 81       	ldd	r18, Y+5	; 0x05
    154a:	3e 81       	ldd	r19, Y+6	; 0x06
    154c:	22 30       	cpi	r18, 0x02	; 2
    154e:	31 05       	cpc	r19, r1
    1550:	09 f4       	brne	.+2      	; 0x1554 <MDIO_Error_State_SetNippleValue+0x54>
    1552:	41 c0       	rjmp	.+130    	; 0x15d6 <MDIO_Error_State_SetNippleValue+0xd6>
    1554:	8d 81       	ldd	r24, Y+5	; 0x05
    1556:	9e 81       	ldd	r25, Y+6	; 0x06
    1558:	83 30       	cpi	r24, 0x03	; 3
    155a:	91 05       	cpc	r25, r1
    155c:	09 f4       	brne	.+2      	; 0x1560 <MDIO_Error_State_SetNippleValue+0x60>
    155e:	58 c0       	rjmp	.+176    	; 0x1610 <MDIO_Error_State_SetNippleValue+0x110>
    1560:	74 c0       	rjmp	.+232    	; 0x164a <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    1562:	ab e3       	ldi	r26, 0x3B	; 59
    1564:	b0 e0       	ldi	r27, 0x00	; 0
    1566:	eb e3       	ldi	r30, 0x3B	; 59
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 81       	ld	r24, Z
    156c:	48 2f       	mov	r20, r24
    156e:	8a 81       	ldd	r24, Y+2	; 0x02
    1570:	28 2f       	mov	r18, r24
    1572:	30 e0       	ldi	r19, 0x00	; 0
    1574:	8f e0       	ldi	r24, 0x0F	; 15
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	02 2e       	mov	r0, r18
    157a:	02 c0       	rjmp	.+4      	; 0x1580 <MDIO_Error_State_SetNippleValue+0x80>
    157c:	88 0f       	add	r24, r24
    157e:	99 1f       	adc	r25, r25
    1580:	0a 94       	dec	r0
    1582:	e2 f7       	brpl	.-8      	; 0x157c <MDIO_Error_State_SetNippleValue+0x7c>
    1584:	80 95       	com	r24
    1586:	84 23       	and	r24, r20
    1588:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    158a:	ab e3       	ldi	r26, 0x3B	; 59
    158c:	b0 e0       	ldi	r27, 0x00	; 0
    158e:	eb e3       	ldi	r30, 0x3B	; 59
    1590:	f0 e0       	ldi	r31, 0x00	; 0
    1592:	90 81       	ld	r25, Z
    1594:	8c 81       	ldd	r24, Y+4	; 0x04
    1596:	89 2b       	or	r24, r25
    1598:	8c 93       	st	X, r24
    159a:	5a c0       	rjmp	.+180    	; 0x1650 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    159c:	a8 e3       	ldi	r26, 0x38	; 56
    159e:	b0 e0       	ldi	r27, 0x00	; 0
    15a0:	e8 e3       	ldi	r30, 0x38	; 56
    15a2:	f0 e0       	ldi	r31, 0x00	; 0
    15a4:	80 81       	ld	r24, Z
    15a6:	48 2f       	mov	r20, r24
    15a8:	8a 81       	ldd	r24, Y+2	; 0x02
    15aa:	28 2f       	mov	r18, r24
    15ac:	30 e0       	ldi	r19, 0x00	; 0
    15ae:	8f e0       	ldi	r24, 0x0F	; 15
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	02 2e       	mov	r0, r18
    15b4:	02 c0       	rjmp	.+4      	; 0x15ba <MDIO_Error_State_SetNippleValue+0xba>
    15b6:	88 0f       	add	r24, r24
    15b8:	99 1f       	adc	r25, r25
    15ba:	0a 94       	dec	r0
    15bc:	e2 f7       	brpl	.-8      	; 0x15b6 <MDIO_Error_State_SetNippleValue+0xb6>
    15be:	80 95       	com	r24
    15c0:	84 23       	and	r24, r20
    15c2:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    15c4:	a8 e3       	ldi	r26, 0x38	; 56
    15c6:	b0 e0       	ldi	r27, 0x00	; 0
    15c8:	e8 e3       	ldi	r30, 0x38	; 56
    15ca:	f0 e0       	ldi	r31, 0x00	; 0
    15cc:	90 81       	ld	r25, Z
    15ce:	8c 81       	ldd	r24, Y+4	; 0x04
    15d0:	89 2b       	or	r24, r25
    15d2:	8c 93       	st	X, r24
    15d4:	3d c0       	rjmp	.+122    	; 0x1650 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    15d6:	a5 e3       	ldi	r26, 0x35	; 53
    15d8:	b0 e0       	ldi	r27, 0x00	; 0
    15da:	e5 e3       	ldi	r30, 0x35	; 53
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	80 81       	ld	r24, Z
    15e0:	48 2f       	mov	r20, r24
    15e2:	8a 81       	ldd	r24, Y+2	; 0x02
    15e4:	28 2f       	mov	r18, r24
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	8f e0       	ldi	r24, 0x0F	; 15
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	02 2e       	mov	r0, r18
    15ee:	02 c0       	rjmp	.+4      	; 0x15f4 <MDIO_Error_State_SetNippleValue+0xf4>
    15f0:	88 0f       	add	r24, r24
    15f2:	99 1f       	adc	r25, r25
    15f4:	0a 94       	dec	r0
    15f6:	e2 f7       	brpl	.-8      	; 0x15f0 <MDIO_Error_State_SetNippleValue+0xf0>
    15f8:	80 95       	com	r24
    15fa:	84 23       	and	r24, r20
    15fc:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    15fe:	a5 e3       	ldi	r26, 0x35	; 53
    1600:	b0 e0       	ldi	r27, 0x00	; 0
    1602:	e5 e3       	ldi	r30, 0x35	; 53
    1604:	f0 e0       	ldi	r31, 0x00	; 0
    1606:	90 81       	ld	r25, Z
    1608:	8c 81       	ldd	r24, Y+4	; 0x04
    160a:	89 2b       	or	r24, r25
    160c:	8c 93       	st	X, r24
    160e:	20 c0       	rjmp	.+64     	; 0x1650 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    1610:	a2 e3       	ldi	r26, 0x32	; 50
    1612:	b0 e0       	ldi	r27, 0x00	; 0
    1614:	e2 e3       	ldi	r30, 0x32	; 50
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	80 81       	ld	r24, Z
    161a:	48 2f       	mov	r20, r24
    161c:	8a 81       	ldd	r24, Y+2	; 0x02
    161e:	28 2f       	mov	r18, r24
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	8f e0       	ldi	r24, 0x0F	; 15
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	02 2e       	mov	r0, r18
    1628:	02 c0       	rjmp	.+4      	; 0x162e <MDIO_Error_State_SetNippleValue+0x12e>
    162a:	88 0f       	add	r24, r24
    162c:	99 1f       	adc	r25, r25
    162e:	0a 94       	dec	r0
    1630:	e2 f7       	brpl	.-8      	; 0x162a <MDIO_Error_State_SetNippleValue+0x12a>
    1632:	80 95       	com	r24
    1634:	84 23       	and	r24, r20
    1636:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    1638:	a2 e3       	ldi	r26, 0x32	; 50
    163a:	b0 e0       	ldi	r27, 0x00	; 0
    163c:	e2 e3       	ldi	r30, 0x32	; 50
    163e:	f0 e0       	ldi	r31, 0x00	; 0
    1640:	90 81       	ld	r25, Z
    1642:	8c 81       	ldd	r24, Y+4	; 0x04
    1644:	89 2b       	or	r24, r25
    1646:	8c 93       	st	X, r24
    1648:	03 c0       	rjmp	.+6      	; 0x1650 <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    164a:	19 82       	std	Y+1, r1	; 0x01
    164c:	01 c0       	rjmp	.+2      	; 0x1650 <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    164e:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    1650:	89 81       	ldd	r24, Y+1	; 0x01
}
    1652:	26 96       	adiw	r28, 0x06	; 6
    1654:	0f b6       	in	r0, 0x3f	; 63
    1656:	f8 94       	cli
    1658:	de bf       	out	0x3e, r29	; 62
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	cd bf       	out	0x3d, r28	; 61
    165e:	cf 91       	pop	r28
    1660:	df 91       	pop	r29
    1662:	08 95       	ret

00001664 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1664:	df 93       	push	r29
    1666:	cf 93       	push	r28
    1668:	00 d0       	rcall	.+0      	; 0x166a <xEventGroupCreate+0x6>
    166a:	cd b7       	in	r28, 0x3d	; 61
    166c:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    166e:	8b e0       	ldi	r24, 0x0B	; 11
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	0e 94 77 0e 	call	0x1cee	; 0x1cee <pvPortMalloc>
    1676:	9a 83       	std	Y+2, r25	; 0x02
    1678:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    167a:	89 81       	ldd	r24, Y+1	; 0x01
    167c:	9a 81       	ldd	r25, Y+2	; 0x02
    167e:	00 97       	sbiw	r24, 0x00	; 0
    1680:	49 f0       	breq	.+18     	; 0x1694 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1682:	e9 81       	ldd	r30, Y+1	; 0x01
    1684:	fa 81       	ldd	r31, Y+2	; 0x02
    1686:	11 82       	std	Z+1, r1	; 0x01
    1688:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	9a 81       	ldd	r25, Y+2	; 0x02
    168e:	02 96       	adiw	r24, 0x02	; 2
    1690:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1694:	89 81       	ldd	r24, Y+1	; 0x01
    1696:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	cf 91       	pop	r28
    169e:	df 91       	pop	r29
    16a0:	08 95       	ret

000016a2 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    16a2:	df 93       	push	r29
    16a4:	cf 93       	push	r28
    16a6:	cd b7       	in	r28, 0x3d	; 61
    16a8:	de b7       	in	r29, 0x3e	; 62
    16aa:	60 97       	sbiw	r28, 0x10	; 16
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	f8 94       	cli
    16b0:	de bf       	out	0x3e, r29	; 62
    16b2:	0f be       	out	0x3f, r0	; 63
    16b4:	cd bf       	out	0x3d, r28	; 61
    16b6:	9a 87       	std	Y+10, r25	; 0x0a
    16b8:	89 87       	std	Y+9, r24	; 0x09
    16ba:	7c 87       	std	Y+12, r23	; 0x0c
    16bc:	6b 87       	std	Y+11, r22	; 0x0b
    16be:	5e 87       	std	Y+14, r21	; 0x0e
    16c0:	4d 87       	std	Y+13, r20	; 0x0d
    16c2:	38 8b       	std	Y+16, r19	; 0x10
    16c4:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    16c6:	89 85       	ldd	r24, Y+9	; 0x09
    16c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    16ca:	9c 83       	std	Y+4, r25	; 0x04
    16cc:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    16ce:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    16d0:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    16d4:	eb 81       	ldd	r30, Y+3	; 0x03
    16d6:	fc 81       	ldd	r31, Y+4	; 0x04
    16d8:	80 81       	ld	r24, Z
    16da:	91 81       	ldd	r25, Z+1	; 0x01
    16dc:	98 87       	std	Y+8, r25	; 0x08
    16de:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    16e0:	89 85       	ldd	r24, Y+9	; 0x09
    16e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    16e4:	2b 85       	ldd	r18, Y+11	; 0x0b
    16e6:	3c 85       	ldd	r19, Y+12	; 0x0c
    16e8:	b9 01       	movw	r22, r18
    16ea:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    16ee:	2f 81       	ldd	r18, Y+7	; 0x07
    16f0:	38 85       	ldd	r19, Y+8	; 0x08
    16f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    16f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    16f6:	28 2b       	or	r18, r24
    16f8:	39 2b       	or	r19, r25
    16fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    16fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    16fe:	28 23       	and	r18, r24
    1700:	39 23       	and	r19, r25
    1702:	8d 85       	ldd	r24, Y+13	; 0x0d
    1704:	9e 85       	ldd	r25, Y+14	; 0x0e
    1706:	28 17       	cp	r18, r24
    1708:	39 07       	cpc	r19, r25
    170a:	c9 f4       	brne	.+50     	; 0x173e <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    170c:	2f 81       	ldd	r18, Y+7	; 0x07
    170e:	38 85       	ldd	r19, Y+8	; 0x08
    1710:	8b 85       	ldd	r24, Y+11	; 0x0b
    1712:	9c 85       	ldd	r25, Y+12	; 0x0c
    1714:	82 2b       	or	r24, r18
    1716:	93 2b       	or	r25, r19
    1718:	9e 83       	std	Y+6, r25	; 0x06
    171a:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    171c:	eb 81       	ldd	r30, Y+3	; 0x03
    171e:	fc 81       	ldd	r31, Y+4	; 0x04
    1720:	20 81       	ld	r18, Z
    1722:	31 81       	ldd	r19, Z+1	; 0x01
    1724:	8d 85       	ldd	r24, Y+13	; 0x0d
    1726:	9e 85       	ldd	r25, Y+14	; 0x0e
    1728:	80 95       	com	r24
    172a:	90 95       	com	r25
    172c:	82 23       	and	r24, r18
    172e:	93 23       	and	r25, r19
    1730:	eb 81       	ldd	r30, Y+3	; 0x03
    1732:	fc 81       	ldd	r31, Y+4	; 0x04
    1734:	91 83       	std	Z+1, r25	; 0x01
    1736:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1738:	18 8a       	std	Y+16, r1	; 0x10
    173a:	1f 86       	std	Y+15, r1	; 0x0f
    173c:	1e c0       	rjmp	.+60     	; 0x177a <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    173e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1740:	98 89       	ldd	r25, Y+16	; 0x10
    1742:	00 97       	sbiw	r24, 0x00	; 0
    1744:	91 f0       	breq	.+36     	; 0x176a <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1746:	8b 81       	ldd	r24, Y+3	; 0x03
    1748:	9c 81       	ldd	r25, Y+4	; 0x04
    174a:	bc 01       	movw	r22, r24
    174c:	6e 5f       	subi	r22, 0xFE	; 254
    174e:	7f 4f       	sbci	r23, 0xFF	; 255
    1750:	8d 85       	ldd	r24, Y+13	; 0x0d
    1752:	9e 85       	ldd	r25, Y+14	; 0x0e
    1754:	9c 01       	movw	r18, r24
    1756:	35 60       	ori	r19, 0x05	; 5
    1758:	4f 85       	ldd	r20, Y+15	; 0x0f
    175a:	58 89       	ldd	r21, Y+16	; 0x10
    175c:	cb 01       	movw	r24, r22
    175e:	b9 01       	movw	r22, r18
    1760:	0e 94 a6 29 	call	0x534c	; 0x534c <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1764:	1e 82       	std	Y+6, r1	; 0x06
    1766:	1d 82       	std	Y+5, r1	; 0x05
    1768:	08 c0       	rjmp	.+16     	; 0x177a <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    176a:	eb 81       	ldd	r30, Y+3	; 0x03
    176c:	fc 81       	ldd	r31, Y+4	; 0x04
    176e:	80 81       	ld	r24, Z
    1770:	91 81       	ldd	r25, Z+1	; 0x01
    1772:	9e 83       	std	Y+6, r25	; 0x06
    1774:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1776:	81 e0       	ldi	r24, 0x01	; 1
    1778:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    177a:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    177e:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1780:	8f 85       	ldd	r24, Y+15	; 0x0f
    1782:	98 89       	ldd	r25, Y+16	; 0x10
    1784:	00 97       	sbiw	r24, 0x00	; 0
    1786:	09 f4       	brne	.+2      	; 0x178a <xEventGroupSync+0xe8>
    1788:	3a c0       	rjmp	.+116    	; 0x17fe <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    178a:	8a 81       	ldd	r24, Y+2	; 0x02
    178c:	88 23       	and	r24, r24
    178e:	11 f4       	brne	.+4      	; 0x1794 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1790:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1794:	0e 94 cb 2d 	call	0x5b96	; 0x5b96 <uxTaskResetEventItemValue>
    1798:	9e 83       	std	Y+6, r25	; 0x06
    179a:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    179c:	8d 81       	ldd	r24, Y+5	; 0x05
    179e:	9e 81       	ldd	r25, Y+6	; 0x06
    17a0:	80 70       	andi	r24, 0x00	; 0
    17a2:	92 70       	andi	r25, 0x02	; 2
    17a4:	00 97       	sbiw	r24, 0x00	; 0
    17a6:	31 f5       	brne	.+76     	; 0x17f4 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    17ae:	eb 81       	ldd	r30, Y+3	; 0x03
    17b0:	fc 81       	ldd	r31, Y+4	; 0x04
    17b2:	80 81       	ld	r24, Z
    17b4:	91 81       	ldd	r25, Z+1	; 0x01
    17b6:	9e 83       	std	Y+6, r25	; 0x06
    17b8:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    17ba:	2d 81       	ldd	r18, Y+5	; 0x05
    17bc:	3e 81       	ldd	r19, Y+6	; 0x06
    17be:	8d 85       	ldd	r24, Y+13	; 0x0d
    17c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    17c2:	28 23       	and	r18, r24
    17c4:	39 23       	and	r19, r25
    17c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    17c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    17ca:	28 17       	cp	r18, r24
    17cc:	39 07       	cpc	r19, r25
    17ce:	71 f4       	brne	.+28     	; 0x17ec <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    17d0:	eb 81       	ldd	r30, Y+3	; 0x03
    17d2:	fc 81       	ldd	r31, Y+4	; 0x04
    17d4:	20 81       	ld	r18, Z
    17d6:	31 81       	ldd	r19, Z+1	; 0x01
    17d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    17da:	9e 85       	ldd	r25, Y+14	; 0x0e
    17dc:	80 95       	com	r24
    17de:	90 95       	com	r25
    17e0:	82 23       	and	r24, r18
    17e2:	93 23       	and	r25, r19
    17e4:	eb 81       	ldd	r30, Y+3	; 0x03
    17e6:	fc 81       	ldd	r31, Y+4	; 0x04
    17e8:	91 83       	std	Z+1, r25	; 0x01
    17ea:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    17f4:	8d 81       	ldd	r24, Y+5	; 0x05
    17f6:	9e 81       	ldd	r25, Y+6	; 0x06
    17f8:	90 70       	andi	r25, 0x00	; 0
    17fa:	9e 83       	std	Y+6, r25	; 0x06
    17fc:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    17fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1800:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1802:	60 96       	adiw	r28, 0x10	; 16
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    180e:	cf 91       	pop	r28
    1810:	df 91       	pop	r29
    1812:	08 95       	ret

00001814 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	df 93       	push	r29
    181a:	cf 93       	push	r28
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
    1820:	63 97       	sbiw	r28, 0x13	; 19
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	de bf       	out	0x3e, r29	; 62
    1828:	0f be       	out	0x3f, r0	; 63
    182a:	cd bf       	out	0x3d, r28	; 61
    182c:	9d 87       	std	Y+13, r25	; 0x0d
    182e:	8c 87       	std	Y+12, r24	; 0x0c
    1830:	7f 87       	std	Y+15, r23	; 0x0f
    1832:	6e 87       	std	Y+14, r22	; 0x0e
    1834:	48 8b       	std	Y+16, r20	; 0x10
    1836:	29 8b       	std	Y+17, r18	; 0x11
    1838:	1b 8b       	std	Y+19, r17	; 0x13
    183a:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    183c:	8c 85       	ldd	r24, Y+12	; 0x0c
    183e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1840:	9b 87       	std	Y+11, r25	; 0x0b
    1842:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1844:	1f 82       	std	Y+7, r1	; 0x07
    1846:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1848:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    184a:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    184e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1850:	fb 85       	ldd	r31, Y+11	; 0x0b
    1852:	80 81       	ld	r24, Z
    1854:	91 81       	ldd	r25, Z+1	; 0x01
    1856:	9a 83       	std	Y+2, r25	; 0x02
    1858:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    185a:	89 81       	ldd	r24, Y+1	; 0x01
    185c:	9a 81       	ldd	r25, Y+2	; 0x02
    185e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1860:	3f 85       	ldd	r19, Y+15	; 0x0f
    1862:	b9 01       	movw	r22, r18
    1864:	49 89       	ldd	r20, Y+17	; 0x11
    1866:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <prvTestWaitCondition>
    186a:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    186c:	8d 81       	ldd	r24, Y+5	; 0x05
    186e:	88 23       	and	r24, r24
    1870:	c1 f0       	breq	.+48     	; 0x18a2 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1872:	89 81       	ldd	r24, Y+1	; 0x01
    1874:	9a 81       	ldd	r25, Y+2	; 0x02
    1876:	99 87       	std	Y+9, r25	; 0x09
    1878:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    187a:	1b 8a       	std	Y+19, r1	; 0x13
    187c:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    187e:	88 89       	ldd	r24, Y+16	; 0x10
    1880:	88 23       	and	r24, r24
    1882:	e9 f1       	breq	.+122    	; 0x18fe <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1884:	ea 85       	ldd	r30, Y+10	; 0x0a
    1886:	fb 85       	ldd	r31, Y+11	; 0x0b
    1888:	20 81       	ld	r18, Z
    188a:	31 81       	ldd	r19, Z+1	; 0x01
    188c:	8e 85       	ldd	r24, Y+14	; 0x0e
    188e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1890:	80 95       	com	r24
    1892:	90 95       	com	r25
    1894:	82 23       	and	r24, r18
    1896:	93 23       	and	r25, r19
    1898:	ea 85       	ldd	r30, Y+10	; 0x0a
    189a:	fb 85       	ldd	r31, Y+11	; 0x0b
    189c:	91 83       	std	Z+1, r25	; 0x01
    189e:	80 83       	st	Z, r24
    18a0:	2e c0       	rjmp	.+92     	; 0x18fe <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    18a2:	8a 89       	ldd	r24, Y+18	; 0x12
    18a4:	9b 89       	ldd	r25, Y+19	; 0x13
    18a6:	00 97       	sbiw	r24, 0x00	; 0
    18a8:	39 f4       	brne	.+14     	; 0x18b8 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    18aa:	89 81       	ldd	r24, Y+1	; 0x01
    18ac:	9a 81       	ldd	r25, Y+2	; 0x02
    18ae:	99 87       	std	Y+9, r25	; 0x09
    18b0:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	8b 83       	std	Y+3, r24	; 0x03
    18b6:	23 c0       	rjmp	.+70     	; 0x18fe <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    18b8:	88 89       	ldd	r24, Y+16	; 0x10
    18ba:	88 23       	and	r24, r24
    18bc:	29 f0       	breq	.+10     	; 0x18c8 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    18be:	8e 81       	ldd	r24, Y+6	; 0x06
    18c0:	9f 81       	ldd	r25, Y+7	; 0x07
    18c2:	91 60       	ori	r25, 0x01	; 1
    18c4:	9f 83       	std	Y+7, r25	; 0x07
    18c6:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    18c8:	89 89       	ldd	r24, Y+17	; 0x11
    18ca:	88 23       	and	r24, r24
    18cc:	29 f0       	breq	.+10     	; 0x18d8 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    18ce:	8e 81       	ldd	r24, Y+6	; 0x06
    18d0:	9f 81       	ldd	r25, Y+7	; 0x07
    18d2:	94 60       	ori	r25, 0x04	; 4
    18d4:	9f 83       	std	Y+7, r25	; 0x07
    18d6:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    18d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    18da:	9b 85       	ldd	r25, Y+11	; 0x0b
    18dc:	bc 01       	movw	r22, r24
    18de:	6e 5f       	subi	r22, 0xFE	; 254
    18e0:	7f 4f       	sbci	r23, 0xFF	; 255
    18e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    18e4:	3f 85       	ldd	r19, Y+15	; 0x0f
    18e6:	8e 81       	ldd	r24, Y+6	; 0x06
    18e8:	9f 81       	ldd	r25, Y+7	; 0x07
    18ea:	28 2b       	or	r18, r24
    18ec:	39 2b       	or	r19, r25
    18ee:	4a 89       	ldd	r20, Y+18	; 0x12
    18f0:	5b 89       	ldd	r21, Y+19	; 0x13
    18f2:	cb 01       	movw	r24, r22
    18f4:	b9 01       	movw	r22, r18
    18f6:	0e 94 a6 29 	call	0x534c	; 0x534c <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    18fa:	19 86       	std	Y+9, r1	; 0x09
    18fc:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    18fe:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    1902:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1904:	8a 89       	ldd	r24, Y+18	; 0x12
    1906:	9b 89       	ldd	r25, Y+19	; 0x13
    1908:	00 97       	sbiw	r24, 0x00	; 0
    190a:	09 f4       	brne	.+2      	; 0x190e <xEventGroupWaitBits+0xfa>
    190c:	3c c0       	rjmp	.+120    	; 0x1986 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    190e:	8c 81       	ldd	r24, Y+4	; 0x04
    1910:	88 23       	and	r24, r24
    1912:	11 f4       	brne	.+4      	; 0x1918 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1914:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1918:	0e 94 cb 2d 	call	0x5b96	; 0x5b96 <uxTaskResetEventItemValue>
    191c:	99 87       	std	Y+9, r25	; 0x09
    191e:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1920:	88 85       	ldd	r24, Y+8	; 0x08
    1922:	99 85       	ldd	r25, Y+9	; 0x09
    1924:	80 70       	andi	r24, 0x00	; 0
    1926:	92 70       	andi	r25, 0x02	; 2
    1928:	00 97       	sbiw	r24, 0x00	; 0
    192a:	41 f5       	brne	.+80     	; 0x197c <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    192c:	0f b6       	in	r0, 0x3f	; 63
    192e:	f8 94       	cli
    1930:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1932:	ea 85       	ldd	r30, Y+10	; 0x0a
    1934:	fb 85       	ldd	r31, Y+11	; 0x0b
    1936:	80 81       	ld	r24, Z
    1938:	91 81       	ldd	r25, Z+1	; 0x01
    193a:	99 87       	std	Y+9, r25	; 0x09
    193c:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    193e:	88 85       	ldd	r24, Y+8	; 0x08
    1940:	99 85       	ldd	r25, Y+9	; 0x09
    1942:	2e 85       	ldd	r18, Y+14	; 0x0e
    1944:	3f 85       	ldd	r19, Y+15	; 0x0f
    1946:	b9 01       	movw	r22, r18
    1948:	49 89       	ldd	r20, Y+17	; 0x11
    194a:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <prvTestWaitCondition>
    194e:	88 23       	and	r24, r24
    1950:	89 f0       	breq	.+34     	; 0x1974 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1952:	88 89       	ldd	r24, Y+16	; 0x10
    1954:	88 23       	and	r24, r24
    1956:	71 f0       	breq	.+28     	; 0x1974 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1958:	ea 85       	ldd	r30, Y+10	; 0x0a
    195a:	fb 85       	ldd	r31, Y+11	; 0x0b
    195c:	20 81       	ld	r18, Z
    195e:	31 81       	ldd	r19, Z+1	; 0x01
    1960:	8e 85       	ldd	r24, Y+14	; 0x0e
    1962:	9f 85       	ldd	r25, Y+15	; 0x0f
    1964:	80 95       	com	r24
    1966:	90 95       	com	r25
    1968:	82 23       	and	r24, r18
    196a:	93 23       	and	r25, r19
    196c:	ea 85       	ldd	r30, Y+10	; 0x0a
    196e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1970:	91 83       	std	Z+1, r25	; 0x01
    1972:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1978:	0f 90       	pop	r0
    197a:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    197c:	88 85       	ldd	r24, Y+8	; 0x08
    197e:	99 85       	ldd	r25, Y+9	; 0x09
    1980:	90 70       	andi	r25, 0x00	; 0
    1982:	99 87       	std	Y+9, r25	; 0x09
    1984:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1986:	88 85       	ldd	r24, Y+8	; 0x08
    1988:	99 85       	ldd	r25, Y+9	; 0x09
}
    198a:	63 96       	adiw	r28, 0x13	; 19
    198c:	0f b6       	in	r0, 0x3f	; 63
    198e:	f8 94       	cli
    1990:	de bf       	out	0x3e, r29	; 62
    1992:	0f be       	out	0x3f, r0	; 63
    1994:	cd bf       	out	0x3d, r28	; 61
    1996:	cf 91       	pop	r28
    1998:	df 91       	pop	r29
    199a:	1f 91       	pop	r17
    199c:	0f 91       	pop	r16
    199e:	08 95       	ret

000019a0 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    19a0:	df 93       	push	r29
    19a2:	cf 93       	push	r28
    19a4:	cd b7       	in	r28, 0x3d	; 61
    19a6:	de b7       	in	r29, 0x3e	; 62
    19a8:	28 97       	sbiw	r28, 0x08	; 8
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	de bf       	out	0x3e, r29	; 62
    19b0:	0f be       	out	0x3f, r0	; 63
    19b2:	cd bf       	out	0x3d, r28	; 61
    19b4:	9e 83       	std	Y+6, r25	; 0x06
    19b6:	8d 83       	std	Y+5, r24	; 0x05
    19b8:	78 87       	std	Y+8, r23	; 0x08
    19ba:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    19bc:	8d 81       	ldd	r24, Y+5	; 0x05
    19be:	9e 81       	ldd	r25, Y+6	; 0x06
    19c0:	9c 83       	std	Y+4, r25	; 0x04
    19c2:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    19c4:	0f b6       	in	r0, 0x3f	; 63
    19c6:	f8 94       	cli
    19c8:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    19ca:	eb 81       	ldd	r30, Y+3	; 0x03
    19cc:	fc 81       	ldd	r31, Y+4	; 0x04
    19ce:	80 81       	ld	r24, Z
    19d0:	91 81       	ldd	r25, Z+1	; 0x01
    19d2:	9a 83       	std	Y+2, r25	; 0x02
    19d4:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    19d6:	eb 81       	ldd	r30, Y+3	; 0x03
    19d8:	fc 81       	ldd	r31, Y+4	; 0x04
    19da:	20 81       	ld	r18, Z
    19dc:	31 81       	ldd	r19, Z+1	; 0x01
    19de:	8f 81       	ldd	r24, Y+7	; 0x07
    19e0:	98 85       	ldd	r25, Y+8	; 0x08
    19e2:	80 95       	com	r24
    19e4:	90 95       	com	r25
    19e6:	82 23       	and	r24, r18
    19e8:	93 23       	and	r25, r19
    19ea:	eb 81       	ldd	r30, Y+3	; 0x03
    19ec:	fc 81       	ldd	r31, Y+4	; 0x04
    19ee:	91 83       	std	Z+1, r25	; 0x01
    19f0:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    19f2:	0f 90       	pop	r0
    19f4:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    19f6:	89 81       	ldd	r24, Y+1	; 0x01
    19f8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19fa:	28 96       	adiw	r28, 0x08	; 8
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	f8 94       	cli
    1a00:	de bf       	out	0x3e, r29	; 62
    1a02:	0f be       	out	0x3f, r0	; 63
    1a04:	cd bf       	out	0x3d, r28	; 61
    1a06:	cf 91       	pop	r28
    1a08:	df 91       	pop	r29
    1a0a:	08 95       	ret

00001a0c <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1a0c:	df 93       	push	r29
    1a0e:	cf 93       	push	r28
    1a10:	cd b7       	in	r28, 0x3d	; 61
    1a12:	de b7       	in	r29, 0x3e	; 62
    1a14:	27 97       	sbiw	r28, 0x07	; 7
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	cd bf       	out	0x3d, r28	; 61
    1a20:	9f 83       	std	Y+7, r25	; 0x07
    1a22:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1a24:	8e 81       	ldd	r24, Y+6	; 0x06
    1a26:	9f 81       	ldd	r25, Y+7	; 0x07
    1a28:	9c 83       	std	Y+4, r25	; 0x04
    1a2a:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a2c:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1a2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a30:	fc 81       	ldd	r31, Y+4	; 0x04
    1a32:	80 81       	ld	r24, Z
    1a34:	91 81       	ldd	r25, Z+1	; 0x01
    1a36:	9a 83       	std	Y+2, r25	; 0x02
    1a38:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1a3a:	89 81       	ldd	r24, Y+1	; 0x01
    1a3c:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1a3e:	27 96       	adiw	r28, 0x07	; 7
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	f8 94       	cli
    1a44:	de bf       	out	0x3e, r29	; 62
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	cd bf       	out	0x3d, r28	; 61
    1a4a:	cf 91       	pop	r28
    1a4c:	df 91       	pop	r29
    1a4e:	08 95       	ret

00001a50 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1a50:	df 93       	push	r29
    1a52:	cf 93       	push	r28
    1a54:	cd b7       	in	r28, 0x3d	; 61
    1a56:	de b7       	in	r29, 0x3e	; 62
    1a58:	65 97       	sbiw	r28, 0x15	; 21
    1a5a:	0f b6       	in	r0, 0x3f	; 63
    1a5c:	f8 94       	cli
    1a5e:	de bf       	out	0x3e, r29	; 62
    1a60:	0f be       	out	0x3f, r0	; 63
    1a62:	cd bf       	out	0x3d, r28	; 61
    1a64:	9b 8b       	std	Y+19, r25	; 0x13
    1a66:	8a 8b       	std	Y+18, r24	; 0x12
    1a68:	7d 8b       	std	Y+21, r23	; 0x15
    1a6a:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1a6c:	19 86       	std	Y+9, r1	; 0x09
    1a6e:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1a70:	8a 89       	ldd	r24, Y+18	; 0x12
    1a72:	9b 89       	ldd	r25, Y+19	; 0x13
    1a74:	9b 83       	std	Y+3, r25	; 0x03
    1a76:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1a78:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a7e:	02 96       	adiw	r24, 0x02	; 2
    1a80:	9b 87       	std	Y+11, r25	; 0x0b
    1a82:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a88:	03 96       	adiw	r24, 0x03	; 3
    1a8a:	9d 87       	std	Y+13, r25	; 0x0d
    1a8c:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1a8e:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1a92:	ea 85       	ldd	r30, Y+10	; 0x0a
    1a94:	fb 85       	ldd	r31, Y+11	; 0x0b
    1a96:	85 81       	ldd	r24, Z+5	; 0x05
    1a98:	96 81       	ldd	r25, Z+6	; 0x06
    1a9a:	99 8b       	std	Y+17, r25	; 0x11
    1a9c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1a9e:	ea 81       	ldd	r30, Y+2	; 0x02
    1aa0:	fb 81       	ldd	r31, Y+3	; 0x03
    1aa2:	20 81       	ld	r18, Z
    1aa4:	31 81       	ldd	r19, Z+1	; 0x01
    1aa6:	8c 89       	ldd	r24, Y+20	; 0x14
    1aa8:	9d 89       	ldd	r25, Y+21	; 0x15
    1aaa:	82 2b       	or	r24, r18
    1aac:	93 2b       	or	r25, r19
    1aae:	ea 81       	ldd	r30, Y+2	; 0x02
    1ab0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ab2:	91 83       	std	Z+1, r25	; 0x01
    1ab4:	80 83       	st	Z, r24
    1ab6:	59 c0       	rjmp	.+178    	; 0x1b6a <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1ab8:	e8 89       	ldd	r30, Y+16	; 0x10
    1aba:	f9 89       	ldd	r31, Y+17	; 0x11
    1abc:	82 81       	ldd	r24, Z+2	; 0x02
    1abe:	93 81       	ldd	r25, Z+3	; 0x03
    1ac0:	9f 87       	std	Y+15, r25	; 0x0f
    1ac2:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1ac4:	e8 89       	ldd	r30, Y+16	; 0x10
    1ac6:	f9 89       	ldd	r31, Y+17	; 0x11
    1ac8:	80 81       	ld	r24, Z
    1aca:	91 81       	ldd	r25, Z+1	; 0x01
    1acc:	9f 83       	std	Y+7, r25	; 0x07
    1ace:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1ad0:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1ad2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ad4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ad6:	80 70       	andi	r24, 0x00	; 0
    1ad8:	9d 83       	std	Y+5, r25	; 0x05
    1ada:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1adc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ade:	9f 81       	ldd	r25, Y+7	; 0x07
    1ae0:	90 70       	andi	r25, 0x00	; 0
    1ae2:	9f 83       	std	Y+7, r25	; 0x07
    1ae4:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1ae6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ae8:	9d 81       	ldd	r25, Y+5	; 0x05
    1aea:	80 70       	andi	r24, 0x00	; 0
    1aec:	94 70       	andi	r25, 0x04	; 4
    1aee:	00 97       	sbiw	r24, 0x00	; 0
    1af0:	69 f4       	brne	.+26     	; 0x1b0c <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1af2:	ea 81       	ldd	r30, Y+2	; 0x02
    1af4:	fb 81       	ldd	r31, Y+3	; 0x03
    1af6:	20 81       	ld	r18, Z
    1af8:	31 81       	ldd	r19, Z+1	; 0x01
    1afa:	8e 81       	ldd	r24, Y+6	; 0x06
    1afc:	9f 81       	ldd	r25, Y+7	; 0x07
    1afe:	82 23       	and	r24, r18
    1b00:	93 23       	and	r25, r19
    1b02:	00 97       	sbiw	r24, 0x00	; 0
    1b04:	91 f0       	breq	.+36     	; 0x1b2a <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	89 83       	std	Y+1, r24	; 0x01
    1b0a:	0f c0       	rjmp	.+30     	; 0x1b2a <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1b0c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b0e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b10:	20 81       	ld	r18, Z
    1b12:	31 81       	ldd	r19, Z+1	; 0x01
    1b14:	8e 81       	ldd	r24, Y+6	; 0x06
    1b16:	9f 81       	ldd	r25, Y+7	; 0x07
    1b18:	28 23       	and	r18, r24
    1b1a:	39 23       	and	r19, r25
    1b1c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b1e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b20:	28 17       	cp	r18, r24
    1b22:	39 07       	cpc	r19, r25
    1b24:	11 f4       	brne	.+4      	; 0x1b2a <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1b2a:	89 81       	ldd	r24, Y+1	; 0x01
    1b2c:	88 23       	and	r24, r24
    1b2e:	c9 f0       	breq	.+50     	; 0x1b62 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1b30:	8c 81       	ldd	r24, Y+4	; 0x04
    1b32:	9d 81       	ldd	r25, Y+5	; 0x05
    1b34:	80 70       	andi	r24, 0x00	; 0
    1b36:	91 70       	andi	r25, 0x01	; 1
    1b38:	00 97       	sbiw	r24, 0x00	; 0
    1b3a:	41 f0       	breq	.+16     	; 0x1b4c <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1b3c:	88 85       	ldd	r24, Y+8	; 0x08
    1b3e:	99 85       	ldd	r25, Y+9	; 0x09
    1b40:	2e 81       	ldd	r18, Y+6	; 0x06
    1b42:	3f 81       	ldd	r19, Y+7	; 0x07
    1b44:	82 2b       	or	r24, r18
    1b46:	93 2b       	or	r25, r19
    1b48:	99 87       	std	Y+9, r25	; 0x09
    1b4a:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1b4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b50:	80 81       	ld	r24, Z
    1b52:	91 81       	ldd	r25, Z+1	; 0x01
    1b54:	9c 01       	movw	r18, r24
    1b56:	32 60       	ori	r19, 0x02	; 2
    1b58:	88 89       	ldd	r24, Y+16	; 0x10
    1b5a:	99 89       	ldd	r25, Y+17	; 0x11
    1b5c:	b9 01       	movw	r22, r18
    1b5e:	0e 94 4f 2b 	call	0x569e	; 0x569e <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1b62:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b64:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b66:	99 8b       	std	Y+17, r25	; 0x11
    1b68:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1b6a:	28 89       	ldd	r18, Y+16	; 0x10
    1b6c:	39 89       	ldd	r19, Y+17	; 0x11
    1b6e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b70:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b72:	28 17       	cp	r18, r24
    1b74:	39 07       	cpc	r19, r25
    1b76:	09 f0       	breq	.+2      	; 0x1b7a <xEventGroupSetBits+0x12a>
    1b78:	9f cf       	rjmp	.-194    	; 0x1ab8 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1b7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b7e:	20 81       	ld	r18, Z
    1b80:	31 81       	ldd	r19, Z+1	; 0x01
    1b82:	88 85       	ldd	r24, Y+8	; 0x08
    1b84:	99 85       	ldd	r25, Y+9	; 0x09
    1b86:	80 95       	com	r24
    1b88:	90 95       	com	r25
    1b8a:	82 23       	and	r24, r18
    1b8c:	93 23       	and	r25, r19
    1b8e:	ea 81       	ldd	r30, Y+2	; 0x02
    1b90:	fb 81       	ldd	r31, Y+3	; 0x03
    1b92:	91 83       	std	Z+1, r25	; 0x01
    1b94:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1b96:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1b9a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b9e:	80 81       	ld	r24, Z
    1ba0:	91 81       	ldd	r25, Z+1	; 0x01
}
    1ba2:	65 96       	adiw	r28, 0x15	; 21
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	cf 91       	pop	r28
    1bb0:	df 91       	pop	r29
    1bb2:	08 95       	ret

00001bb4 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1bb4:	df 93       	push	r29
    1bb6:	cf 93       	push	r28
    1bb8:	00 d0       	rcall	.+0      	; 0x1bba <vEventGroupDelete+0x6>
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <vEventGroupDelete+0x8>
    1bbc:	00 d0       	rcall	.+0      	; 0x1bbe <vEventGroupDelete+0xa>
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	9e 83       	std	Y+6, r25	; 0x06
    1bc4:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bca:	9c 83       	std	Y+4, r25	; 0x04
    1bcc:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1bce:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd2:	02 96       	adiw	r24, 0x02	; 2
    1bd4:	9a 83       	std	Y+2, r25	; 0x02
    1bd6:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1bd8:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    1bdc:	08 c0       	rjmp	.+16     	; 0x1bee <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1bde:	e9 81       	ldd	r30, Y+1	; 0x01
    1be0:	fa 81       	ldd	r31, Y+2	; 0x02
    1be2:	85 81       	ldd	r24, Z+5	; 0x05
    1be4:	96 81       	ldd	r25, Z+6	; 0x06
    1be6:	60 e0       	ldi	r22, 0x00	; 0
    1be8:	72 e0       	ldi	r23, 0x02	; 2
    1bea:	0e 94 4f 2b 	call	0x569e	; 0x569e <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1bee:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf2:	80 81       	ld	r24, Z
    1bf4:	88 23       	and	r24, r24
    1bf6:	99 f7       	brne	.-26     	; 0x1bde <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfc:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1c00:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
}
    1c04:	26 96       	adiw	r28, 0x06	; 6
    1c06:	0f b6       	in	r0, 0x3f	; 63
    1c08:	f8 94       	cli
    1c0a:	de bf       	out	0x3e, r29	; 62
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	cd bf       	out	0x3d, r28	; 61
    1c10:	cf 91       	pop	r28
    1c12:	df 91       	pop	r29
    1c14:	08 95       	ret

00001c16 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1c16:	df 93       	push	r29
    1c18:	cf 93       	push	r28
    1c1a:	00 d0       	rcall	.+0      	; 0x1c1c <vEventGroupSetBitsCallback+0x6>
    1c1c:	00 d0       	rcall	.+0      	; 0x1c1e <vEventGroupSetBitsCallback+0x8>
    1c1e:	00 d0       	rcall	.+0      	; 0x1c20 <vEventGroupSetBitsCallback+0xa>
    1c20:	cd b7       	in	r28, 0x3d	; 61
    1c22:	de b7       	in	r29, 0x3e	; 62
    1c24:	9a 83       	std	Y+2, r25	; 0x02
    1c26:	89 83       	std	Y+1, r24	; 0x01
    1c28:	4b 83       	std	Y+3, r20	; 0x03
    1c2a:	5c 83       	std	Y+4, r21	; 0x04
    1c2c:	6d 83       	std	Y+5, r22	; 0x05
    1c2e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1c30:	89 81       	ldd	r24, Y+1	; 0x01
    1c32:	9a 81       	ldd	r25, Y+2	; 0x02
    1c34:	2b 81       	ldd	r18, Y+3	; 0x03
    1c36:	3c 81       	ldd	r19, Y+4	; 0x04
    1c38:	b9 01       	movw	r22, r18
    1c3a:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <xEventGroupSetBits>
}
    1c3e:	26 96       	adiw	r28, 0x06	; 6
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	f8 94       	cli
    1c44:	de bf       	out	0x3e, r29	; 62
    1c46:	0f be       	out	0x3f, r0	; 63
    1c48:	cd bf       	out	0x3d, r28	; 61
    1c4a:	cf 91       	pop	r28
    1c4c:	df 91       	pop	r29
    1c4e:	08 95       	ret

00001c50 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1c50:	df 93       	push	r29
    1c52:	cf 93       	push	r28
    1c54:	00 d0       	rcall	.+0      	; 0x1c56 <vEventGroupClearBitsCallback+0x6>
    1c56:	00 d0       	rcall	.+0      	; 0x1c58 <vEventGroupClearBitsCallback+0x8>
    1c58:	00 d0       	rcall	.+0      	; 0x1c5a <vEventGroupClearBitsCallback+0xa>
    1c5a:	cd b7       	in	r28, 0x3d	; 61
    1c5c:	de b7       	in	r29, 0x3e	; 62
    1c5e:	9a 83       	std	Y+2, r25	; 0x02
    1c60:	89 83       	std	Y+1, r24	; 0x01
    1c62:	4b 83       	std	Y+3, r20	; 0x03
    1c64:	5c 83       	std	Y+4, r21	; 0x04
    1c66:	6d 83       	std	Y+5, r22	; 0x05
    1c68:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1c6a:	89 81       	ldd	r24, Y+1	; 0x01
    1c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6e:	2b 81       	ldd	r18, Y+3	; 0x03
    1c70:	3c 81       	ldd	r19, Y+4	; 0x04
    1c72:	b9 01       	movw	r22, r18
    1c74:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xEventGroupClearBits>
}
    1c78:	26 96       	adiw	r28, 0x06	; 6
    1c7a:	0f b6       	in	r0, 0x3f	; 63
    1c7c:	f8 94       	cli
    1c7e:	de bf       	out	0x3e, r29	; 62
    1c80:	0f be       	out	0x3f, r0	; 63
    1c82:	cd bf       	out	0x3d, r28	; 61
    1c84:	cf 91       	pop	r28
    1c86:	df 91       	pop	r29
    1c88:	08 95       	ret

00001c8a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1c8a:	df 93       	push	r29
    1c8c:	cf 93       	push	r28
    1c8e:	00 d0       	rcall	.+0      	; 0x1c90 <prvTestWaitCondition+0x6>
    1c90:	00 d0       	rcall	.+0      	; 0x1c92 <prvTestWaitCondition+0x8>
    1c92:	00 d0       	rcall	.+0      	; 0x1c94 <prvTestWaitCondition+0xa>
    1c94:	cd b7       	in	r28, 0x3d	; 61
    1c96:	de b7       	in	r29, 0x3e	; 62
    1c98:	9b 83       	std	Y+3, r25	; 0x03
    1c9a:	8a 83       	std	Y+2, r24	; 0x02
    1c9c:	7d 83       	std	Y+5, r23	; 0x05
    1c9e:	6c 83       	std	Y+4, r22	; 0x04
    1ca0:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1ca2:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1ca4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ca6:	88 23       	and	r24, r24
    1ca8:	59 f4       	brne	.+22     	; 0x1cc0 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1caa:	8a 81       	ldd	r24, Y+2	; 0x02
    1cac:	9b 81       	ldd	r25, Y+3	; 0x03
    1cae:	2c 81       	ldd	r18, Y+4	; 0x04
    1cb0:	3d 81       	ldd	r19, Y+5	; 0x05
    1cb2:	82 23       	and	r24, r18
    1cb4:	93 23       	and	r25, r19
    1cb6:	00 97       	sbiw	r24, 0x00	; 0
    1cb8:	81 f0       	breq	.+32     	; 0x1cda <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1cba:	81 e0       	ldi	r24, 0x01	; 1
    1cbc:	89 83       	std	Y+1, r24	; 0x01
    1cbe:	0d c0       	rjmp	.+26     	; 0x1cda <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1cc0:	2a 81       	ldd	r18, Y+2	; 0x02
    1cc2:	3b 81       	ldd	r19, Y+3	; 0x03
    1cc4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cc6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cc8:	28 23       	and	r18, r24
    1cca:	39 23       	and	r19, r25
    1ccc:	8c 81       	ldd	r24, Y+4	; 0x04
    1cce:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd0:	28 17       	cp	r18, r24
    1cd2:	39 07       	cpc	r19, r25
    1cd4:	11 f4       	brne	.+4      	; 0x1cda <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1cda:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cdc:	26 96       	adiw	r28, 0x06	; 6
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	de bf       	out	0x3e, r29	; 62
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	cd bf       	out	0x3d, r28	; 61
    1ce8:	cf 91       	pop	r28
    1cea:	df 91       	pop	r29
    1cec:	08 95       	ret

00001cee <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1cee:	df 93       	push	r29
    1cf0:	cf 93       	push	r28
    1cf2:	00 d0       	rcall	.+0      	; 0x1cf4 <pvPortMalloc+0x6>
    1cf4:	00 d0       	rcall	.+0      	; 0x1cf6 <pvPortMalloc+0x8>
    1cf6:	cd b7       	in	r28, 0x3d	; 61
    1cf8:	de b7       	in	r29, 0x3e	; 62
    1cfa:	9c 83       	std	Y+4, r25	; 0x04
    1cfc:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    1cfe:	1a 82       	std	Y+2, r1	; 0x02
    1d00:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
    1d02:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1d06:	80 91 a8 01 	lds	r24, 0x01A8
    1d0a:	90 91 a9 01 	lds	r25, 0x01A9
    1d0e:	00 97       	sbiw	r24, 0x00	; 0
    1d10:	31 f4       	brne	.+12     	; 0x1d1e <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1d12:	8a ea       	ldi	r24, 0xAA	; 170
    1d14:	91 e0       	ldi	r25, 0x01	; 1
    1d16:	90 93 a9 01 	sts	0x01A9, r25
    1d1a:	80 93 a8 01 	sts	0x01A8, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    1d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d20:	9c 81       	ldd	r25, Y+4	; 0x04
    1d22:	00 97       	sbiw	r24, 0x00	; 0
    1d24:	99 f1       	breq	.+102    	; 0x1d8c <pvPortMalloc+0x9e>
    1d26:	80 91 a6 01 	lds	r24, 0x01A6
    1d2a:	90 91 a7 01 	lds	r25, 0x01A7
    1d2e:	2b 81       	ldd	r18, Y+3	; 0x03
    1d30:	3c 81       	ldd	r19, Y+4	; 0x04
    1d32:	82 0f       	add	r24, r18
    1d34:	93 1f       	adc	r25, r19
    1d36:	25 e0       	ldi	r18, 0x05	; 5
    1d38:	8b 3d       	cpi	r24, 0xDB	; 219
    1d3a:	92 07       	cpc	r25, r18
    1d3c:	38 f5       	brcc	.+78     	; 0x1d8c <pvPortMalloc+0x9e>
    1d3e:	20 91 a6 01 	lds	r18, 0x01A6
    1d42:	30 91 a7 01 	lds	r19, 0x01A7
    1d46:	8b 81       	ldd	r24, Y+3	; 0x03
    1d48:	9c 81       	ldd	r25, Y+4	; 0x04
    1d4a:	28 0f       	add	r18, r24
    1d4c:	39 1f       	adc	r19, r25
    1d4e:	80 91 a6 01 	lds	r24, 0x01A6
    1d52:	90 91 a7 01 	lds	r25, 0x01A7
    1d56:	82 17       	cp	r24, r18
    1d58:	93 07       	cpc	r25, r19
    1d5a:	c0 f4       	brcc	.+48     	; 0x1d8c <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    1d5c:	20 91 a8 01 	lds	r18, 0x01A8
    1d60:	30 91 a9 01 	lds	r19, 0x01A9
    1d64:	80 91 a6 01 	lds	r24, 0x01A6
    1d68:	90 91 a7 01 	lds	r25, 0x01A7
    1d6c:	82 0f       	add	r24, r18
    1d6e:	93 1f       	adc	r25, r19
    1d70:	9a 83       	std	Y+2, r25	; 0x02
    1d72:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    1d74:	20 91 a6 01 	lds	r18, 0x01A6
    1d78:	30 91 a7 01 	lds	r19, 0x01A7
    1d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d80:	82 0f       	add	r24, r18
    1d82:	93 1f       	adc	r25, r19
    1d84:	90 93 a7 01 	sts	0x01A7, r25
    1d88:	80 93 a6 01 	sts	0x01A6, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1d8c:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
    1d90:	89 81       	ldd	r24, Y+1	; 0x01
    1d92:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1d94:	0f 90       	pop	r0
    1d96:	0f 90       	pop	r0
    1d98:	0f 90       	pop	r0
    1d9a:	0f 90       	pop	r0
    1d9c:	cf 91       	pop	r28
    1d9e:	df 91       	pop	r29
    1da0:	08 95       	ret

00001da2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    1da2:	df 93       	push	r29
    1da4:	cf 93       	push	r28
    1da6:	00 d0       	rcall	.+0      	; 0x1da8 <vPortFree+0x6>
    1da8:	cd b7       	in	r28, 0x3d	; 61
    1daa:	de b7       	in	r29, 0x3e	; 62
    1dac:	9a 83       	std	Y+2, r25	; 0x02
    1dae:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	cf 91       	pop	r28
    1db6:	df 91       	pop	r29
    1db8:	08 95       	ret

00001dba <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1dba:	df 93       	push	r29
    1dbc:	cf 93       	push	r28
    1dbe:	cd b7       	in	r28, 0x3d	; 61
    1dc0:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    1dc2:	10 92 a7 01 	sts	0x01A7, r1
    1dc6:	10 92 a6 01 	sts	0x01A6, r1
}
    1dca:	cf 91       	pop	r28
    1dcc:	df 91       	pop	r29
    1dce:	08 95       	ret

00001dd0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1dd8:	20 91 a6 01 	lds	r18, 0x01A6
    1ddc:	30 91 a7 01 	lds	r19, 0x01A7
    1de0:	8b ed       	ldi	r24, 0xDB	; 219
    1de2:	95 e0       	ldi	r25, 0x05	; 5
    1de4:	82 1b       	sub	r24, r18
    1de6:	93 0b       	sbc	r25, r19
}
    1de8:	cf 91       	pop	r28
    1dea:	df 91       	pop	r29
    1dec:	08 95       	ret

00001dee <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1dee:	df 93       	push	r29
    1df0:	cf 93       	push	r28
    1df2:	00 d0       	rcall	.+0      	; 0x1df4 <vListInitialise+0x6>
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	9a 83       	std	Y+2, r25	; 0x02
    1dfa:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1dfc:	89 81       	ldd	r24, Y+1	; 0x01
    1dfe:	9a 81       	ldd	r25, Y+2	; 0x02
    1e00:	03 96       	adiw	r24, 0x03	; 3
    1e02:	e9 81       	ldd	r30, Y+1	; 0x01
    1e04:	fa 81       	ldd	r31, Y+2	; 0x02
    1e06:	92 83       	std	Z+2, r25	; 0x02
    1e08:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0e:	8f ef       	ldi	r24, 0xFF	; 255
    1e10:	9f ef       	ldi	r25, 0xFF	; 255
    1e12:	94 83       	std	Z+4, r25	; 0x04
    1e14:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e16:	89 81       	ldd	r24, Y+1	; 0x01
    1e18:	9a 81       	ldd	r25, Y+2	; 0x02
    1e1a:	03 96       	adiw	r24, 0x03	; 3
    1e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e20:	96 83       	std	Z+6, r25	; 0x06
    1e22:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e24:	89 81       	ldd	r24, Y+1	; 0x01
    1e26:	9a 81       	ldd	r25, Y+2	; 0x02
    1e28:	03 96       	adiw	r24, 0x03	; 3
    1e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2e:	90 87       	std	Z+8, r25	; 0x08
    1e30:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1e32:	e9 81       	ldd	r30, Y+1	; 0x01
    1e34:	fa 81       	ldd	r31, Y+2	; 0x02
    1e36:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1e38:	0f 90       	pop	r0
    1e3a:	0f 90       	pop	r0
    1e3c:	cf 91       	pop	r28
    1e3e:	df 91       	pop	r29
    1e40:	08 95       	ret

00001e42 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1e42:	df 93       	push	r29
    1e44:	cf 93       	push	r28
    1e46:	00 d0       	rcall	.+0      	; 0x1e48 <vListInitialiseItem+0x6>
    1e48:	cd b7       	in	r28, 0x3d	; 61
    1e4a:	de b7       	in	r29, 0x3e	; 62
    1e4c:	9a 83       	std	Y+2, r25	; 0x02
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1e50:	e9 81       	ldd	r30, Y+1	; 0x01
    1e52:	fa 81       	ldd	r31, Y+2	; 0x02
    1e54:	11 86       	std	Z+9, r1	; 0x09
    1e56:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1e58:	0f 90       	pop	r0
    1e5a:	0f 90       	pop	r0
    1e5c:	cf 91       	pop	r28
    1e5e:	df 91       	pop	r29
    1e60:	08 95       	ret

00001e62 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1e62:	df 93       	push	r29
    1e64:	cf 93       	push	r28
    1e66:	00 d0       	rcall	.+0      	; 0x1e68 <vListInsertEnd+0x6>
    1e68:	00 d0       	rcall	.+0      	; 0x1e6a <vListInsertEnd+0x8>
    1e6a:	00 d0       	rcall	.+0      	; 0x1e6c <vListInsertEnd+0xa>
    1e6c:	cd b7       	in	r28, 0x3d	; 61
    1e6e:	de b7       	in	r29, 0x3e	; 62
    1e70:	9c 83       	std	Y+4, r25	; 0x04
    1e72:	8b 83       	std	Y+3, r24	; 0x03
    1e74:	7e 83       	std	Y+6, r23	; 0x06
    1e76:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1e78:	eb 81       	ldd	r30, Y+3	; 0x03
    1e7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7c:	81 81       	ldd	r24, Z+1	; 0x01
    1e7e:	92 81       	ldd	r25, Z+2	; 0x02
    1e80:	9a 83       	std	Y+2, r25	; 0x02
    1e82:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1e84:	ed 81       	ldd	r30, Y+5	; 0x05
    1e86:	fe 81       	ldd	r31, Y+6	; 0x06
    1e88:	89 81       	ldd	r24, Y+1	; 0x01
    1e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e8c:	93 83       	std	Z+3, r25	; 0x03
    1e8e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1e90:	e9 81       	ldd	r30, Y+1	; 0x01
    1e92:	fa 81       	ldd	r31, Y+2	; 0x02
    1e94:	84 81       	ldd	r24, Z+4	; 0x04
    1e96:	95 81       	ldd	r25, Z+5	; 0x05
    1e98:	ed 81       	ldd	r30, Y+5	; 0x05
    1e9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1e9c:	95 83       	std	Z+5, r25	; 0x05
    1e9e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea4:	04 80       	ldd	r0, Z+4	; 0x04
    1ea6:	f5 81       	ldd	r31, Z+5	; 0x05
    1ea8:	e0 2d       	mov	r30, r0
    1eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    1eac:	9e 81       	ldd	r25, Y+6	; 0x06
    1eae:	93 83       	std	Z+3, r25	; 0x03
    1eb0:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1eb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1eba:	95 83       	std	Z+5, r25	; 0x05
    1ebc:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1ebe:	ed 81       	ldd	r30, Y+5	; 0x05
    1ec0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec6:	91 87       	std	Z+9, r25	; 0x09
    1ec8:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1eca:	eb 81       	ldd	r30, Y+3	; 0x03
    1ecc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ece:	80 81       	ld	r24, Z
    1ed0:	8f 5f       	subi	r24, 0xFF	; 255
    1ed2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed6:	80 83       	st	Z, r24
}
    1ed8:	26 96       	adiw	r28, 0x06	; 6
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	de bf       	out	0x3e, r29	; 62
    1ee0:	0f be       	out	0x3f, r0	; 63
    1ee2:	cd bf       	out	0x3d, r28	; 61
    1ee4:	cf 91       	pop	r28
    1ee6:	df 91       	pop	r29
    1ee8:	08 95       	ret

00001eea <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1eea:	df 93       	push	r29
    1eec:	cf 93       	push	r28
    1eee:	cd b7       	in	r28, 0x3d	; 61
    1ef0:	de b7       	in	r29, 0x3e	; 62
    1ef2:	28 97       	sbiw	r28, 0x08	; 8
    1ef4:	0f b6       	in	r0, 0x3f	; 63
    1ef6:	f8 94       	cli
    1ef8:	de bf       	out	0x3e, r29	; 62
    1efa:	0f be       	out	0x3f, r0	; 63
    1efc:	cd bf       	out	0x3d, r28	; 61
    1efe:	9e 83       	std	Y+6, r25	; 0x06
    1f00:	8d 83       	std	Y+5, r24	; 0x05
    1f02:	78 87       	std	Y+8, r23	; 0x08
    1f04:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1f06:	ef 81       	ldd	r30, Y+7	; 0x07
    1f08:	f8 85       	ldd	r31, Y+8	; 0x08
    1f0a:	80 81       	ld	r24, Z
    1f0c:	91 81       	ldd	r25, Z+1	; 0x01
    1f0e:	9a 83       	std	Y+2, r25	; 0x02
    1f10:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1f12:	89 81       	ldd	r24, Y+1	; 0x01
    1f14:	9a 81       	ldd	r25, Y+2	; 0x02
    1f16:	2f ef       	ldi	r18, 0xFF	; 255
    1f18:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1a:	92 07       	cpc	r25, r18
    1f1c:	39 f4       	brne	.+14     	; 0x1f2c <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1f1e:	ed 81       	ldd	r30, Y+5	; 0x05
    1f20:	fe 81       	ldd	r31, Y+6	; 0x06
    1f22:	87 81       	ldd	r24, Z+7	; 0x07
    1f24:	90 85       	ldd	r25, Z+8	; 0x08
    1f26:	9c 83       	std	Y+4, r25	; 0x04
    1f28:	8b 83       	std	Y+3, r24	; 0x03
    1f2a:	18 c0       	rjmp	.+48     	; 0x1f5c <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1f2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f30:	03 96       	adiw	r24, 0x03	; 3
    1f32:	9c 83       	std	Y+4, r25	; 0x04
    1f34:	8b 83       	std	Y+3, r24	; 0x03
    1f36:	06 c0       	rjmp	.+12     	; 0x1f44 <vListInsert+0x5a>
    1f38:	eb 81       	ldd	r30, Y+3	; 0x03
    1f3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3c:	82 81       	ldd	r24, Z+2	; 0x02
    1f3e:	93 81       	ldd	r25, Z+3	; 0x03
    1f40:	9c 83       	std	Y+4, r25	; 0x04
    1f42:	8b 83       	std	Y+3, r24	; 0x03
    1f44:	eb 81       	ldd	r30, Y+3	; 0x03
    1f46:	fc 81       	ldd	r31, Y+4	; 0x04
    1f48:	02 80       	ldd	r0, Z+2	; 0x02
    1f4a:	f3 81       	ldd	r31, Z+3	; 0x03
    1f4c:	e0 2d       	mov	r30, r0
    1f4e:	20 81       	ld	r18, Z
    1f50:	31 81       	ldd	r19, Z+1	; 0x01
    1f52:	89 81       	ldd	r24, Y+1	; 0x01
    1f54:	9a 81       	ldd	r25, Y+2	; 0x02
    1f56:	82 17       	cp	r24, r18
    1f58:	93 07       	cpc	r25, r19
    1f5a:	70 f7       	brcc	.-36     	; 0x1f38 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1f5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f60:	82 81       	ldd	r24, Z+2	; 0x02
    1f62:	93 81       	ldd	r25, Z+3	; 0x03
    1f64:	ef 81       	ldd	r30, Y+7	; 0x07
    1f66:	f8 85       	ldd	r31, Y+8	; 0x08
    1f68:	93 83       	std	Z+3, r25	; 0x03
    1f6a:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1f6c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f6e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f70:	02 80       	ldd	r0, Z+2	; 0x02
    1f72:	f3 81       	ldd	r31, Z+3	; 0x03
    1f74:	e0 2d       	mov	r30, r0
    1f76:	8f 81       	ldd	r24, Y+7	; 0x07
    1f78:	98 85       	ldd	r25, Y+8	; 0x08
    1f7a:	95 83       	std	Z+5, r25	; 0x05
    1f7c:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1f7e:	ef 81       	ldd	r30, Y+7	; 0x07
    1f80:	f8 85       	ldd	r31, Y+8	; 0x08
    1f82:	8b 81       	ldd	r24, Y+3	; 0x03
    1f84:	9c 81       	ldd	r25, Y+4	; 0x04
    1f86:	95 83       	std	Z+5, r25	; 0x05
    1f88:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f90:	98 85       	ldd	r25, Y+8	; 0x08
    1f92:	93 83       	std	Z+3, r25	; 0x03
    1f94:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1f96:	ef 81       	ldd	r30, Y+7	; 0x07
    1f98:	f8 85       	ldd	r31, Y+8	; 0x08
    1f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f9e:	91 87       	std	Z+9, r25	; 0x09
    1fa0:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1fa2:	ed 81       	ldd	r30, Y+5	; 0x05
    1fa4:	fe 81       	ldd	r31, Y+6	; 0x06
    1fa6:	80 81       	ld	r24, Z
    1fa8:	8f 5f       	subi	r24, 0xFF	; 255
    1faa:	ed 81       	ldd	r30, Y+5	; 0x05
    1fac:	fe 81       	ldd	r31, Y+6	; 0x06
    1fae:	80 83       	st	Z, r24
}
    1fb0:	28 96       	adiw	r28, 0x08	; 8
    1fb2:	0f b6       	in	r0, 0x3f	; 63
    1fb4:	f8 94       	cli
    1fb6:	de bf       	out	0x3e, r29	; 62
    1fb8:	0f be       	out	0x3f, r0	; 63
    1fba:	cd bf       	out	0x3d, r28	; 61
    1fbc:	cf 91       	pop	r28
    1fbe:	df 91       	pop	r29
    1fc0:	08 95       	ret

00001fc2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1fc2:	df 93       	push	r29
    1fc4:	cf 93       	push	r28
    1fc6:	00 d0       	rcall	.+0      	; 0x1fc8 <uxListRemove+0x6>
    1fc8:	00 d0       	rcall	.+0      	; 0x1fca <uxListRemove+0x8>
    1fca:	cd b7       	in	r28, 0x3d	; 61
    1fcc:	de b7       	in	r29, 0x3e	; 62
    1fce:	9c 83       	std	Y+4, r25	; 0x04
    1fd0:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd6:	80 85       	ldd	r24, Z+8	; 0x08
    1fd8:	91 85       	ldd	r25, Z+9	; 0x09
    1fda:	9a 83       	std	Y+2, r25	; 0x02
    1fdc:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1fde:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe2:	a2 81       	ldd	r26, Z+2	; 0x02
    1fe4:	b3 81       	ldd	r27, Z+3	; 0x03
    1fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fea:	84 81       	ldd	r24, Z+4	; 0x04
    1fec:	95 81       	ldd	r25, Z+5	; 0x05
    1fee:	15 96       	adiw	r26, 0x05	; 5
    1ff0:	9c 93       	st	X, r25
    1ff2:	8e 93       	st	-X, r24
    1ff4:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffa:	a4 81       	ldd	r26, Z+4	; 0x04
    1ffc:	b5 81       	ldd	r27, Z+5	; 0x05
    1ffe:	eb 81       	ldd	r30, Y+3	; 0x03
    2000:	fc 81       	ldd	r31, Y+4	; 0x04
    2002:	82 81       	ldd	r24, Z+2	; 0x02
    2004:	93 81       	ldd	r25, Z+3	; 0x03
    2006:	13 96       	adiw	r26, 0x03	; 3
    2008:	9c 93       	st	X, r25
    200a:	8e 93       	st	-X, r24
    200c:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    200e:	e9 81       	ldd	r30, Y+1	; 0x01
    2010:	fa 81       	ldd	r31, Y+2	; 0x02
    2012:	21 81       	ldd	r18, Z+1	; 0x01
    2014:	32 81       	ldd	r19, Z+2	; 0x02
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	9c 81       	ldd	r25, Y+4	; 0x04
    201a:	28 17       	cp	r18, r24
    201c:	39 07       	cpc	r19, r25
    201e:	41 f4       	brne	.+16     	; 0x2030 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2020:	eb 81       	ldd	r30, Y+3	; 0x03
    2022:	fc 81       	ldd	r31, Y+4	; 0x04
    2024:	84 81       	ldd	r24, Z+4	; 0x04
    2026:	95 81       	ldd	r25, Z+5	; 0x05
    2028:	e9 81       	ldd	r30, Y+1	; 0x01
    202a:	fa 81       	ldd	r31, Y+2	; 0x02
    202c:	92 83       	std	Z+2, r25	; 0x02
    202e:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2030:	eb 81       	ldd	r30, Y+3	; 0x03
    2032:	fc 81       	ldd	r31, Y+4	; 0x04
    2034:	11 86       	std	Z+9, r1	; 0x09
    2036:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2038:	e9 81       	ldd	r30, Y+1	; 0x01
    203a:	fa 81       	ldd	r31, Y+2	; 0x02
    203c:	80 81       	ld	r24, Z
    203e:	81 50       	subi	r24, 0x01	; 1
    2040:	e9 81       	ldd	r30, Y+1	; 0x01
    2042:	fa 81       	ldd	r31, Y+2	; 0x02
    2044:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	80 81       	ld	r24, Z
}
    204c:	0f 90       	pop	r0
    204e:	0f 90       	pop	r0
    2050:	0f 90       	pop	r0
    2052:	0f 90       	pop	r0
    2054:	cf 91       	pop	r28
    2056:	df 91       	pop	r29
    2058:	08 95       	ret

0000205a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    205a:	df 93       	push	r29
    205c:	cf 93       	push	r28
    205e:	cd b7       	in	r28, 0x3d	; 61
    2060:	de b7       	in	r29, 0x3e	; 62
    2062:	28 97       	sbiw	r28, 0x08	; 8
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	de bf       	out	0x3e, r29	; 62
    206a:	0f be       	out	0x3f, r0	; 63
    206c:	cd bf       	out	0x3d, r28	; 61
    206e:	9c 83       	std	Y+4, r25	; 0x04
    2070:	8b 83       	std	Y+3, r24	; 0x03
    2072:	7e 83       	std	Y+6, r23	; 0x06
    2074:	6d 83       	std	Y+5, r22	; 0x05
    2076:	58 87       	std	Y+8, r21	; 0x08
    2078:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    207a:	eb 81       	ldd	r30, Y+3	; 0x03
    207c:	fc 81       	ldd	r31, Y+4	; 0x04
    207e:	81 e1       	ldi	r24, 0x11	; 17
    2080:	80 83       	st	Z, r24
	pxTopOfStack--;
    2082:	8b 81       	ldd	r24, Y+3	; 0x03
    2084:	9c 81       	ldd	r25, Y+4	; 0x04
    2086:	01 97       	sbiw	r24, 0x01	; 1
    2088:	9c 83       	std	Y+4, r25	; 0x04
    208a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    208c:	eb 81       	ldd	r30, Y+3	; 0x03
    208e:	fc 81       	ldd	r31, Y+4	; 0x04
    2090:	82 e2       	ldi	r24, 0x22	; 34
    2092:	80 83       	st	Z, r24
	pxTopOfStack--;
    2094:	8b 81       	ldd	r24, Y+3	; 0x03
    2096:	9c 81       	ldd	r25, Y+4	; 0x04
    2098:	01 97       	sbiw	r24, 0x01	; 1
    209a:	9c 83       	std	Y+4, r25	; 0x04
    209c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    209e:	eb 81       	ldd	r30, Y+3	; 0x03
    20a0:	fc 81       	ldd	r31, Y+4	; 0x04
    20a2:	83 e3       	ldi	r24, 0x33	; 51
    20a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    20a6:	8b 81       	ldd	r24, Y+3	; 0x03
    20a8:	9c 81       	ldd	r25, Y+4	; 0x04
    20aa:	01 97       	sbiw	r24, 0x01	; 1
    20ac:	9c 83       	std	Y+4, r25	; 0x04
    20ae:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    20b0:	8d 81       	ldd	r24, Y+5	; 0x05
    20b2:	9e 81       	ldd	r25, Y+6	; 0x06
    20b4:	9a 83       	std	Y+2, r25	; 0x02
    20b6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	eb 81       	ldd	r30, Y+3	; 0x03
    20bc:	fc 81       	ldd	r31, Y+4	; 0x04
    20be:	80 83       	st	Z, r24
	pxTopOfStack--;
    20c0:	8b 81       	ldd	r24, Y+3	; 0x03
    20c2:	9c 81       	ldd	r25, Y+4	; 0x04
    20c4:	01 97       	sbiw	r24, 0x01	; 1
    20c6:	9c 83       	std	Y+4, r25	; 0x04
    20c8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    20ca:	89 81       	ldd	r24, Y+1	; 0x01
    20cc:	9a 81       	ldd	r25, Y+2	; 0x02
    20ce:	89 2f       	mov	r24, r25
    20d0:	99 27       	eor	r25, r25
    20d2:	9a 83       	std	Y+2, r25	; 0x02
    20d4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20d6:	89 81       	ldd	r24, Y+1	; 0x01
    20d8:	eb 81       	ldd	r30, Y+3	; 0x03
    20da:	fc 81       	ldd	r31, Y+4	; 0x04
    20dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    20de:	8b 81       	ldd	r24, Y+3	; 0x03
    20e0:	9c 81       	ldd	r25, Y+4	; 0x04
    20e2:	01 97       	sbiw	r24, 0x01	; 1
    20e4:	9c 83       	std	Y+4, r25	; 0x04
    20e6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	10 82       	st	Z, r1
	pxTopOfStack--;
    20ee:	8b 81       	ldd	r24, Y+3	; 0x03
    20f0:	9c 81       	ldd	r25, Y+4	; 0x04
    20f2:	01 97       	sbiw	r24, 0x01	; 1
    20f4:	9c 83       	std	Y+4, r25	; 0x04
    20f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20f8:	eb 81       	ldd	r30, Y+3	; 0x03
    20fa:	fc 81       	ldd	r31, Y+4	; 0x04
    20fc:	80 e8       	ldi	r24, 0x80	; 128
    20fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2100:	8b 81       	ldd	r24, Y+3	; 0x03
    2102:	9c 81       	ldd	r25, Y+4	; 0x04
    2104:	01 97       	sbiw	r24, 0x01	; 1
    2106:	9c 83       	std	Y+4, r25	; 0x04
    2108:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    210a:	eb 81       	ldd	r30, Y+3	; 0x03
    210c:	fc 81       	ldd	r31, Y+4	; 0x04
    210e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2110:	8b 81       	ldd	r24, Y+3	; 0x03
    2112:	9c 81       	ldd	r25, Y+4	; 0x04
    2114:	01 97       	sbiw	r24, 0x01	; 1
    2116:	9c 83       	std	Y+4, r25	; 0x04
    2118:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    211a:	eb 81       	ldd	r30, Y+3	; 0x03
    211c:	fc 81       	ldd	r31, Y+4	; 0x04
    211e:	82 e0       	ldi	r24, 0x02	; 2
    2120:	80 83       	st	Z, r24
	pxTopOfStack--;
    2122:	8b 81       	ldd	r24, Y+3	; 0x03
    2124:	9c 81       	ldd	r25, Y+4	; 0x04
    2126:	01 97       	sbiw	r24, 0x01	; 1
    2128:	9c 83       	std	Y+4, r25	; 0x04
    212a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    212c:	eb 81       	ldd	r30, Y+3	; 0x03
    212e:	fc 81       	ldd	r31, Y+4	; 0x04
    2130:	83 e0       	ldi	r24, 0x03	; 3
    2132:	80 83       	st	Z, r24
	pxTopOfStack--;
    2134:	8b 81       	ldd	r24, Y+3	; 0x03
    2136:	9c 81       	ldd	r25, Y+4	; 0x04
    2138:	01 97       	sbiw	r24, 0x01	; 1
    213a:	9c 83       	std	Y+4, r25	; 0x04
    213c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    213e:	eb 81       	ldd	r30, Y+3	; 0x03
    2140:	fc 81       	ldd	r31, Y+4	; 0x04
    2142:	84 e0       	ldi	r24, 0x04	; 4
    2144:	80 83       	st	Z, r24
	pxTopOfStack--;
    2146:	8b 81       	ldd	r24, Y+3	; 0x03
    2148:	9c 81       	ldd	r25, Y+4	; 0x04
    214a:	01 97       	sbiw	r24, 0x01	; 1
    214c:	9c 83       	std	Y+4, r25	; 0x04
    214e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2150:	eb 81       	ldd	r30, Y+3	; 0x03
    2152:	fc 81       	ldd	r31, Y+4	; 0x04
    2154:	85 e0       	ldi	r24, 0x05	; 5
    2156:	80 83       	st	Z, r24
	pxTopOfStack--;
    2158:	8b 81       	ldd	r24, Y+3	; 0x03
    215a:	9c 81       	ldd	r25, Y+4	; 0x04
    215c:	01 97       	sbiw	r24, 0x01	; 1
    215e:	9c 83       	std	Y+4, r25	; 0x04
    2160:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2162:	eb 81       	ldd	r30, Y+3	; 0x03
    2164:	fc 81       	ldd	r31, Y+4	; 0x04
    2166:	86 e0       	ldi	r24, 0x06	; 6
    2168:	80 83       	st	Z, r24
	pxTopOfStack--;
    216a:	8b 81       	ldd	r24, Y+3	; 0x03
    216c:	9c 81       	ldd	r25, Y+4	; 0x04
    216e:	01 97       	sbiw	r24, 0x01	; 1
    2170:	9c 83       	std	Y+4, r25	; 0x04
    2172:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2174:	eb 81       	ldd	r30, Y+3	; 0x03
    2176:	fc 81       	ldd	r31, Y+4	; 0x04
    2178:	87 e0       	ldi	r24, 0x07	; 7
    217a:	80 83       	st	Z, r24
	pxTopOfStack--;
    217c:	8b 81       	ldd	r24, Y+3	; 0x03
    217e:	9c 81       	ldd	r25, Y+4	; 0x04
    2180:	01 97       	sbiw	r24, 0x01	; 1
    2182:	9c 83       	std	Y+4, r25	; 0x04
    2184:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2186:	eb 81       	ldd	r30, Y+3	; 0x03
    2188:	fc 81       	ldd	r31, Y+4	; 0x04
    218a:	88 e0       	ldi	r24, 0x08	; 8
    218c:	80 83       	st	Z, r24
	pxTopOfStack--;
    218e:	8b 81       	ldd	r24, Y+3	; 0x03
    2190:	9c 81       	ldd	r25, Y+4	; 0x04
    2192:	01 97       	sbiw	r24, 0x01	; 1
    2194:	9c 83       	std	Y+4, r25	; 0x04
    2196:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2198:	eb 81       	ldd	r30, Y+3	; 0x03
    219a:	fc 81       	ldd	r31, Y+4	; 0x04
    219c:	89 e0       	ldi	r24, 0x09	; 9
    219e:	80 83       	st	Z, r24
	pxTopOfStack--;
    21a0:	8b 81       	ldd	r24, Y+3	; 0x03
    21a2:	9c 81       	ldd	r25, Y+4	; 0x04
    21a4:	01 97       	sbiw	r24, 0x01	; 1
    21a6:	9c 83       	std	Y+4, r25	; 0x04
    21a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    21aa:	eb 81       	ldd	r30, Y+3	; 0x03
    21ac:	fc 81       	ldd	r31, Y+4	; 0x04
    21ae:	80 e1       	ldi	r24, 0x10	; 16
    21b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    21b2:	8b 81       	ldd	r24, Y+3	; 0x03
    21b4:	9c 81       	ldd	r25, Y+4	; 0x04
    21b6:	01 97       	sbiw	r24, 0x01	; 1
    21b8:	9c 83       	std	Y+4, r25	; 0x04
    21ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    21bc:	eb 81       	ldd	r30, Y+3	; 0x03
    21be:	fc 81       	ldd	r31, Y+4	; 0x04
    21c0:	81 e1       	ldi	r24, 0x11	; 17
    21c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    21c4:	8b 81       	ldd	r24, Y+3	; 0x03
    21c6:	9c 81       	ldd	r25, Y+4	; 0x04
    21c8:	01 97       	sbiw	r24, 0x01	; 1
    21ca:	9c 83       	std	Y+4, r25	; 0x04
    21cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    21ce:	eb 81       	ldd	r30, Y+3	; 0x03
    21d0:	fc 81       	ldd	r31, Y+4	; 0x04
    21d2:	82 e1       	ldi	r24, 0x12	; 18
    21d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    21d6:	8b 81       	ldd	r24, Y+3	; 0x03
    21d8:	9c 81       	ldd	r25, Y+4	; 0x04
    21da:	01 97       	sbiw	r24, 0x01	; 1
    21dc:	9c 83       	std	Y+4, r25	; 0x04
    21de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	83 e1       	ldi	r24, 0x13	; 19
    21e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    21e8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ea:	9c 81       	ldd	r25, Y+4	; 0x04
    21ec:	01 97       	sbiw	r24, 0x01	; 1
    21ee:	9c 83       	std	Y+4, r25	; 0x04
    21f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    21f2:	eb 81       	ldd	r30, Y+3	; 0x03
    21f4:	fc 81       	ldd	r31, Y+4	; 0x04
    21f6:	84 e1       	ldi	r24, 0x14	; 20
    21f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    21fa:	8b 81       	ldd	r24, Y+3	; 0x03
    21fc:	9c 81       	ldd	r25, Y+4	; 0x04
    21fe:	01 97       	sbiw	r24, 0x01	; 1
    2200:	9c 83       	std	Y+4, r25	; 0x04
    2202:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2204:	eb 81       	ldd	r30, Y+3	; 0x03
    2206:	fc 81       	ldd	r31, Y+4	; 0x04
    2208:	85 e1       	ldi	r24, 0x15	; 21
    220a:	80 83       	st	Z, r24
	pxTopOfStack--;
    220c:	8b 81       	ldd	r24, Y+3	; 0x03
    220e:	9c 81       	ldd	r25, Y+4	; 0x04
    2210:	01 97       	sbiw	r24, 0x01	; 1
    2212:	9c 83       	std	Y+4, r25	; 0x04
    2214:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2216:	eb 81       	ldd	r30, Y+3	; 0x03
    2218:	fc 81       	ldd	r31, Y+4	; 0x04
    221a:	86 e1       	ldi	r24, 0x16	; 22
    221c:	80 83       	st	Z, r24
	pxTopOfStack--;
    221e:	8b 81       	ldd	r24, Y+3	; 0x03
    2220:	9c 81       	ldd	r25, Y+4	; 0x04
    2222:	01 97       	sbiw	r24, 0x01	; 1
    2224:	9c 83       	std	Y+4, r25	; 0x04
    2226:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2228:	eb 81       	ldd	r30, Y+3	; 0x03
    222a:	fc 81       	ldd	r31, Y+4	; 0x04
    222c:	87 e1       	ldi	r24, 0x17	; 23
    222e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	9c 81       	ldd	r25, Y+4	; 0x04
    2234:	01 97       	sbiw	r24, 0x01	; 1
    2236:	9c 83       	std	Y+4, r25	; 0x04
    2238:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	88 e1       	ldi	r24, 0x18	; 24
    2240:	80 83       	st	Z, r24
	pxTopOfStack--;
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	01 97       	sbiw	r24, 0x01	; 1
    2248:	9c 83       	std	Y+4, r25	; 0x04
    224a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    224c:	eb 81       	ldd	r30, Y+3	; 0x03
    224e:	fc 81       	ldd	r31, Y+4	; 0x04
    2250:	89 e1       	ldi	r24, 0x19	; 25
    2252:	80 83       	st	Z, r24
	pxTopOfStack--;
    2254:	8b 81       	ldd	r24, Y+3	; 0x03
    2256:	9c 81       	ldd	r25, Y+4	; 0x04
    2258:	01 97       	sbiw	r24, 0x01	; 1
    225a:	9c 83       	std	Y+4, r25	; 0x04
    225c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    225e:	eb 81       	ldd	r30, Y+3	; 0x03
    2260:	fc 81       	ldd	r31, Y+4	; 0x04
    2262:	80 e2       	ldi	r24, 0x20	; 32
    2264:	80 83       	st	Z, r24
	pxTopOfStack--;
    2266:	8b 81       	ldd	r24, Y+3	; 0x03
    2268:	9c 81       	ldd	r25, Y+4	; 0x04
    226a:	01 97       	sbiw	r24, 0x01	; 1
    226c:	9c 83       	std	Y+4, r25	; 0x04
    226e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2270:	eb 81       	ldd	r30, Y+3	; 0x03
    2272:	fc 81       	ldd	r31, Y+4	; 0x04
    2274:	81 e2       	ldi	r24, 0x21	; 33
    2276:	80 83       	st	Z, r24
	pxTopOfStack--;
    2278:	8b 81       	ldd	r24, Y+3	; 0x03
    227a:	9c 81       	ldd	r25, Y+4	; 0x04
    227c:	01 97       	sbiw	r24, 0x01	; 1
    227e:	9c 83       	std	Y+4, r25	; 0x04
    2280:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2282:	eb 81       	ldd	r30, Y+3	; 0x03
    2284:	fc 81       	ldd	r31, Y+4	; 0x04
    2286:	82 e2       	ldi	r24, 0x22	; 34
    2288:	80 83       	st	Z, r24
	pxTopOfStack--;
    228a:	8b 81       	ldd	r24, Y+3	; 0x03
    228c:	9c 81       	ldd	r25, Y+4	; 0x04
    228e:	01 97       	sbiw	r24, 0x01	; 1
    2290:	9c 83       	std	Y+4, r25	; 0x04
    2292:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2294:	eb 81       	ldd	r30, Y+3	; 0x03
    2296:	fc 81       	ldd	r31, Y+4	; 0x04
    2298:	83 e2       	ldi	r24, 0x23	; 35
    229a:	80 83       	st	Z, r24
	pxTopOfStack--;
    229c:	8b 81       	ldd	r24, Y+3	; 0x03
    229e:	9c 81       	ldd	r25, Y+4	; 0x04
    22a0:	01 97       	sbiw	r24, 0x01	; 1
    22a2:	9c 83       	std	Y+4, r25	; 0x04
    22a4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    22a6:	8f 81       	ldd	r24, Y+7	; 0x07
    22a8:	98 85       	ldd	r25, Y+8	; 0x08
    22aa:	9a 83       	std	Y+2, r25	; 0x02
    22ac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	eb 81       	ldd	r30, Y+3	; 0x03
    22b2:	fc 81       	ldd	r31, Y+4	; 0x04
    22b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    22b6:	8b 81       	ldd	r24, Y+3	; 0x03
    22b8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ba:	01 97       	sbiw	r24, 0x01	; 1
    22bc:	9c 83       	std	Y+4, r25	; 0x04
    22be:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    22c0:	89 81       	ldd	r24, Y+1	; 0x01
    22c2:	9a 81       	ldd	r25, Y+2	; 0x02
    22c4:	89 2f       	mov	r24, r25
    22c6:	99 27       	eor	r25, r25
    22c8:	9a 83       	std	Y+2, r25	; 0x02
    22ca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22cc:	89 81       	ldd	r24, Y+1	; 0x01
    22ce:	eb 81       	ldd	r30, Y+3	; 0x03
    22d0:	fc 81       	ldd	r31, Y+4	; 0x04
    22d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    22d4:	8b 81       	ldd	r24, Y+3	; 0x03
    22d6:	9c 81       	ldd	r25, Y+4	; 0x04
    22d8:	01 97       	sbiw	r24, 0x01	; 1
    22da:	9c 83       	std	Y+4, r25	; 0x04
    22dc:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    22de:	eb 81       	ldd	r30, Y+3	; 0x03
    22e0:	fc 81       	ldd	r31, Y+4	; 0x04
    22e2:	86 e2       	ldi	r24, 0x26	; 38
    22e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    22e6:	8b 81       	ldd	r24, Y+3	; 0x03
    22e8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ea:	01 97       	sbiw	r24, 0x01	; 1
    22ec:	9c 83       	std	Y+4, r25	; 0x04
    22ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    22f0:	eb 81       	ldd	r30, Y+3	; 0x03
    22f2:	fc 81       	ldd	r31, Y+4	; 0x04
    22f4:	87 e2       	ldi	r24, 0x27	; 39
    22f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    22f8:	8b 81       	ldd	r24, Y+3	; 0x03
    22fa:	9c 81       	ldd	r25, Y+4	; 0x04
    22fc:	01 97       	sbiw	r24, 0x01	; 1
    22fe:	9c 83       	std	Y+4, r25	; 0x04
    2300:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2302:	eb 81       	ldd	r30, Y+3	; 0x03
    2304:	fc 81       	ldd	r31, Y+4	; 0x04
    2306:	88 e2       	ldi	r24, 0x28	; 40
    2308:	80 83       	st	Z, r24
	pxTopOfStack--;
    230a:	8b 81       	ldd	r24, Y+3	; 0x03
    230c:	9c 81       	ldd	r25, Y+4	; 0x04
    230e:	01 97       	sbiw	r24, 0x01	; 1
    2310:	9c 83       	std	Y+4, r25	; 0x04
    2312:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2314:	eb 81       	ldd	r30, Y+3	; 0x03
    2316:	fc 81       	ldd	r31, Y+4	; 0x04
    2318:	89 e2       	ldi	r24, 0x29	; 41
    231a:	80 83       	st	Z, r24
	pxTopOfStack--;
    231c:	8b 81       	ldd	r24, Y+3	; 0x03
    231e:	9c 81       	ldd	r25, Y+4	; 0x04
    2320:	01 97       	sbiw	r24, 0x01	; 1
    2322:	9c 83       	std	Y+4, r25	; 0x04
    2324:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2326:	eb 81       	ldd	r30, Y+3	; 0x03
    2328:	fc 81       	ldd	r31, Y+4	; 0x04
    232a:	80 e3       	ldi	r24, 0x30	; 48
    232c:	80 83       	st	Z, r24
	pxTopOfStack--;
    232e:	8b 81       	ldd	r24, Y+3	; 0x03
    2330:	9c 81       	ldd	r25, Y+4	; 0x04
    2332:	01 97       	sbiw	r24, 0x01	; 1
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2338:	eb 81       	ldd	r30, Y+3	; 0x03
    233a:	fc 81       	ldd	r31, Y+4	; 0x04
    233c:	81 e3       	ldi	r24, 0x31	; 49
    233e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2340:	8b 81       	ldd	r24, Y+3	; 0x03
    2342:	9c 81       	ldd	r25, Y+4	; 0x04
    2344:	01 97       	sbiw	r24, 0x01	; 1
    2346:	9c 83       	std	Y+4, r25	; 0x04
    2348:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    234a:	8b 81       	ldd	r24, Y+3	; 0x03
    234c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    234e:	28 96       	adiw	r28, 0x08	; 8
    2350:	0f b6       	in	r0, 0x3f	; 63
    2352:	f8 94       	cli
    2354:	de bf       	out	0x3e, r29	; 62
    2356:	0f be       	out	0x3f, r0	; 63
    2358:	cd bf       	out	0x3d, r28	; 61
    235a:	cf 91       	pop	r28
    235c:	df 91       	pop	r29
    235e:	08 95       	ret

00002360 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2360:	df 93       	push	r29
    2362:	cf 93       	push	r28
    2364:	cd b7       	in	r28, 0x3d	; 61
    2366:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2368:	0e 94 a2 12 	call	0x2544	; 0x2544 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    236c:	a0 91 86 07 	lds	r26, 0x0786
    2370:	b0 91 87 07 	lds	r27, 0x0787
    2374:	cd 91       	ld	r28, X+
    2376:	cd bf       	out	0x3d, r28	; 61
    2378:	dd 91       	ld	r29, X+
    237a:	de bf       	out	0x3e, r29	; 62
    237c:	ff 91       	pop	r31
    237e:	ef 91       	pop	r30
    2380:	df 91       	pop	r29
    2382:	cf 91       	pop	r28
    2384:	bf 91       	pop	r27
    2386:	af 91       	pop	r26
    2388:	9f 91       	pop	r25
    238a:	8f 91       	pop	r24
    238c:	7f 91       	pop	r23
    238e:	6f 91       	pop	r22
    2390:	5f 91       	pop	r21
    2392:	4f 91       	pop	r20
    2394:	3f 91       	pop	r19
    2396:	2f 91       	pop	r18
    2398:	1f 91       	pop	r17
    239a:	0f 91       	pop	r16
    239c:	ff 90       	pop	r15
    239e:	ef 90       	pop	r14
    23a0:	df 90       	pop	r13
    23a2:	cf 90       	pop	r12
    23a4:	bf 90       	pop	r11
    23a6:	af 90       	pop	r10
    23a8:	9f 90       	pop	r9
    23aa:	8f 90       	pop	r8
    23ac:	7f 90       	pop	r7
    23ae:	6f 90       	pop	r6
    23b0:	5f 90       	pop	r5
    23b2:	4f 90       	pop	r4
    23b4:	3f 90       	pop	r3
    23b6:	2f 90       	pop	r2
    23b8:	1f 90       	pop	r1
    23ba:	0f 90       	pop	r0
    23bc:	0f be       	out	0x3f, r0	; 63
    23be:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    23c0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    23c2:	81 e0       	ldi	r24, 0x01	; 1
}
    23c4:	cf 91       	pop	r28
    23c6:	df 91       	pop	r29
    23c8:	08 95       	ret

000023ca <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    23ca:	df 93       	push	r29
    23cc:	cf 93       	push	r28
    23ce:	cd b7       	in	r28, 0x3d	; 61
    23d0:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    23d2:	cf 91       	pop	r28
    23d4:	df 91       	pop	r29
    23d6:	08 95       	ret

000023d8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    23d8:	0f 92       	push	r0
    23da:	0f b6       	in	r0, 0x3f	; 63
    23dc:	f8 94       	cli
    23de:	0f 92       	push	r0
    23e0:	1f 92       	push	r1
    23e2:	11 24       	eor	r1, r1
    23e4:	2f 92       	push	r2
    23e6:	3f 92       	push	r3
    23e8:	4f 92       	push	r4
    23ea:	5f 92       	push	r5
    23ec:	6f 92       	push	r6
    23ee:	7f 92       	push	r7
    23f0:	8f 92       	push	r8
    23f2:	9f 92       	push	r9
    23f4:	af 92       	push	r10
    23f6:	bf 92       	push	r11
    23f8:	cf 92       	push	r12
    23fa:	df 92       	push	r13
    23fc:	ef 92       	push	r14
    23fe:	ff 92       	push	r15
    2400:	0f 93       	push	r16
    2402:	1f 93       	push	r17
    2404:	2f 93       	push	r18
    2406:	3f 93       	push	r19
    2408:	4f 93       	push	r20
    240a:	5f 93       	push	r21
    240c:	6f 93       	push	r22
    240e:	7f 93       	push	r23
    2410:	8f 93       	push	r24
    2412:	9f 93       	push	r25
    2414:	af 93       	push	r26
    2416:	bf 93       	push	r27
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	ef 93       	push	r30
    241e:	ff 93       	push	r31
    2420:	a0 91 86 07 	lds	r26, 0x0786
    2424:	b0 91 87 07 	lds	r27, 0x0787
    2428:	0d b6       	in	r0, 0x3d	; 61
    242a:	0d 92       	st	X+, r0
    242c:	0e b6       	in	r0, 0x3e	; 62
    242e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2430:	0e 94 17 29 	call	0x522e	; 0x522e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2434:	a0 91 86 07 	lds	r26, 0x0786
    2438:	b0 91 87 07 	lds	r27, 0x0787
    243c:	cd 91       	ld	r28, X+
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	dd 91       	ld	r29, X+
    2442:	de bf       	out	0x3e, r29	; 62
    2444:	ff 91       	pop	r31
    2446:	ef 91       	pop	r30
    2448:	df 91       	pop	r29
    244a:	cf 91       	pop	r28
    244c:	bf 91       	pop	r27
    244e:	af 91       	pop	r26
    2450:	9f 91       	pop	r25
    2452:	8f 91       	pop	r24
    2454:	7f 91       	pop	r23
    2456:	6f 91       	pop	r22
    2458:	5f 91       	pop	r21
    245a:	4f 91       	pop	r20
    245c:	3f 91       	pop	r19
    245e:	2f 91       	pop	r18
    2460:	1f 91       	pop	r17
    2462:	0f 91       	pop	r16
    2464:	ff 90       	pop	r15
    2466:	ef 90       	pop	r14
    2468:	df 90       	pop	r13
    246a:	cf 90       	pop	r12
    246c:	bf 90       	pop	r11
    246e:	af 90       	pop	r10
    2470:	9f 90       	pop	r9
    2472:	8f 90       	pop	r8
    2474:	7f 90       	pop	r7
    2476:	6f 90       	pop	r6
    2478:	5f 90       	pop	r5
    247a:	4f 90       	pop	r4
    247c:	3f 90       	pop	r3
    247e:	2f 90       	pop	r2
    2480:	1f 90       	pop	r1
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63
    2486:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2488:	08 95       	ret

0000248a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    248a:	0f 92       	push	r0
    248c:	0f b6       	in	r0, 0x3f	; 63
    248e:	f8 94       	cli
    2490:	0f 92       	push	r0
    2492:	1f 92       	push	r1
    2494:	11 24       	eor	r1, r1
    2496:	2f 92       	push	r2
    2498:	3f 92       	push	r3
    249a:	4f 92       	push	r4
    249c:	5f 92       	push	r5
    249e:	6f 92       	push	r6
    24a0:	7f 92       	push	r7
    24a2:	8f 92       	push	r8
    24a4:	9f 92       	push	r9
    24a6:	af 92       	push	r10
    24a8:	bf 92       	push	r11
    24aa:	cf 92       	push	r12
    24ac:	df 92       	push	r13
    24ae:	ef 92       	push	r14
    24b0:	ff 92       	push	r15
    24b2:	0f 93       	push	r16
    24b4:	1f 93       	push	r17
    24b6:	2f 93       	push	r18
    24b8:	3f 93       	push	r19
    24ba:	4f 93       	push	r20
    24bc:	5f 93       	push	r21
    24be:	6f 93       	push	r22
    24c0:	7f 93       	push	r23
    24c2:	8f 93       	push	r24
    24c4:	9f 93       	push	r25
    24c6:	af 93       	push	r26
    24c8:	bf 93       	push	r27
    24ca:	cf 93       	push	r28
    24cc:	df 93       	push	r29
    24ce:	ef 93       	push	r30
    24d0:	ff 93       	push	r31
    24d2:	a0 91 86 07 	lds	r26, 0x0786
    24d6:	b0 91 87 07 	lds	r27, 0x0787
    24da:	0d b6       	in	r0, 0x3d	; 61
    24dc:	0d 92       	st	X+, r0
    24de:	0e b6       	in	r0, 0x3e	; 62
    24e0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    24e2:	0e 94 80 27 	call	0x4f00	; 0x4f00 <xTaskIncrementTick>
    24e6:	88 23       	and	r24, r24
    24e8:	11 f0       	breq	.+4      	; 0x24ee <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    24ea:	0e 94 17 29 	call	0x522e	; 0x522e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    24ee:	a0 91 86 07 	lds	r26, 0x0786
    24f2:	b0 91 87 07 	lds	r27, 0x0787
    24f6:	cd 91       	ld	r28, X+
    24f8:	cd bf       	out	0x3d, r28	; 61
    24fa:	dd 91       	ld	r29, X+
    24fc:	de bf       	out	0x3e, r29	; 62
    24fe:	ff 91       	pop	r31
    2500:	ef 91       	pop	r30
    2502:	df 91       	pop	r29
    2504:	cf 91       	pop	r28
    2506:	bf 91       	pop	r27
    2508:	af 91       	pop	r26
    250a:	9f 91       	pop	r25
    250c:	8f 91       	pop	r24
    250e:	7f 91       	pop	r23
    2510:	6f 91       	pop	r22
    2512:	5f 91       	pop	r21
    2514:	4f 91       	pop	r20
    2516:	3f 91       	pop	r19
    2518:	2f 91       	pop	r18
    251a:	1f 91       	pop	r17
    251c:	0f 91       	pop	r16
    251e:	ff 90       	pop	r15
    2520:	ef 90       	pop	r14
    2522:	df 90       	pop	r13
    2524:	cf 90       	pop	r12
    2526:	bf 90       	pop	r11
    2528:	af 90       	pop	r10
    252a:	9f 90       	pop	r9
    252c:	8f 90       	pop	r8
    252e:	7f 90       	pop	r7
    2530:	6f 90       	pop	r6
    2532:	5f 90       	pop	r5
    2534:	4f 90       	pop	r4
    2536:	3f 90       	pop	r3
    2538:	2f 90       	pop	r2
    253a:	1f 90       	pop	r1
    253c:	0f 90       	pop	r0
    253e:	0f be       	out	0x3f, r0	; 63
    2540:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2542:	08 95       	ret

00002544 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2544:	df 93       	push	r29
    2546:	cf 93       	push	r28
    2548:	00 d0       	rcall	.+0      	; 0x254a <prvSetupTimerInterrupt+0x6>
    254a:	00 d0       	rcall	.+0      	; 0x254c <prvSetupTimerInterrupt+0x8>
    254c:	00 d0       	rcall	.+0      	; 0x254e <prvSetupTimerInterrupt+0xa>
    254e:	cd b7       	in	r28, 0x3d	; 61
    2550:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2552:	80 e4       	ldi	r24, 0x40	; 64
    2554:	9f e1       	ldi	r25, 0x1F	; 31
    2556:	a0 e0       	ldi	r26, 0x00	; 0
    2558:	b0 e0       	ldi	r27, 0x00	; 0
    255a:	8b 83       	std	Y+3, r24	; 0x03
    255c:	9c 83       	std	Y+4, r25	; 0x04
    255e:	ad 83       	std	Y+5, r26	; 0x05
    2560:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2562:	8b 81       	ldd	r24, Y+3	; 0x03
    2564:	9c 81       	ldd	r25, Y+4	; 0x04
    2566:	ad 81       	ldd	r26, Y+5	; 0x05
    2568:	be 81       	ldd	r27, Y+6	; 0x06
    256a:	68 94       	set
    256c:	15 f8       	bld	r1, 5
    256e:	b6 95       	lsr	r27
    2570:	a7 95       	ror	r26
    2572:	97 95       	ror	r25
    2574:	87 95       	ror	r24
    2576:	16 94       	lsr	r1
    2578:	d1 f7       	brne	.-12     	; 0x256e <prvSetupTimerInterrupt+0x2a>
    257a:	8b 83       	std	Y+3, r24	; 0x03
    257c:	9c 83       	std	Y+4, r25	; 0x04
    257e:	ad 83       	std	Y+5, r26	; 0x05
    2580:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2582:	8b 81       	ldd	r24, Y+3	; 0x03
    2584:	9c 81       	ldd	r25, Y+4	; 0x04
    2586:	ad 81       	ldd	r26, Y+5	; 0x05
    2588:	be 81       	ldd	r27, Y+6	; 0x06
    258a:	01 97       	sbiw	r24, 0x01	; 1
    258c:	a1 09       	sbc	r26, r1
    258e:	b1 09       	sbc	r27, r1
    2590:	8b 83       	std	Y+3, r24	; 0x03
    2592:	9c 83       	std	Y+4, r25	; 0x04
    2594:	ad 83       	std	Y+5, r26	; 0x05
    2596:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2598:	8b 81       	ldd	r24, Y+3	; 0x03
    259a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    259c:	8b 81       	ldd	r24, Y+3	; 0x03
    259e:	9c 81       	ldd	r25, Y+4	; 0x04
    25a0:	ad 81       	ldd	r26, Y+5	; 0x05
    25a2:	be 81       	ldd	r27, Y+6	; 0x06
    25a4:	89 2f       	mov	r24, r25
    25a6:	9a 2f       	mov	r25, r26
    25a8:	ab 2f       	mov	r26, r27
    25aa:	bb 27       	eor	r27, r27
    25ac:	8b 83       	std	Y+3, r24	; 0x03
    25ae:	9c 83       	std	Y+4, r25	; 0x04
    25b0:	ad 83       	std	Y+5, r26	; 0x05
    25b2:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    25b4:	8b 81       	ldd	r24, Y+3	; 0x03
    25b6:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    25b8:	eb e4       	ldi	r30, 0x4B	; 75
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	8a 81       	ldd	r24, Y+2	; 0x02
    25be:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    25c0:	ea e4       	ldi	r30, 0x4A	; 74
    25c2:	f0 e0       	ldi	r31, 0x00	; 0
    25c4:	89 81       	ldd	r24, Y+1	; 0x01
    25c6:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    25c8:	8b e0       	ldi	r24, 0x0B	; 11
    25ca:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    25cc:	ee e4       	ldi	r30, 0x4E	; 78
    25ce:	f0 e0       	ldi	r31, 0x00	; 0
    25d0:	89 81       	ldd	r24, Y+1	; 0x01
    25d2:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    25d4:	e9 e5       	ldi	r30, 0x59	; 89
    25d6:	f0 e0       	ldi	r31, 0x00	; 0
    25d8:	80 81       	ld	r24, Z
    25da:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    25dc:	89 81       	ldd	r24, Y+1	; 0x01
    25de:	80 61       	ori	r24, 0x10	; 16
    25e0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    25e2:	e9 e5       	ldi	r30, 0x59	; 89
    25e4:	f0 e0       	ldi	r31, 0x00	; 0
    25e6:	89 81       	ldd	r24, Y+1	; 0x01
    25e8:	80 83       	st	Z, r24
}
    25ea:	26 96       	adiw	r28, 0x06	; 6
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    25fc:	0e 94 45 12 	call	0x248a	; 0x248a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2600:	18 95       	reti

00002602 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    2602:	df 93       	push	r29
    2604:	cf 93       	push	r28
    2606:	00 d0       	rcall	.+0      	; 0x2608 <xQueueGenericReset+0x6>
    2608:	00 d0       	rcall	.+0      	; 0x260a <xQueueGenericReset+0x8>
    260a:	00 d0       	rcall	.+0      	; 0x260c <xQueueGenericReset+0xa>
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
    2610:	9d 83       	std	Y+5, r25	; 0x05
    2612:	8c 83       	std	Y+4, r24	; 0x04
    2614:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    261a:	8c 81       	ldd	r24, Y+4	; 0x04
    261c:	9d 81       	ldd	r25, Y+5	; 0x05
    261e:	9a 83       	std	Y+2, r25	; 0x02
    2620:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    2622:	89 81       	ldd	r24, Y+1	; 0x01
    2624:	9a 81       	ldd	r25, Y+2	; 0x02
    2626:	00 97       	sbiw	r24, 0x00	; 0
    2628:	09 f4       	brne	.+2      	; 0x262c <xQueueGenericReset+0x2a>
    262a:	8b c0       	rjmp	.+278    	; 0x2742 <xQueueGenericReset+0x140>
    262c:	e9 81       	ldd	r30, Y+1	; 0x01
    262e:	fa 81       	ldd	r31, Y+2	; 0x02
    2630:	83 8d       	ldd	r24, Z+27	; 0x1b
    2632:	88 23       	and	r24, r24
    2634:	09 f4       	brne	.+2      	; 0x2638 <xQueueGenericReset+0x36>
    2636:	85 c0       	rjmp	.+266    	; 0x2742 <xQueueGenericReset+0x140>
    2638:	e9 81       	ldd	r30, Y+1	; 0x01
    263a:	fa 81       	ldd	r31, Y+2	; 0x02
    263c:	83 8d       	ldd	r24, Z+27	; 0x1b
    263e:	28 2f       	mov	r18, r24
    2640:	30 e0       	ldi	r19, 0x00	; 0
    2642:	8f ef       	ldi	r24, 0xFF	; 255
    2644:	9f e7       	ldi	r25, 0x7F	; 127
    2646:	b9 01       	movw	r22, r18
    2648:	0e 94 69 42 	call	0x84d2	; 0x84d2 <__udivmodhi4>
    264c:	cb 01       	movw	r24, r22
    264e:	9c 01       	movw	r18, r24
    2650:	e9 81       	ldd	r30, Y+1	; 0x01
    2652:	fa 81       	ldd	r31, Y+2	; 0x02
    2654:	84 8d       	ldd	r24, Z+28	; 0x1c
    2656:	88 2f       	mov	r24, r24
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	28 17       	cp	r18, r24
    265c:	39 07       	cpc	r19, r25
    265e:	08 f4       	brcc	.+2      	; 0x2662 <xQueueGenericReset+0x60>
    2660:	70 c0       	rjmp	.+224    	; 0x2742 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2668:	e9 81       	ldd	r30, Y+1	; 0x01
    266a:	fa 81       	ldd	r31, Y+2	; 0x02
    266c:	40 81       	ld	r20, Z
    266e:	51 81       	ldd	r21, Z+1	; 0x01
    2670:	e9 81       	ldd	r30, Y+1	; 0x01
    2672:	fa 81       	ldd	r31, Y+2	; 0x02
    2674:	83 8d       	ldd	r24, Z+27	; 0x1b
    2676:	28 2f       	mov	r18, r24
    2678:	30 e0       	ldi	r19, 0x00	; 0
    267a:	e9 81       	ldd	r30, Y+1	; 0x01
    267c:	fa 81       	ldd	r31, Y+2	; 0x02
    267e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2680:	88 2f       	mov	r24, r24
    2682:	90 e0       	ldi	r25, 0x00	; 0
    2684:	bc 01       	movw	r22, r24
    2686:	26 9f       	mul	r18, r22
    2688:	c0 01       	movw	r24, r0
    268a:	27 9f       	mul	r18, r23
    268c:	90 0d       	add	r25, r0
    268e:	36 9f       	mul	r19, r22
    2690:	90 0d       	add	r25, r0
    2692:	11 24       	eor	r1, r1
    2694:	84 0f       	add	r24, r20
    2696:	95 1f       	adc	r25, r21
    2698:	e9 81       	ldd	r30, Y+1	; 0x01
    269a:	fa 81       	ldd	r31, Y+2	; 0x02
    269c:	95 83       	std	Z+5, r25	; 0x05
    269e:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    26a0:	e9 81       	ldd	r30, Y+1	; 0x01
    26a2:	fa 81       	ldd	r31, Y+2	; 0x02
    26a4:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    26a6:	e9 81       	ldd	r30, Y+1	; 0x01
    26a8:	fa 81       	ldd	r31, Y+2	; 0x02
    26aa:	80 81       	ld	r24, Z
    26ac:	91 81       	ldd	r25, Z+1	; 0x01
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	93 83       	std	Z+3, r25	; 0x03
    26b4:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    26b6:	e9 81       	ldd	r30, Y+1	; 0x01
    26b8:	fa 81       	ldd	r31, Y+2	; 0x02
    26ba:	40 81       	ld	r20, Z
    26bc:	51 81       	ldd	r21, Z+1	; 0x01
    26be:	e9 81       	ldd	r30, Y+1	; 0x01
    26c0:	fa 81       	ldd	r31, Y+2	; 0x02
    26c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    26c4:	88 2f       	mov	r24, r24
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	9c 01       	movw	r18, r24
    26ca:	21 50       	subi	r18, 0x01	; 1
    26cc:	30 40       	sbci	r19, 0x00	; 0
    26ce:	e9 81       	ldd	r30, Y+1	; 0x01
    26d0:	fa 81       	ldd	r31, Y+2	; 0x02
    26d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    26d4:	88 2f       	mov	r24, r24
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	bc 01       	movw	r22, r24
    26da:	26 9f       	mul	r18, r22
    26dc:	c0 01       	movw	r24, r0
    26de:	27 9f       	mul	r18, r23
    26e0:	90 0d       	add	r25, r0
    26e2:	36 9f       	mul	r19, r22
    26e4:	90 0d       	add	r25, r0
    26e6:	11 24       	eor	r1, r1
    26e8:	84 0f       	add	r24, r20
    26ea:	95 1f       	adc	r25, r21
    26ec:	e9 81       	ldd	r30, Y+1	; 0x01
    26ee:	fa 81       	ldd	r31, Y+2	; 0x02
    26f0:	97 83       	std	Z+7, r25	; 0x07
    26f2:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    26f4:	e9 81       	ldd	r30, Y+1	; 0x01
    26f6:	fa 81       	ldd	r31, Y+2	; 0x02
    26f8:	8f ef       	ldi	r24, 0xFF	; 255
    26fa:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    26fc:	e9 81       	ldd	r30, Y+1	; 0x01
    26fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2700:	8f ef       	ldi	r24, 0xFF	; 255
    2702:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    2704:	8e 81       	ldd	r24, Y+6	; 0x06
    2706:	88 23       	and	r24, r24
    2708:	79 f4       	brne	.+30     	; 0x2728 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    270a:	e9 81       	ldd	r30, Y+1	; 0x01
    270c:	fa 81       	ldd	r31, Y+2	; 0x02
    270e:	80 85       	ldd	r24, Z+8	; 0x08
    2710:	88 23       	and	r24, r24
    2712:	a1 f0       	breq	.+40     	; 0x273c <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2714:	89 81       	ldd	r24, Y+1	; 0x01
    2716:	9a 81       	ldd	r25, Y+2	; 0x02
    2718:	08 96       	adiw	r24, 0x08	; 8
    271a:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    271e:	88 23       	and	r24, r24
    2720:	69 f0       	breq	.+26     	; 0x273c <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2722:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    2726:	0a c0       	rjmp	.+20     	; 0x273c <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	9a 81       	ldd	r25, Y+2	; 0x02
    272c:	08 96       	adiw	r24, 0x08	; 8
    272e:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	9a 81       	ldd	r25, Y+2	; 0x02
    2736:	41 96       	adiw	r24, 0x11	; 17
    2738:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    273c:	0f 90       	pop	r0
    273e:	0f be       	out	0x3f, r0	; 63
    2740:	01 c0       	rjmp	.+2      	; 0x2744 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    2742:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2744:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2746:	26 96       	adiw	r28, 0x06	; 6
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	cf 91       	pop	r28
    2754:	df 91       	pop	r29
    2756:	08 95       	ret

00002758 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    2758:	0f 93       	push	r16
    275a:	1f 93       	push	r17
    275c:	df 93       	push	r29
    275e:	cf 93       	push	r28
    2760:	cd b7       	in	r28, 0x3d	; 61
    2762:	de b7       	in	r29, 0x3e	; 62
    2764:	29 97       	sbiw	r28, 0x09	; 9
    2766:	0f b6       	in	r0, 0x3f	; 63
    2768:	f8 94       	cli
    276a:	de bf       	out	0x3e, r29	; 62
    276c:	0f be       	out	0x3f, r0	; 63
    276e:	cd bf       	out	0x3d, r28	; 61
    2770:	8f 83       	std	Y+7, r24	; 0x07
    2772:	68 87       	std	Y+8, r22	; 0x08
    2774:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    2776:	1e 82       	std	Y+6, r1	; 0x06
    2778:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    277a:	8f 81       	ldd	r24, Y+7	; 0x07
    277c:	88 23       	and	r24, r24
    277e:	09 f4       	brne	.+2      	; 0x2782 <xQueueGenericCreate+0x2a>
    2780:	52 c0       	rjmp	.+164    	; 0x2826 <xQueueGenericCreate+0xce>
    2782:	8f 81       	ldd	r24, Y+7	; 0x07
    2784:	28 2f       	mov	r18, r24
    2786:	30 e0       	ldi	r19, 0x00	; 0
    2788:	8f ef       	ldi	r24, 0xFF	; 255
    278a:	9f e7       	ldi	r25, 0x7F	; 127
    278c:	b9 01       	movw	r22, r18
    278e:	0e 94 69 42 	call	0x84d2	; 0x84d2 <__udivmodhi4>
    2792:	cb 01       	movw	r24, r22
    2794:	9c 01       	movw	r18, r24
    2796:	88 85       	ldd	r24, Y+8	; 0x08
    2798:	88 2f       	mov	r24, r24
    279a:	90 e0       	ldi	r25, 0x00	; 0
    279c:	28 17       	cp	r18, r24
    279e:	39 07       	cpc	r19, r25
    27a0:	08 f4       	brcc	.+2      	; 0x27a4 <xQueueGenericCreate+0x4c>
    27a2:	41 c0       	rjmp	.+130    	; 0x2826 <xQueueGenericCreate+0xce>
    27a4:	8f 81       	ldd	r24, Y+7	; 0x07
    27a6:	28 2f       	mov	r18, r24
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	88 85       	ldd	r24, Y+8	; 0x08
    27ac:	88 2f       	mov	r24, r24
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	ac 01       	movw	r20, r24
    27b2:	24 9f       	mul	r18, r20
    27b4:	c0 01       	movw	r24, r0
    27b6:	25 9f       	mul	r18, r21
    27b8:	90 0d       	add	r25, r0
    27ba:	34 9f       	mul	r19, r20
    27bc:	90 0d       	add	r25, r0
    27be:	11 24       	eor	r1, r1
    27c0:	5f e7       	ldi	r21, 0x7F	; 127
    27c2:	81 3e       	cpi	r24, 0xE1	; 225
    27c4:	95 07       	cpc	r25, r21
    27c6:	78 f5       	brcc	.+94     	; 0x2826 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27c8:	8f 81       	ldd	r24, Y+7	; 0x07
    27ca:	28 2f       	mov	r18, r24
    27cc:	30 e0       	ldi	r19, 0x00	; 0
    27ce:	88 85       	ldd	r24, Y+8	; 0x08
    27d0:	88 2f       	mov	r24, r24
    27d2:	90 e0       	ldi	r25, 0x00	; 0
    27d4:	ac 01       	movw	r20, r24
    27d6:	24 9f       	mul	r18, r20
    27d8:	c0 01       	movw	r24, r0
    27da:	25 9f       	mul	r18, r21
    27dc:	90 0d       	add	r25, r0
    27de:	34 9f       	mul	r19, r20
    27e0:	90 0d       	add	r25, r0
    27e2:	11 24       	eor	r1, r1
    27e4:	9c 83       	std	Y+4, r25	; 0x04
    27e6:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    27e8:	8b 81       	ldd	r24, Y+3	; 0x03
    27ea:	9c 81       	ldd	r25, Y+4	; 0x04
    27ec:	4f 96       	adiw	r24, 0x1f	; 31
    27ee:	0e 94 77 0e 	call	0x1cee	; 0x1cee <pvPortMalloc>
    27f2:	9e 83       	std	Y+6, r25	; 0x06
    27f4:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    27f6:	8d 81       	ldd	r24, Y+5	; 0x05
    27f8:	9e 81       	ldd	r25, Y+6	; 0x06
    27fa:	00 97       	sbiw	r24, 0x00	; 0
    27fc:	a1 f0       	breq	.+40     	; 0x2826 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    27fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2800:	9e 81       	ldd	r25, Y+6	; 0x06
    2802:	9a 83       	std	Y+2, r25	; 0x02
    2804:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2806:	89 81       	ldd	r24, Y+1	; 0x01
    2808:	9a 81       	ldd	r25, Y+2	; 0x02
    280a:	4f 96       	adiw	r24, 0x1f	; 31
    280c:	9a 83       	std	Y+2, r25	; 0x02
    280e:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2810:	29 81       	ldd	r18, Y+1	; 0x01
    2812:	3a 81       	ldd	r19, Y+2	; 0x02
    2814:	ed 81       	ldd	r30, Y+5	; 0x05
    2816:	fe 81       	ldd	r31, Y+6	; 0x06
    2818:	8f 81       	ldd	r24, Y+7	; 0x07
    281a:	68 85       	ldd	r22, Y+8	; 0x08
    281c:	a9 01       	movw	r20, r18
    281e:	29 85       	ldd	r18, Y+9	; 0x09
    2820:	8f 01       	movw	r16, r30
    2822:	0e 94 20 14 	call	0x2840	; 0x2840 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    2826:	8d 81       	ldd	r24, Y+5	; 0x05
    2828:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    282a:	29 96       	adiw	r28, 0x09	; 9
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	de bf       	out	0x3e, r29	; 62
    2832:	0f be       	out	0x3f, r0	; 63
    2834:	cd bf       	out	0x3d, r28	; 61
    2836:	cf 91       	pop	r28
    2838:	df 91       	pop	r29
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	08 95       	ret

00002840 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2840:	0f 93       	push	r16
    2842:	1f 93       	push	r17
    2844:	df 93       	push	r29
    2846:	cf 93       	push	r28
    2848:	cd b7       	in	r28, 0x3d	; 61
    284a:	de b7       	in	r29, 0x3e	; 62
    284c:	27 97       	sbiw	r28, 0x07	; 7
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	f8 94       	cli
    2852:	de bf       	out	0x3e, r29	; 62
    2854:	0f be       	out	0x3f, r0	; 63
    2856:	cd bf       	out	0x3d, r28	; 61
    2858:	89 83       	std	Y+1, r24	; 0x01
    285a:	6a 83       	std	Y+2, r22	; 0x02
    285c:	5c 83       	std	Y+4, r21	; 0x04
    285e:	4b 83       	std	Y+3, r20	; 0x03
    2860:	2d 83       	std	Y+5, r18	; 0x05
    2862:	1f 83       	std	Y+7, r17	; 0x07
    2864:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2866:	8a 81       	ldd	r24, Y+2	; 0x02
    2868:	88 23       	and	r24, r24
    286a:	39 f4       	brne	.+14     	; 0x287a <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    286c:	8e 81       	ldd	r24, Y+6	; 0x06
    286e:	9f 81       	ldd	r25, Y+7	; 0x07
    2870:	ee 81       	ldd	r30, Y+6	; 0x06
    2872:	ff 81       	ldd	r31, Y+7	; 0x07
    2874:	91 83       	std	Z+1, r25	; 0x01
    2876:	80 83       	st	Z, r24
    2878:	06 c0       	rjmp	.+12     	; 0x2886 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    287a:	8b 81       	ldd	r24, Y+3	; 0x03
    287c:	9c 81       	ldd	r25, Y+4	; 0x04
    287e:	ee 81       	ldd	r30, Y+6	; 0x06
    2880:	ff 81       	ldd	r31, Y+7	; 0x07
    2882:	91 83       	std	Z+1, r25	; 0x01
    2884:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2886:	ee 81       	ldd	r30, Y+6	; 0x06
    2888:	ff 81       	ldd	r31, Y+7	; 0x07
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    288e:	ee 81       	ldd	r30, Y+6	; 0x06
    2890:	ff 81       	ldd	r31, Y+7	; 0x07
    2892:	8a 81       	ldd	r24, Y+2	; 0x02
    2894:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2896:	8e 81       	ldd	r24, Y+6	; 0x06
    2898:	9f 81       	ldd	r25, Y+7	; 0x07
    289a:	61 e0       	ldi	r22, 0x01	; 1
    289c:	0e 94 01 13 	call	0x2602	; 0x2602 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    28a0:	27 96       	adiw	r28, 0x07	; 7
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	de bf       	out	0x3e, r29	; 62
    28a8:	0f be       	out	0x3f, r0	; 63
    28aa:	cd bf       	out	0x3d, r28	; 61
    28ac:	cf 91       	pop	r28
    28ae:	df 91       	pop	r29
    28b0:	1f 91       	pop	r17
    28b2:	0f 91       	pop	r16
    28b4:	08 95       	ret

000028b6 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    28b6:	df 93       	push	r29
    28b8:	cf 93       	push	r28
    28ba:	00 d0       	rcall	.+0      	; 0x28bc <xQueueCreateCountingSemaphore+0x6>
    28bc:	00 d0       	rcall	.+0      	; 0x28be <xQueueCreateCountingSemaphore+0x8>
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
    28c2:	8b 83       	std	Y+3, r24	; 0x03
    28c4:	6c 83       	std	Y+4, r22	; 0x04
        QueueHandle_t xHandle = NULL;
    28c6:	1a 82       	std	Y+2, r1	; 0x02
    28c8:	19 82       	std	Y+1, r1	; 0x01

        if( ( uxMaxCount != 0 ) &&
    28ca:	8b 81       	ldd	r24, Y+3	; 0x03
    28cc:	88 23       	and	r24, r24
    28ce:	99 f0       	breq	.+38     	; 0x28f6 <xQueueCreateCountingSemaphore+0x40>
    28d0:	9c 81       	ldd	r25, Y+4	; 0x04
    28d2:	8b 81       	ldd	r24, Y+3	; 0x03
    28d4:	89 17       	cp	r24, r25
    28d6:	78 f0       	brcs	.+30     	; 0x28f6 <xQueueCreateCountingSemaphore+0x40>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    28d8:	8b 81       	ldd	r24, Y+3	; 0x03
    28da:	60 e0       	ldi	r22, 0x00	; 0
    28dc:	42 e0       	ldi	r20, 0x02	; 2
    28de:	0e 94 ac 13 	call	0x2758	; 0x2758 <xQueueGenericCreate>
    28e2:	9a 83       	std	Y+2, r25	; 0x02
    28e4:	89 83       	std	Y+1, r24	; 0x01

            if( xHandle != NULL )
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
    28e8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ea:	00 97       	sbiw	r24, 0x00	; 0
    28ec:	21 f0       	breq	.+8      	; 0x28f6 <xQueueCreateCountingSemaphore+0x40>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    28ee:	e9 81       	ldd	r30, Y+1	; 0x01
    28f0:	fa 81       	ldd	r31, Y+2	; 0x02
    28f2:	8c 81       	ldd	r24, Y+4	; 0x04
    28f4:	82 8f       	std	Z+26, r24	; 0x1a
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
    28f6:	89 81       	ldd	r24, Y+1	; 0x01
    28f8:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    28fa:	0f 90       	pop	r0
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
    2902:	cf 91       	pop	r28
    2904:	df 91       	pop	r29
    2906:	08 95       	ret

00002908 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2908:	df 93       	push	r29
    290a:	cf 93       	push	r28
    290c:	cd b7       	in	r28, 0x3d	; 61
    290e:	de b7       	in	r29, 0x3e	; 62
    2910:	2f 97       	sbiw	r28, 0x0f	; 15
    2912:	0f b6       	in	r0, 0x3f	; 63
    2914:	f8 94       	cli
    2916:	de bf       	out	0x3e, r29	; 62
    2918:	0f be       	out	0x3f, r0	; 63
    291a:	cd bf       	out	0x3d, r28	; 61
    291c:	99 87       	std	Y+9, r25	; 0x09
    291e:	88 87       	std	Y+8, r24	; 0x08
    2920:	7b 87       	std	Y+11, r23	; 0x0b
    2922:	6a 87       	std	Y+10, r22	; 0x0a
    2924:	5d 87       	std	Y+13, r21	; 0x0d
    2926:	4c 87       	std	Y+12, r20	; 0x0c
    2928:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    292a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    292c:	88 85       	ldd	r24, Y+8	; 0x08
    292e:	99 85       	ldd	r25, Y+9	; 0x09
    2930:	9a 83       	std	Y+2, r25	; 0x02
    2932:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2934:	0f b6       	in	r0, 0x3f	; 63
    2936:	f8 94       	cli
    2938:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    293a:	e9 81       	ldd	r30, Y+1	; 0x01
    293c:	fa 81       	ldd	r31, Y+2	; 0x02
    293e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2940:	e9 81       	ldd	r30, Y+1	; 0x01
    2942:	fa 81       	ldd	r31, Y+2	; 0x02
    2944:	83 8d       	ldd	r24, Z+27	; 0x1b
    2946:	98 17       	cp	r25, r24
    2948:	18 f0       	brcs	.+6      	; 0x2950 <xQueueGenericSend+0x48>
    294a:	8e 85       	ldd	r24, Y+14	; 0x0e
    294c:	82 30       	cpi	r24, 0x02	; 2
    294e:	11 f5       	brne	.+68     	; 0x2994 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2950:	89 81       	ldd	r24, Y+1	; 0x01
    2952:	9a 81       	ldd	r25, Y+2	; 0x02
    2954:	2a 85       	ldd	r18, Y+10	; 0x0a
    2956:	3b 85       	ldd	r19, Y+11	; 0x0b
    2958:	b9 01       	movw	r22, r18
    295a:	4e 85       	ldd	r20, Y+14	; 0x0e
    295c:	0e 94 da 18 	call	0x31b4	; 0x31b4 <prvCopyDataToQueue>
    2960:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2962:	e9 81       	ldd	r30, Y+1	; 0x01
    2964:	fa 81       	ldd	r31, Y+2	; 0x02
    2966:	81 89       	ldd	r24, Z+17	; 0x11
    2968:	88 23       	and	r24, r24
    296a:	51 f0       	breq	.+20     	; 0x2980 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    296c:	89 81       	ldd	r24, Y+1	; 0x01
    296e:	9a 81       	ldd	r25, Y+2	; 0x02
    2970:	41 96       	adiw	r24, 0x11	; 17
    2972:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2976:	88 23       	and	r24, r24
    2978:	41 f0       	breq	.+16     	; 0x298a <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    297a:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    297e:	05 c0       	rjmp	.+10     	; 0x298a <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    2980:	8b 81       	ldd	r24, Y+3	; 0x03
    2982:	88 23       	and	r24, r24
    2984:	11 f0       	breq	.+4      	; 0x298a <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    2986:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    298a:	0f 90       	pop	r0
    298c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    298e:	81 e0       	ldi	r24, 0x01	; 1
    2990:	8f 87       	std	Y+15, r24	; 0x0f
    2992:	5c c0       	rjmp	.+184    	; 0x2a4c <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2994:	8c 85       	ldd	r24, Y+12	; 0x0c
    2996:	9d 85       	ldd	r25, Y+13	; 0x0d
    2998:	00 97       	sbiw	r24, 0x00	; 0
    299a:	21 f4       	brne	.+8      	; 0x29a4 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    299c:	0f 90       	pop	r0
    299e:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    29a0:	1f 86       	std	Y+15, r1	; 0x0f
    29a2:	54 c0       	rjmp	.+168    	; 0x2a4c <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    29a4:	8c 81       	ldd	r24, Y+4	; 0x04
    29a6:	88 23       	and	r24, r24
    29a8:	31 f4       	brne	.+12     	; 0x29b6 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    29aa:	ce 01       	movw	r24, r28
    29ac:	05 96       	adiw	r24, 0x05	; 5
    29ae:	0e 94 7b 2c 	call	0x58f6	; 0x58f6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    29b6:	0f 90       	pop	r0
    29b8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    29ba:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	f8 94       	cli
    29c2:	0f 92       	push	r0
    29c4:	e9 81       	ldd	r30, Y+1	; 0x01
    29c6:	fa 81       	ldd	r31, Y+2	; 0x02
    29c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    29ca:	8f 3f       	cpi	r24, 0xFF	; 255
    29cc:	19 f4       	brne	.+6      	; 0x29d4 <xQueueGenericSend+0xcc>
    29ce:	e9 81       	ldd	r30, Y+1	; 0x01
    29d0:	fa 81       	ldd	r31, Y+2	; 0x02
    29d2:	15 8e       	std	Z+29, r1	; 0x1d
    29d4:	e9 81       	ldd	r30, Y+1	; 0x01
    29d6:	fa 81       	ldd	r31, Y+2	; 0x02
    29d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    29da:	8f 3f       	cpi	r24, 0xFF	; 255
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <xQueueGenericSend+0xdc>
    29de:	e9 81       	ldd	r30, Y+1	; 0x01
    29e0:	fa 81       	ldd	r31, Y+2	; 0x02
    29e2:	16 8e       	std	Z+30, r1	; 0x1e
    29e4:	0f 90       	pop	r0
    29e6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    29e8:	ce 01       	movw	r24, r28
    29ea:	05 96       	adiw	r24, 0x05	; 5
    29ec:	9e 01       	movw	r18, r28
    29ee:	24 5f       	subi	r18, 0xF4	; 244
    29f0:	3f 4f       	sbci	r19, 0xFF	; 255
    29f2:	b9 01       	movw	r22, r18
    29f4:	0e 94 94 2c 	call	0x5928	; 0x5928 <xTaskCheckForTimeOut>
    29f8:	88 23       	and	r24, r24
    29fa:	09 f5       	brne	.+66     	; 0x2a3e <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    29fc:	89 81       	ldd	r24, Y+1	; 0x01
    29fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2a00:	0e 94 56 1a 	call	0x34ac	; 0x34ac <prvIsQueueFull>
    2a04:	88 23       	and	r24, r24
    2a06:	a1 f0       	breq	.+40     	; 0x2a30 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2a08:	89 81       	ldd	r24, Y+1	; 0x01
    2a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0c:	08 96       	adiw	r24, 0x08	; 8
    2a0e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2a10:	3d 85       	ldd	r19, Y+13	; 0x0d
    2a12:	b9 01       	movw	r22, r18
    2a14:	0e 94 84 29 	call	0x5308	; 0x5308 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1c:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2a20:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2a24:	88 23       	and	r24, r24
    2a26:	09 f0       	breq	.+2      	; 0x2a2a <xQueueGenericSend+0x122>
    2a28:	85 cf       	rjmp	.-246    	; 0x2934 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2a2a:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    2a2e:	82 cf       	rjmp	.-252    	; 0x2934 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	9a 81       	ldd	r25, Y+2	; 0x02
    2a34:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2a38:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2a3c:	7b cf       	rjmp	.-266    	; 0x2934 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2a3e:	89 81       	ldd	r24, Y+1	; 0x01
    2a40:	9a 81       	ldd	r25, Y+2	; 0x02
    2a42:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2a46:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2a4a:	1f 86       	std	Y+15, r1	; 0x0f
    2a4c:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2a4e:	2f 96       	adiw	r28, 0x0f	; 15
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	f8 94       	cli
    2a54:	de bf       	out	0x3e, r29	; 62
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	cf 91       	pop	r28
    2a5c:	df 91       	pop	r29
    2a5e:	08 95       	ret

00002a60 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2a60:	df 93       	push	r29
    2a62:	cf 93       	push	r28
    2a64:	cd b7       	in	r28, 0x3d	; 61
    2a66:	de b7       	in	r29, 0x3e	; 62
    2a68:	2d 97       	sbiw	r28, 0x0d	; 13
    2a6a:	0f b6       	in	r0, 0x3f	; 63
    2a6c:	f8 94       	cli
    2a6e:	de bf       	out	0x3e, r29	; 62
    2a70:	0f be       	out	0x3f, r0	; 63
    2a72:	cd bf       	out	0x3d, r28	; 61
    2a74:	98 87       	std	Y+8, r25	; 0x08
    2a76:	8f 83       	std	Y+7, r24	; 0x07
    2a78:	7a 87       	std	Y+10, r23	; 0x0a
    2a7a:	69 87       	std	Y+9, r22	; 0x09
    2a7c:	5c 87       	std	Y+12, r21	; 0x0c
    2a7e:	4b 87       	std	Y+11, r20	; 0x0b
    2a80:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2a82:	8f 81       	ldd	r24, Y+7	; 0x07
    2a84:	98 85       	ldd	r25, Y+8	; 0x08
    2a86:	9c 83       	std	Y+4, r25	; 0x04
    2a88:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a8a:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2a8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a90:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a92:	eb 81       	ldd	r30, Y+3	; 0x03
    2a94:	fc 81       	ldd	r31, Y+4	; 0x04
    2a96:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a98:	98 17       	cp	r25, r24
    2a9a:	18 f0       	brcs	.+6      	; 0x2aa2 <xQueueGenericSendFromISR+0x42>
    2a9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a9e:	82 30       	cpi	r24, 0x02	; 2
    2aa0:	81 f5       	brne	.+96     	; 0x2b02 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2aa2:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa4:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa6:	86 8d       	ldd	r24, Z+30	; 0x1e
    2aa8:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    2aac:	fc 81       	ldd	r31, Y+4	; 0x04
    2aae:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ab0:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab6:	29 85       	ldd	r18, Y+9	; 0x09
    2ab8:	3a 85       	ldd	r19, Y+10	; 0x0a
    2aba:	b9 01       	movw	r22, r18
    2abc:	4d 85       	ldd	r20, Y+13	; 0x0d
    2abe:	0e 94 da 18 	call	0x31b4	; 0x31b4 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ac6:	a9 f4       	brne	.+42     	; 0x2af2 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aca:	fc 81       	ldd	r31, Y+4	; 0x04
    2acc:	81 89       	ldd	r24, Z+17	; 0x11
    2ace:	88 23       	and	r24, r24
    2ad0:	a9 f0       	breq	.+42     	; 0x2afc <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad6:	41 96       	adiw	r24, 0x11	; 17
    2ad8:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2adc:	88 23       	and	r24, r24
    2ade:	71 f0       	breq	.+28     	; 0x2afc <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2ae0:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ae2:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ae4:	00 97       	sbiw	r24, 0x00	; 0
    2ae6:	51 f0       	breq	.+20     	; 0x2afc <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2ae8:	eb 85       	ldd	r30, Y+11	; 0x0b
    2aea:	fc 85       	ldd	r31, Y+12	; 0x0c
    2aec:	81 e0       	ldi	r24, 0x01	; 1
    2aee:	80 83       	st	Z, r24
    2af0:	05 c0       	rjmp	.+10     	; 0x2afc <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2af2:	8a 81       	ldd	r24, Y+2	; 0x02
    2af4:	8f 5f       	subi	r24, 0xFF	; 255
    2af6:	eb 81       	ldd	r30, Y+3	; 0x03
    2af8:	fc 81       	ldd	r31, Y+4	; 0x04
    2afa:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2afc:	81 e0       	ldi	r24, 0x01	; 1
    2afe:	8e 83       	std	Y+6, r24	; 0x06
    2b00:	01 c0       	rjmp	.+2      	; 0x2b04 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2b02:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2b04:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2b06:	2d 96       	adiw	r28, 0x0d	; 13
    2b08:	0f b6       	in	r0, 0x3f	; 63
    2b0a:	f8 94       	cli
    2b0c:	de bf       	out	0x3e, r29	; 62
    2b0e:	0f be       	out	0x3f, r0	; 63
    2b10:	cd bf       	out	0x3d, r28	; 61
    2b12:	cf 91       	pop	r28
    2b14:	df 91       	pop	r29
    2b16:	08 95       	ret

00002b18 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2b18:	df 93       	push	r29
    2b1a:	cf 93       	push	r28
    2b1c:	cd b7       	in	r28, 0x3d	; 61
    2b1e:	de b7       	in	r29, 0x3e	; 62
    2b20:	2a 97       	sbiw	r28, 0x0a	; 10
    2b22:	0f b6       	in	r0, 0x3f	; 63
    2b24:	f8 94       	cli
    2b26:	de bf       	out	0x3e, r29	; 62
    2b28:	0f be       	out	0x3f, r0	; 63
    2b2a:	cd bf       	out	0x3d, r28	; 61
    2b2c:	98 87       	std	Y+8, r25	; 0x08
    2b2e:	8f 83       	std	Y+7, r24	; 0x07
    2b30:	7a 87       	std	Y+10, r23	; 0x0a
    2b32:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2b34:	8f 81       	ldd	r24, Y+7	; 0x07
    2b36:	98 85       	ldd	r25, Y+8	; 0x08
    2b38:	9c 83       	std	Y+4, r25	; 0x04
    2b3a:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2b3c:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b40:	fc 81       	ldd	r31, Y+4	; 0x04
    2b42:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b44:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2b46:	eb 81       	ldd	r30, Y+3	; 0x03
    2b48:	fc 81       	ldd	r31, Y+4	; 0x04
    2b4a:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4e:	89 17       	cp	r24, r25
    2b50:	48 f5       	brcc	.+82     	; 0x2ba4 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2b52:	eb 81       	ldd	r30, Y+3	; 0x03
    2b54:	fc 81       	ldd	r31, Y+4	; 0x04
    2b56:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b58:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5c:	8f 5f       	subi	r24, 0xFF	; 255
    2b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b60:	fc 81       	ldd	r31, Y+4	; 0x04
    2b62:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2b64:	89 81       	ldd	r24, Y+1	; 0x01
    2b66:	8f 3f       	cpi	r24, 0xFF	; 255
    2b68:	a9 f4       	brne	.+42     	; 0x2b94 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b6e:	81 89       	ldd	r24, Z+17	; 0x11
    2b70:	88 23       	and	r24, r24
    2b72:	a9 f0       	breq	.+42     	; 0x2b9e <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b74:	8b 81       	ldd	r24, Y+3	; 0x03
    2b76:	9c 81       	ldd	r25, Y+4	; 0x04
    2b78:	41 96       	adiw	r24, 0x11	; 17
    2b7a:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2b7e:	88 23       	and	r24, r24
    2b80:	71 f0       	breq	.+28     	; 0x2b9e <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2b82:	89 85       	ldd	r24, Y+9	; 0x09
    2b84:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b86:	00 97       	sbiw	r24, 0x00	; 0
    2b88:	51 f0       	breq	.+20     	; 0x2b9e <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2b8a:	e9 85       	ldd	r30, Y+9	; 0x09
    2b8c:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b8e:	81 e0       	ldi	r24, 0x01	; 1
    2b90:	80 83       	st	Z, r24
    2b92:	05 c0       	rjmp	.+10     	; 0x2b9e <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2b94:	89 81       	ldd	r24, Y+1	; 0x01
    2b96:	8f 5f       	subi	r24, 0xFF	; 255
    2b98:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9c:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2b9e:	81 e0       	ldi	r24, 0x01	; 1
    2ba0:	8e 83       	std	Y+6, r24	; 0x06
    2ba2:	01 c0       	rjmp	.+2      	; 0x2ba6 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2ba4:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2ba6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2ba8:	2a 96       	adiw	r28, 0x0a	; 10
    2baa:	0f b6       	in	r0, 0x3f	; 63
    2bac:	f8 94       	cli
    2bae:	de bf       	out	0x3e, r29	; 62
    2bb0:	0f be       	out	0x3f, r0	; 63
    2bb2:	cd bf       	out	0x3d, r28	; 61
    2bb4:	cf 91       	pop	r28
    2bb6:	df 91       	pop	r29
    2bb8:	08 95       	ret

00002bba <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2bba:	df 93       	push	r29
    2bbc:	cf 93       	push	r28
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
    2bc2:	2e 97       	sbiw	r28, 0x0e	; 14
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	f8 94       	cli
    2bc8:	de bf       	out	0x3e, r29	; 62
    2bca:	0f be       	out	0x3f, r0	; 63
    2bcc:	cd bf       	out	0x3d, r28	; 61
    2bce:	99 87       	std	Y+9, r25	; 0x09
    2bd0:	88 87       	std	Y+8, r24	; 0x08
    2bd2:	7b 87       	std	Y+11, r23	; 0x0b
    2bd4:	6a 87       	std	Y+10, r22	; 0x0a
    2bd6:	5d 87       	std	Y+13, r21	; 0x0d
    2bd8:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2bda:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2bdc:	88 85       	ldd	r24, Y+8	; 0x08
    2bde:	99 85       	ldd	r25, Y+9	; 0x09
    2be0:	9b 83       	std	Y+3, r25	; 0x03
    2be2:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2be4:	0f b6       	in	r0, 0x3f	; 63
    2be6:	f8 94       	cli
    2be8:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bea:	ea 81       	ldd	r30, Y+2	; 0x02
    2bec:	fb 81       	ldd	r31, Y+3	; 0x03
    2bee:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf0:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bf2:	89 81       	ldd	r24, Y+1	; 0x01
    2bf4:	88 23       	and	r24, r24
    2bf6:	f9 f0       	breq	.+62     	; 0x2c36 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2bfc:	2a 85       	ldd	r18, Y+10	; 0x0a
    2bfe:	3b 85       	ldd	r19, Y+11	; 0x0b
    2c00:	b9 01       	movw	r22, r18
    2c02:	0e 94 80 19 	call	0x3300	; 0x3300 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2c06:	89 81       	ldd	r24, Y+1	; 0x01
    2c08:	81 50       	subi	r24, 0x01	; 1
    2c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c0e:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c10:	ea 81       	ldd	r30, Y+2	; 0x02
    2c12:	fb 81       	ldd	r31, Y+3	; 0x03
    2c14:	80 85       	ldd	r24, Z+8	; 0x08
    2c16:	88 23       	and	r24, r24
    2c18:	49 f0       	breq	.+18     	; 0x2c2c <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c1e:	08 96       	adiw	r24, 0x08	; 8
    2c20:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2c24:	88 23       	and	r24, r24
    2c26:	11 f0       	breq	.+4      	; 0x2c2c <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2c28:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2c2c:	0f 90       	pop	r0
    2c2e:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2c30:	81 e0       	ldi	r24, 0x01	; 1
    2c32:	8e 87       	std	Y+14, r24	; 0x0e
    2c34:	63 c0       	rjmp	.+198    	; 0x2cfc <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2c36:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c38:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c3a:	00 97       	sbiw	r24, 0x00	; 0
    2c3c:	21 f4       	brne	.+8      	; 0x2c46 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2c3e:	0f 90       	pop	r0
    2c40:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2c42:	1e 86       	std	Y+14, r1	; 0x0e
    2c44:	5b c0       	rjmp	.+182    	; 0x2cfc <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    2c46:	8c 81       	ldd	r24, Y+4	; 0x04
    2c48:	88 23       	and	r24, r24
    2c4a:	31 f4       	brne	.+12     	; 0x2c58 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2c4c:	ce 01       	movw	r24, r28
    2c4e:	05 96       	adiw	r24, 0x05	; 5
    2c50:	0e 94 7b 2c 	call	0x58f6	; 0x58f6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2c54:	81 e0       	ldi	r24, 0x01	; 1
    2c56:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2c58:	0f 90       	pop	r0
    2c5a:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2c5c:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2c60:	0f b6       	in	r0, 0x3f	; 63
    2c62:	f8 94       	cli
    2c64:	0f 92       	push	r0
    2c66:	ea 81       	ldd	r30, Y+2	; 0x02
    2c68:	fb 81       	ldd	r31, Y+3	; 0x03
    2c6a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c6c:	8f 3f       	cpi	r24, 0xFF	; 255
    2c6e:	19 f4       	brne	.+6      	; 0x2c76 <xQueueReceive+0xbc>
    2c70:	ea 81       	ldd	r30, Y+2	; 0x02
    2c72:	fb 81       	ldd	r31, Y+3	; 0x03
    2c74:	15 8e       	std	Z+29, r1	; 0x1d
    2c76:	ea 81       	ldd	r30, Y+2	; 0x02
    2c78:	fb 81       	ldd	r31, Y+3	; 0x03
    2c7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c7c:	8f 3f       	cpi	r24, 0xFF	; 255
    2c7e:	19 f4       	brne	.+6      	; 0x2c86 <xQueueReceive+0xcc>
    2c80:	ea 81       	ldd	r30, Y+2	; 0x02
    2c82:	fb 81       	ldd	r31, Y+3	; 0x03
    2c84:	16 8e       	std	Z+30, r1	; 0x1e
    2c86:	0f 90       	pop	r0
    2c88:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c8a:	ce 01       	movw	r24, r28
    2c8c:	05 96       	adiw	r24, 0x05	; 5
    2c8e:	9e 01       	movw	r18, r28
    2c90:	24 5f       	subi	r18, 0xF4	; 244
    2c92:	3f 4f       	sbci	r19, 0xFF	; 255
    2c94:	b9 01       	movw	r22, r18
    2c96:	0e 94 94 2c 	call	0x5928	; 0x5928 <xTaskCheckForTimeOut>
    2c9a:	88 23       	and	r24, r24
    2c9c:	09 f5       	brne	.+66     	; 0x2ce0 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ca2:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2ca6:	88 23       	and	r24, r24
    2ca8:	a1 f0       	breq	.+40     	; 0x2cd2 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2caa:	8a 81       	ldd	r24, Y+2	; 0x02
    2cac:	9b 81       	ldd	r25, Y+3	; 0x03
    2cae:	41 96       	adiw	r24, 0x11	; 17
    2cb0:	2c 85       	ldd	r18, Y+12	; 0x0c
    2cb2:	3d 85       	ldd	r19, Y+13	; 0x0d
    2cb4:	b9 01       	movw	r22, r18
    2cb6:	0e 94 84 29 	call	0x5308	; 0x5308 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2cba:	8a 81       	ldd	r24, Y+2	; 0x02
    2cbc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cbe:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2cc2:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2cc6:	88 23       	and	r24, r24
    2cc8:	09 f0       	breq	.+2      	; 0x2ccc <xQueueReceive+0x112>
    2cca:	8c cf       	rjmp	.-232    	; 0x2be4 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2ccc:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    2cd0:	89 cf       	rjmp	.-238    	; 0x2be4 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd6:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2cda:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2cde:	82 cf       	rjmp	.-252    	; 0x2be4 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ce4:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2ce8:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2cec:	8a 81       	ldd	r24, Y+2	; 0x02
    2cee:	9b 81       	ldd	r25, Y+3	; 0x03
    2cf0:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2cf4:	88 23       	and	r24, r24
    2cf6:	09 f4       	brne	.+2      	; 0x2cfa <xQueueReceive+0x140>
    2cf8:	75 cf       	rjmp	.-278    	; 0x2be4 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2cfa:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2cfc:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2cfe:	2e 96       	adiw	r28, 0x0e	; 14
    2d00:	0f b6       	in	r0, 0x3f	; 63
    2d02:	f8 94       	cli
    2d04:	de bf       	out	0x3e, r29	; 62
    2d06:	0f be       	out	0x3f, r0	; 63
    2d08:	cd bf       	out	0x3d, r28	; 61
    2d0a:	cf 91       	pop	r28
    2d0c:	df 91       	pop	r29
    2d0e:	08 95       	ret

00002d10 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2d10:	df 93       	push	r29
    2d12:	cf 93       	push	r28
    2d14:	cd b7       	in	r28, 0x3d	; 61
    2d16:	de b7       	in	r29, 0x3e	; 62
    2d18:	2c 97       	sbiw	r28, 0x0c	; 12
    2d1a:	0f b6       	in	r0, 0x3f	; 63
    2d1c:	f8 94       	cli
    2d1e:	de bf       	out	0x3e, r29	; 62
    2d20:	0f be       	out	0x3f, r0	; 63
    2d22:	cd bf       	out	0x3d, r28	; 61
    2d24:	99 87       	std	Y+9, r25	; 0x09
    2d26:	88 87       	std	Y+8, r24	; 0x08
    2d28:	7b 87       	std	Y+11, r23	; 0x0b
    2d2a:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2d2c:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2d2e:	88 85       	ldd	r24, Y+8	; 0x08
    2d30:	99 85       	ldd	r25, Y+9	; 0x09
    2d32:	9b 83       	std	Y+3, r25	; 0x03
    2d34:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2d36:	0f b6       	in	r0, 0x3f	; 63
    2d38:	f8 94       	cli
    2d3a:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2d3c:	ea 81       	ldd	r30, Y+2	; 0x02
    2d3e:	fb 81       	ldd	r31, Y+3	; 0x03
    2d40:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d42:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2d44:	89 81       	ldd	r24, Y+1	; 0x01
    2d46:	88 23       	and	r24, r24
    2d48:	c1 f0       	breq	.+48     	; 0x2d7a <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2d4a:	89 81       	ldd	r24, Y+1	; 0x01
    2d4c:	81 50       	subi	r24, 0x01	; 1
    2d4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d50:	fb 81       	ldd	r31, Y+3	; 0x03
    2d52:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d54:	ea 81       	ldd	r30, Y+2	; 0x02
    2d56:	fb 81       	ldd	r31, Y+3	; 0x03
    2d58:	80 85       	ldd	r24, Z+8	; 0x08
    2d5a:	88 23       	and	r24, r24
    2d5c:	49 f0       	breq	.+18     	; 0x2d70 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d60:	9b 81       	ldd	r25, Y+3	; 0x03
    2d62:	08 96       	adiw	r24, 0x08	; 8
    2d64:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2d68:	88 23       	and	r24, r24
    2d6a:	11 f0       	breq	.+4      	; 0x2d70 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2d6c:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2d70:	0f 90       	pop	r0
    2d72:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2d74:	81 e0       	ldi	r24, 0x01	; 1
    2d76:	8c 87       	std	Y+12, r24	; 0x0c
    2d78:	63 c0       	rjmp	.+198    	; 0x2e40 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2d7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d7c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d7e:	00 97       	sbiw	r24, 0x00	; 0
    2d80:	21 f4       	brne	.+8      	; 0x2d8a <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2d82:	0f 90       	pop	r0
    2d84:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2d86:	1c 86       	std	Y+12, r1	; 0x0c
    2d88:	5b c0       	rjmp	.+182    	; 0x2e40 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2d8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d8c:	88 23       	and	r24, r24
    2d8e:	31 f4       	brne	.+12     	; 0x2d9c <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2d90:	ce 01       	movw	r24, r28
    2d92:	05 96       	adiw	r24, 0x05	; 5
    2d94:	0e 94 7b 2c 	call	0x58f6	; 0x58f6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2d98:	81 e0       	ldi	r24, 0x01	; 1
    2d9a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2d9c:	0f 90       	pop	r0
    2d9e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2da0:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2da4:	0f b6       	in	r0, 0x3f	; 63
    2da6:	f8 94       	cli
    2da8:	0f 92       	push	r0
    2daa:	ea 81       	ldd	r30, Y+2	; 0x02
    2dac:	fb 81       	ldd	r31, Y+3	; 0x03
    2dae:	85 8d       	ldd	r24, Z+29	; 0x1d
    2db0:	8f 3f       	cpi	r24, 0xFF	; 255
    2db2:	19 f4       	brne	.+6      	; 0x2dba <xQueueSemaphoreTake+0xaa>
    2db4:	ea 81       	ldd	r30, Y+2	; 0x02
    2db6:	fb 81       	ldd	r31, Y+3	; 0x03
    2db8:	15 8e       	std	Z+29, r1	; 0x1d
    2dba:	ea 81       	ldd	r30, Y+2	; 0x02
    2dbc:	fb 81       	ldd	r31, Y+3	; 0x03
    2dbe:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dc0:	8f 3f       	cpi	r24, 0xFF	; 255
    2dc2:	19 f4       	brne	.+6      	; 0x2dca <xQueueSemaphoreTake+0xba>
    2dc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2dc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2dc8:	16 8e       	std	Z+30, r1	; 0x1e
    2dca:	0f 90       	pop	r0
    2dcc:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2dce:	ce 01       	movw	r24, r28
    2dd0:	05 96       	adiw	r24, 0x05	; 5
    2dd2:	9e 01       	movw	r18, r28
    2dd4:	26 5f       	subi	r18, 0xF6	; 246
    2dd6:	3f 4f       	sbci	r19, 0xFF	; 255
    2dd8:	b9 01       	movw	r22, r18
    2dda:	0e 94 94 2c 	call	0x5928	; 0x5928 <xTaskCheckForTimeOut>
    2dde:	88 23       	and	r24, r24
    2de0:	09 f5       	brne	.+66     	; 0x2e24 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2de2:	8a 81       	ldd	r24, Y+2	; 0x02
    2de4:	9b 81       	ldd	r25, Y+3	; 0x03
    2de6:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2dea:	88 23       	and	r24, r24
    2dec:	a1 f0       	breq	.+40     	; 0x2e16 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2dee:	8a 81       	ldd	r24, Y+2	; 0x02
    2df0:	9b 81       	ldd	r25, Y+3	; 0x03
    2df2:	41 96       	adiw	r24, 0x11	; 17
    2df4:	2a 85       	ldd	r18, Y+10	; 0x0a
    2df6:	3b 85       	ldd	r19, Y+11	; 0x0b
    2df8:	b9 01       	movw	r22, r18
    2dfa:	0e 94 84 29 	call	0x5308	; 0x5308 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2dfe:	8a 81       	ldd	r24, Y+2	; 0x02
    2e00:	9b 81       	ldd	r25, Y+3	; 0x03
    2e02:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2e06:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2e0a:	88 23       	and	r24, r24
    2e0c:	09 f0       	breq	.+2      	; 0x2e10 <xQueueSemaphoreTake+0x100>
    2e0e:	93 cf       	rjmp	.-218    	; 0x2d36 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2e10:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    2e14:	90 cf       	rjmp	.-224    	; 0x2d36 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2e16:	8a 81       	ldd	r24, Y+2	; 0x02
    2e18:	9b 81       	ldd	r25, Y+3	; 0x03
    2e1a:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2e1e:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2e22:	89 cf       	rjmp	.-238    	; 0x2d36 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2e24:	8a 81       	ldd	r24, Y+2	; 0x02
    2e26:	9b 81       	ldd	r25, Y+3	; 0x03
    2e28:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2e2c:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e30:	8a 81       	ldd	r24, Y+2	; 0x02
    2e32:	9b 81       	ldd	r25, Y+3	; 0x03
    2e34:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2e38:	88 23       	and	r24, r24
    2e3a:	09 f4       	brne	.+2      	; 0x2e3e <xQueueSemaphoreTake+0x12e>
    2e3c:	7c cf       	rjmp	.-264    	; 0x2d36 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2e3e:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2e40:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2e42:	2c 96       	adiw	r28, 0x0c	; 12
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	de bf       	out	0x3e, r29	; 62
    2e4a:	0f be       	out	0x3f, r0	; 63
    2e4c:	cd bf       	out	0x3d, r28	; 61
    2e4e:	cf 91       	pop	r28
    2e50:	df 91       	pop	r29
    2e52:	08 95       	ret

00002e54 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2e54:	df 93       	push	r29
    2e56:	cf 93       	push	r28
    2e58:	cd b7       	in	r28, 0x3d	; 61
    2e5a:	de b7       	in	r29, 0x3e	; 62
    2e5c:	60 97       	sbiw	r28, 0x10	; 16
    2e5e:	0f b6       	in	r0, 0x3f	; 63
    2e60:	f8 94       	cli
    2e62:	de bf       	out	0x3e, r29	; 62
    2e64:	0f be       	out	0x3f, r0	; 63
    2e66:	cd bf       	out	0x3d, r28	; 61
    2e68:	9b 87       	std	Y+11, r25	; 0x0b
    2e6a:	8a 87       	std	Y+10, r24	; 0x0a
    2e6c:	7d 87       	std	Y+13, r23	; 0x0d
    2e6e:	6c 87       	std	Y+12, r22	; 0x0c
    2e70:	5f 87       	std	Y+15, r21	; 0x0f
    2e72:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2e74:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2e76:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e78:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e7a:	9b 83       	std	Y+3, r25	; 0x03
    2e7c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2e7e:	0f b6       	in	r0, 0x3f	; 63
    2e80:	f8 94       	cli
    2e82:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2e84:	ea 81       	ldd	r30, Y+2	; 0x02
    2e86:	fb 81       	ldd	r31, Y+3	; 0x03
    2e88:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e8a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e8c:	89 81       	ldd	r24, Y+1	; 0x01
    2e8e:	88 23       	and	r24, r24
    2e90:	31 f1       	breq	.+76     	; 0x2ede <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2e92:	ea 81       	ldd	r30, Y+2	; 0x02
    2e94:	fb 81       	ldd	r31, Y+3	; 0x03
    2e96:	86 81       	ldd	r24, Z+6	; 0x06
    2e98:	97 81       	ldd	r25, Z+7	; 0x07
    2e9a:	9d 83       	std	Y+5, r25	; 0x05
    2e9c:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea2:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ea4:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ea6:	b9 01       	movw	r22, r18
    2ea8:	0e 94 80 19 	call	0x3300	; 0x3300 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2eac:	ea 81       	ldd	r30, Y+2	; 0x02
    2eae:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb0:	8c 81       	ldd	r24, Y+4	; 0x04
    2eb2:	9d 81       	ldd	r25, Y+5	; 0x05
    2eb4:	97 83       	std	Z+7, r25	; 0x07
    2eb6:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2eb8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eba:	fb 81       	ldd	r31, Y+3	; 0x03
    2ebc:	81 89       	ldd	r24, Z+17	; 0x11
    2ebe:	88 23       	and	r24, r24
    2ec0:	49 f0       	breq	.+18     	; 0x2ed4 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec6:	41 96       	adiw	r24, 0x11	; 17
    2ec8:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    2ecc:	88 23       	and	r24, r24
    2ece:	11 f0       	breq	.+4      	; 0x2ed4 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2ed0:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2ed4:	0f 90       	pop	r0
    2ed6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	88 8b       	std	Y+16, r24	; 0x10
    2edc:	63 c0       	rjmp	.+198    	; 0x2fa4 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ede:	8e 85       	ldd	r24, Y+14	; 0x0e
    2ee0:	9f 85       	ldd	r25, Y+15	; 0x0f
    2ee2:	00 97       	sbiw	r24, 0x00	; 0
    2ee4:	21 f4       	brne	.+8      	; 0x2eee <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2ee6:	0f 90       	pop	r0
    2ee8:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2eea:	18 8a       	std	Y+16, r1	; 0x10
    2eec:	5b c0       	rjmp	.+182    	; 0x2fa4 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2eee:	8e 81       	ldd	r24, Y+6	; 0x06
    2ef0:	88 23       	and	r24, r24
    2ef2:	31 f4       	brne	.+12     	; 0x2f00 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2ef4:	ce 01       	movw	r24, r28
    2ef6:	07 96       	adiw	r24, 0x07	; 7
    2ef8:	0e 94 7b 2c 	call	0x58f6	; 0x58f6 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2efc:	81 e0       	ldi	r24, 0x01	; 1
    2efe:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2f00:	0f 90       	pop	r0
    2f02:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2f04:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	0f 92       	push	r0
    2f0e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f10:	fb 81       	ldd	r31, Y+3	; 0x03
    2f12:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f14:	8f 3f       	cpi	r24, 0xFF	; 255
    2f16:	19 f4       	brne	.+6      	; 0x2f1e <xQueuePeek+0xca>
    2f18:	ea 81       	ldd	r30, Y+2	; 0x02
    2f1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f1c:	15 8e       	std	Z+29, r1	; 0x1d
    2f1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f20:	fb 81       	ldd	r31, Y+3	; 0x03
    2f22:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f24:	8f 3f       	cpi	r24, 0xFF	; 255
    2f26:	19 f4       	brne	.+6      	; 0x2f2e <xQueuePeek+0xda>
    2f28:	ea 81       	ldd	r30, Y+2	; 0x02
    2f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f2c:	16 8e       	std	Z+30, r1	; 0x1e
    2f2e:	0f 90       	pop	r0
    2f30:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2f32:	ce 01       	movw	r24, r28
    2f34:	07 96       	adiw	r24, 0x07	; 7
    2f36:	9e 01       	movw	r18, r28
    2f38:	22 5f       	subi	r18, 0xF2	; 242
    2f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f3c:	b9 01       	movw	r22, r18
    2f3e:	0e 94 94 2c 	call	0x5928	; 0x5928 <xTaskCheckForTimeOut>
    2f42:	88 23       	and	r24, r24
    2f44:	09 f5       	brne	.+66     	; 0x2f88 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f46:	8a 81       	ldd	r24, Y+2	; 0x02
    2f48:	9b 81       	ldd	r25, Y+3	; 0x03
    2f4a:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2f4e:	88 23       	and	r24, r24
    2f50:	a1 f0       	breq	.+40     	; 0x2f7a <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2f52:	8a 81       	ldd	r24, Y+2	; 0x02
    2f54:	9b 81       	ldd	r25, Y+3	; 0x03
    2f56:	41 96       	adiw	r24, 0x11	; 17
    2f58:	2e 85       	ldd	r18, Y+14	; 0x0e
    2f5a:	3f 85       	ldd	r19, Y+15	; 0x0f
    2f5c:	b9 01       	movw	r22, r18
    2f5e:	0e 94 84 29 	call	0x5308	; 0x5308 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2f62:	8a 81       	ldd	r24, Y+2	; 0x02
    2f64:	9b 81       	ldd	r25, Y+3	; 0x03
    2f66:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2f6a:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2f6e:	88 23       	and	r24, r24
    2f70:	09 f0       	breq	.+2      	; 0x2f74 <xQueuePeek+0x120>
    2f72:	85 cf       	rjmp	.-246    	; 0x2e7e <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2f74:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    2f78:	82 cf       	rjmp	.-252    	; 0x2e7e <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7e:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2f82:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    2f86:	7b cf       	rjmp	.-266    	; 0x2e7e <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2f88:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8c:	0e 94 c7 19 	call	0x338e	; 0x338e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2f90:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f94:	8a 81       	ldd	r24, Y+2	; 0x02
    2f96:	9b 81       	ldd	r25, Y+3	; 0x03
    2f98:	0e 94 1a 1a 	call	0x3434	; 0x3434 <prvIsQueueEmpty>
    2f9c:	88 23       	and	r24, r24
    2f9e:	09 f4       	brne	.+2      	; 0x2fa2 <xQueuePeek+0x14e>
    2fa0:	6e cf       	rjmp	.-292    	; 0x2e7e <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2fa2:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2fa4:	88 89       	ldd	r24, Y+16	; 0x10
}
    2fa6:	60 96       	adiw	r28, 0x10	; 16
    2fa8:	0f b6       	in	r0, 0x3f	; 63
    2faa:	f8 94       	cli
    2fac:	de bf       	out	0x3e, r29	; 62
    2fae:	0f be       	out	0x3f, r0	; 63
    2fb0:	cd bf       	out	0x3d, r28	; 61
    2fb2:	cf 91       	pop	r28
    2fb4:	df 91       	pop	r29
    2fb6:	08 95       	ret

00002fb8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2fb8:	df 93       	push	r29
    2fba:	cf 93       	push	r28
    2fbc:	cd b7       	in	r28, 0x3d	; 61
    2fbe:	de b7       	in	r29, 0x3e	; 62
    2fc0:	2c 97       	sbiw	r28, 0x0c	; 12
    2fc2:	0f b6       	in	r0, 0x3f	; 63
    2fc4:	f8 94       	cli
    2fc6:	de bf       	out	0x3e, r29	; 62
    2fc8:	0f be       	out	0x3f, r0	; 63
    2fca:	cd bf       	out	0x3d, r28	; 61
    2fcc:	98 87       	std	Y+8, r25	; 0x08
    2fce:	8f 83       	std	Y+7, r24	; 0x07
    2fd0:	7a 87       	std	Y+10, r23	; 0x0a
    2fd2:	69 87       	std	Y+9, r22	; 0x09
    2fd4:	5c 87       	std	Y+12, r21	; 0x0c
    2fd6:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2fd8:	8f 81       	ldd	r24, Y+7	; 0x07
    2fda:	98 85       	ldd	r25, Y+8	; 0x08
    2fdc:	9c 83       	std	Y+4, r25	; 0x04
    2fde:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2fe0:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2fe2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fe8:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2fea:	8a 81       	ldd	r24, Y+2	; 0x02
    2fec:	88 23       	and	r24, r24
    2fee:	81 f1       	breq	.+96     	; 0x3050 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ff6:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    2ffc:	29 85       	ldd	r18, Y+9	; 0x09
    2ffe:	3a 85       	ldd	r19, Y+10	; 0x0a
    3000:	b9 01       	movw	r22, r18
    3002:	0e 94 80 19 	call	0x3300	; 0x3300 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3006:	8a 81       	ldd	r24, Y+2	; 0x02
    3008:	81 50       	subi	r24, 0x01	; 1
    300a:	eb 81       	ldd	r30, Y+3	; 0x03
    300c:	fc 81       	ldd	r31, Y+4	; 0x04
    300e:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3010:	89 81       	ldd	r24, Y+1	; 0x01
    3012:	8f 3f       	cpi	r24, 0xFF	; 255
    3014:	a9 f4       	brne	.+42     	; 0x3040 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3016:	eb 81       	ldd	r30, Y+3	; 0x03
    3018:	fc 81       	ldd	r31, Y+4	; 0x04
    301a:	80 85       	ldd	r24, Z+8	; 0x08
    301c:	88 23       	and	r24, r24
    301e:	a9 f0       	breq	.+42     	; 0x304a <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3020:	8b 81       	ldd	r24, Y+3	; 0x03
    3022:	9c 81       	ldd	r25, Y+4	; 0x04
    3024:	08 96       	adiw	r24, 0x08	; 8
    3026:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    302a:	88 23       	and	r24, r24
    302c:	71 f0       	breq	.+28     	; 0x304a <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    302e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3030:	9c 85       	ldd	r25, Y+12	; 0x0c
    3032:	00 97       	sbiw	r24, 0x00	; 0
    3034:	51 f0       	breq	.+20     	; 0x304a <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    3036:	eb 85       	ldd	r30, Y+11	; 0x0b
    3038:	fc 85       	ldd	r31, Y+12	; 0x0c
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	80 83       	st	Z, r24
    303e:	05 c0       	rjmp	.+10     	; 0x304a <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	8f 5f       	subi	r24, 0xFF	; 255
    3044:	eb 81       	ldd	r30, Y+3	; 0x03
    3046:	fc 81       	ldd	r31, Y+4	; 0x04
    3048:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	8e 83       	std	Y+6, r24	; 0x06
    304e:	01 c0       	rjmp	.+2      	; 0x3052 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    3050:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3052:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3054:	2c 96       	adiw	r28, 0x0c	; 12
    3056:	0f b6       	in	r0, 0x3f	; 63
    3058:	f8 94       	cli
    305a:	de bf       	out	0x3e, r29	; 62
    305c:	0f be       	out	0x3f, r0	; 63
    305e:	cd bf       	out	0x3d, r28	; 61
    3060:	cf 91       	pop	r28
    3062:	df 91       	pop	r29
    3064:	08 95       	ret

00003066 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3066:	df 93       	push	r29
    3068:	cf 93       	push	r28
    306a:	cd b7       	in	r28, 0x3d	; 61
    306c:	de b7       	in	r29, 0x3e	; 62
    306e:	2a 97       	sbiw	r28, 0x0a	; 10
    3070:	0f b6       	in	r0, 0x3f	; 63
    3072:	f8 94       	cli
    3074:	de bf       	out	0x3e, r29	; 62
    3076:	0f be       	out	0x3f, r0	; 63
    3078:	cd bf       	out	0x3d, r28	; 61
    307a:	98 87       	std	Y+8, r25	; 0x08
    307c:	8f 83       	std	Y+7, r24	; 0x07
    307e:	7a 87       	std	Y+10, r23	; 0x0a
    3080:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3082:	8f 81       	ldd	r24, Y+7	; 0x07
    3084:	98 85       	ldd	r25, Y+8	; 0x08
    3086:	9a 83       	std	Y+2, r25	; 0x02
    3088:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    308a:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    308c:	e9 81       	ldd	r30, Y+1	; 0x01
    308e:	fa 81       	ldd	r31, Y+2	; 0x02
    3090:	82 8d       	ldd	r24, Z+26	; 0x1a
    3092:	88 23       	and	r24, r24
    3094:	b1 f0       	breq	.+44     	; 0x30c2 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3096:	e9 81       	ldd	r30, Y+1	; 0x01
    3098:	fa 81       	ldd	r31, Y+2	; 0x02
    309a:	86 81       	ldd	r24, Z+6	; 0x06
    309c:	97 81       	ldd	r25, Z+7	; 0x07
    309e:	9c 83       	std	Y+4, r25	; 0x04
    30a0:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    30a2:	89 81       	ldd	r24, Y+1	; 0x01
    30a4:	9a 81       	ldd	r25, Y+2	; 0x02
    30a6:	29 85       	ldd	r18, Y+9	; 0x09
    30a8:	3a 85       	ldd	r19, Y+10	; 0x0a
    30aa:	b9 01       	movw	r22, r18
    30ac:	0e 94 80 19 	call	0x3300	; 0x3300 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    30b0:	e9 81       	ldd	r30, Y+1	; 0x01
    30b2:	fa 81       	ldd	r31, Y+2	; 0x02
    30b4:	8b 81       	ldd	r24, Y+3	; 0x03
    30b6:	9c 81       	ldd	r25, Y+4	; 0x04
    30b8:	97 83       	std	Z+7, r25	; 0x07
    30ba:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    30bc:	81 e0       	ldi	r24, 0x01	; 1
    30be:	8e 83       	std	Y+6, r24	; 0x06
    30c0:	01 c0       	rjmp	.+2      	; 0x30c4 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    30c2:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    30c4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    30c6:	2a 96       	adiw	r28, 0x0a	; 10
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	de bf       	out	0x3e, r29	; 62
    30ce:	0f be       	out	0x3f, r0	; 63
    30d0:	cd bf       	out	0x3d, r28	; 61
    30d2:	cf 91       	pop	r28
    30d4:	df 91       	pop	r29
    30d6:	08 95       	ret

000030d8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    30d8:	df 93       	push	r29
    30da:	cf 93       	push	r28
    30dc:	00 d0       	rcall	.+0      	; 0x30de <uxQueueMessagesWaiting+0x6>
    30de:	0f 92       	push	r0
    30e0:	cd b7       	in	r28, 0x3d	; 61
    30e2:	de b7       	in	r29, 0x3e	; 62
    30e4:	9b 83       	std	Y+3, r25	; 0x03
    30e6:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    30e8:	0f b6       	in	r0, 0x3f	; 63
    30ea:	f8 94       	cli
    30ec:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    30ee:	ea 81       	ldd	r30, Y+2	; 0x02
    30f0:	fb 81       	ldd	r31, Y+3	; 0x03
    30f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    30f4:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    30f6:	0f 90       	pop	r0
    30f8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    30fa:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    30fc:	0f 90       	pop	r0
    30fe:	0f 90       	pop	r0
    3100:	0f 90       	pop	r0
    3102:	cf 91       	pop	r28
    3104:	df 91       	pop	r29
    3106:	08 95       	ret

00003108 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3108:	df 93       	push	r29
    310a:	cf 93       	push	r28
    310c:	00 d0       	rcall	.+0      	; 0x310e <uxQueueSpacesAvailable+0x6>
    310e:	00 d0       	rcall	.+0      	; 0x3110 <uxQueueSpacesAvailable+0x8>
    3110:	0f 92       	push	r0
    3112:	cd b7       	in	r28, 0x3d	; 61
    3114:	de b7       	in	r29, 0x3e	; 62
    3116:	9d 83       	std	Y+5, r25	; 0x05
    3118:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    311a:	8c 81       	ldd	r24, Y+4	; 0x04
    311c:	9d 81       	ldd	r25, Y+5	; 0x05
    311e:	9a 83       	std	Y+2, r25	; 0x02
    3120:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3122:	0f b6       	in	r0, 0x3f	; 63
    3124:	f8 94       	cli
    3126:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3128:	e9 81       	ldd	r30, Y+1	; 0x01
    312a:	fa 81       	ldd	r31, Y+2	; 0x02
    312c:	93 8d       	ldd	r25, Z+27	; 0x1b
    312e:	e9 81       	ldd	r30, Y+1	; 0x01
    3130:	fa 81       	ldd	r31, Y+2	; 0x02
    3132:	82 8d       	ldd	r24, Z+26	; 0x1a
    3134:	29 2f       	mov	r18, r25
    3136:	28 1b       	sub	r18, r24
    3138:	82 2f       	mov	r24, r18
    313a:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    313c:	0f 90       	pop	r0
    313e:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3140:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3142:	0f 90       	pop	r0
    3144:	0f 90       	pop	r0
    3146:	0f 90       	pop	r0
    3148:	0f 90       	pop	r0
    314a:	0f 90       	pop	r0
    314c:	cf 91       	pop	r28
    314e:	df 91       	pop	r29
    3150:	08 95       	ret

00003152 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3152:	df 93       	push	r29
    3154:	cf 93       	push	r28
    3156:	00 d0       	rcall	.+0      	; 0x3158 <uxQueueMessagesWaitingFromISR+0x6>
    3158:	00 d0       	rcall	.+0      	; 0x315a <uxQueueMessagesWaitingFromISR+0x8>
    315a:	0f 92       	push	r0
    315c:	cd b7       	in	r28, 0x3d	; 61
    315e:	de b7       	in	r29, 0x3e	; 62
    3160:	9d 83       	std	Y+5, r25	; 0x05
    3162:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3164:	8c 81       	ldd	r24, Y+4	; 0x04
    3166:	9d 81       	ldd	r25, Y+5	; 0x05
    3168:	9a 83       	std	Y+2, r25	; 0x02
    316a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    316c:	e9 81       	ldd	r30, Y+1	; 0x01
    316e:	fa 81       	ldd	r31, Y+2	; 0x02
    3170:	82 8d       	ldd	r24, Z+26	; 0x1a
    3172:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    3174:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3176:	0f 90       	pop	r0
    3178:	0f 90       	pop	r0
    317a:	0f 90       	pop	r0
    317c:	0f 90       	pop	r0
    317e:	0f 90       	pop	r0
    3180:	cf 91       	pop	r28
    3182:	df 91       	pop	r29
    3184:	08 95       	ret

00003186 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3186:	df 93       	push	r29
    3188:	cf 93       	push	r28
    318a:	00 d0       	rcall	.+0      	; 0x318c <vQueueDelete+0x6>
    318c:	00 d0       	rcall	.+0      	; 0x318e <vQueueDelete+0x8>
    318e:	cd b7       	in	r28, 0x3d	; 61
    3190:	de b7       	in	r29, 0x3e	; 62
    3192:	9c 83       	std	Y+4, r25	; 0x04
    3194:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3196:	8b 81       	ldd	r24, Y+3	; 0x03
    3198:	9c 81       	ldd	r25, Y+4	; 0x04
    319a:	9a 83       	std	Y+2, r25	; 0x02
    319c:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    319e:	89 81       	ldd	r24, Y+1	; 0x01
    31a0:	9a 81       	ldd	r25, Y+2	; 0x02
    31a2:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    31a6:	0f 90       	pop	r0
    31a8:	0f 90       	pop	r0
    31aa:	0f 90       	pop	r0
    31ac:	0f 90       	pop	r0
    31ae:	cf 91       	pop	r28
    31b0:	df 91       	pop	r29
    31b2:	08 95       	ret

000031b4 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    31b4:	df 93       	push	r29
    31b6:	cf 93       	push	r28
    31b8:	cd b7       	in	r28, 0x3d	; 61
    31ba:	de b7       	in	r29, 0x3e	; 62
    31bc:	27 97       	sbiw	r28, 0x07	; 7
    31be:	0f b6       	in	r0, 0x3f	; 63
    31c0:	f8 94       	cli
    31c2:	de bf       	out	0x3e, r29	; 62
    31c4:	0f be       	out	0x3f, r0	; 63
    31c6:	cd bf       	out	0x3d, r28	; 61
    31c8:	9c 83       	std	Y+4, r25	; 0x04
    31ca:	8b 83       	std	Y+3, r24	; 0x03
    31cc:	7e 83       	std	Y+6, r23	; 0x06
    31ce:	6d 83       	std	Y+5, r22	; 0x05
    31d0:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    31d2:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    31d4:	eb 81       	ldd	r30, Y+3	; 0x03
    31d6:	fc 81       	ldd	r31, Y+4	; 0x04
    31d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    31da:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    31dc:	eb 81       	ldd	r30, Y+3	; 0x03
    31de:	fc 81       	ldd	r31, Y+4	; 0x04
    31e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    31e2:	88 23       	and	r24, r24
    31e4:	09 f4       	brne	.+2      	; 0x31e8 <prvCopyDataToQueue+0x34>
    31e6:	7d c0       	rjmp	.+250    	; 0x32e2 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    31e8:	8f 81       	ldd	r24, Y+7	; 0x07
    31ea:	88 23       	and	r24, r24
    31ec:	99 f5       	brne	.+102    	; 0x3254 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    31ee:	eb 81       	ldd	r30, Y+3	; 0x03
    31f0:	fc 81       	ldd	r31, Y+4	; 0x04
    31f2:	62 81       	ldd	r22, Z+2	; 0x02
    31f4:	73 81       	ldd	r23, Z+3	; 0x03
    31f6:	eb 81       	ldd	r30, Y+3	; 0x03
    31f8:	fc 81       	ldd	r31, Y+4	; 0x04
    31fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    31fc:	48 2f       	mov	r20, r24
    31fe:	50 e0       	ldi	r21, 0x00	; 0
    3200:	2d 81       	ldd	r18, Y+5	; 0x05
    3202:	3e 81       	ldd	r19, Y+6	; 0x06
    3204:	cb 01       	movw	r24, r22
    3206:	b9 01       	movw	r22, r18
    3208:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    320c:	eb 81       	ldd	r30, Y+3	; 0x03
    320e:	fc 81       	ldd	r31, Y+4	; 0x04
    3210:	22 81       	ldd	r18, Z+2	; 0x02
    3212:	33 81       	ldd	r19, Z+3	; 0x03
    3214:	eb 81       	ldd	r30, Y+3	; 0x03
    3216:	fc 81       	ldd	r31, Y+4	; 0x04
    3218:	84 8d       	ldd	r24, Z+28	; 0x1c
    321a:	88 2f       	mov	r24, r24
    321c:	90 e0       	ldi	r25, 0x00	; 0
    321e:	82 0f       	add	r24, r18
    3220:	93 1f       	adc	r25, r19
    3222:	eb 81       	ldd	r30, Y+3	; 0x03
    3224:	fc 81       	ldd	r31, Y+4	; 0x04
    3226:	93 83       	std	Z+3, r25	; 0x03
    3228:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    322a:	eb 81       	ldd	r30, Y+3	; 0x03
    322c:	fc 81       	ldd	r31, Y+4	; 0x04
    322e:	22 81       	ldd	r18, Z+2	; 0x02
    3230:	33 81       	ldd	r19, Z+3	; 0x03
    3232:	eb 81       	ldd	r30, Y+3	; 0x03
    3234:	fc 81       	ldd	r31, Y+4	; 0x04
    3236:	84 81       	ldd	r24, Z+4	; 0x04
    3238:	95 81       	ldd	r25, Z+5	; 0x05
    323a:	28 17       	cp	r18, r24
    323c:	39 07       	cpc	r19, r25
    323e:	08 f4       	brcc	.+2      	; 0x3242 <prvCopyDataToQueue+0x8e>
    3240:	50 c0       	rjmp	.+160    	; 0x32e2 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3242:	eb 81       	ldd	r30, Y+3	; 0x03
    3244:	fc 81       	ldd	r31, Y+4	; 0x04
    3246:	80 81       	ld	r24, Z
    3248:	91 81       	ldd	r25, Z+1	; 0x01
    324a:	eb 81       	ldd	r30, Y+3	; 0x03
    324c:	fc 81       	ldd	r31, Y+4	; 0x04
    324e:	93 83       	std	Z+3, r25	; 0x03
    3250:	82 83       	std	Z+2, r24	; 0x02
    3252:	47 c0       	rjmp	.+142    	; 0x32e2 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3254:	eb 81       	ldd	r30, Y+3	; 0x03
    3256:	fc 81       	ldd	r31, Y+4	; 0x04
    3258:	66 81       	ldd	r22, Z+6	; 0x06
    325a:	77 81       	ldd	r23, Z+7	; 0x07
    325c:	eb 81       	ldd	r30, Y+3	; 0x03
    325e:	fc 81       	ldd	r31, Y+4	; 0x04
    3260:	84 8d       	ldd	r24, Z+28	; 0x1c
    3262:	48 2f       	mov	r20, r24
    3264:	50 e0       	ldi	r21, 0x00	; 0
    3266:	2d 81       	ldd	r18, Y+5	; 0x05
    3268:	3e 81       	ldd	r19, Y+6	; 0x06
    326a:	cb 01       	movw	r24, r22
    326c:	b9 01       	movw	r22, r18
    326e:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3272:	eb 81       	ldd	r30, Y+3	; 0x03
    3274:	fc 81       	ldd	r31, Y+4	; 0x04
    3276:	26 81       	ldd	r18, Z+6	; 0x06
    3278:	37 81       	ldd	r19, Z+7	; 0x07
    327a:	eb 81       	ldd	r30, Y+3	; 0x03
    327c:	fc 81       	ldd	r31, Y+4	; 0x04
    327e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3280:	88 2f       	mov	r24, r24
    3282:	90 e0       	ldi	r25, 0x00	; 0
    3284:	90 95       	com	r25
    3286:	81 95       	neg	r24
    3288:	9f 4f       	sbci	r25, 0xFF	; 255
    328a:	82 0f       	add	r24, r18
    328c:	93 1f       	adc	r25, r19
    328e:	eb 81       	ldd	r30, Y+3	; 0x03
    3290:	fc 81       	ldd	r31, Y+4	; 0x04
    3292:	97 83       	std	Z+7, r25	; 0x07
    3294:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3296:	eb 81       	ldd	r30, Y+3	; 0x03
    3298:	fc 81       	ldd	r31, Y+4	; 0x04
    329a:	26 81       	ldd	r18, Z+6	; 0x06
    329c:	37 81       	ldd	r19, Z+7	; 0x07
    329e:	eb 81       	ldd	r30, Y+3	; 0x03
    32a0:	fc 81       	ldd	r31, Y+4	; 0x04
    32a2:	80 81       	ld	r24, Z
    32a4:	91 81       	ldd	r25, Z+1	; 0x01
    32a6:	28 17       	cp	r18, r24
    32a8:	39 07       	cpc	r19, r25
    32aa:	90 f4       	brcc	.+36     	; 0x32d0 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    32ac:	eb 81       	ldd	r30, Y+3	; 0x03
    32ae:	fc 81       	ldd	r31, Y+4	; 0x04
    32b0:	24 81       	ldd	r18, Z+4	; 0x04
    32b2:	35 81       	ldd	r19, Z+5	; 0x05
    32b4:	eb 81       	ldd	r30, Y+3	; 0x03
    32b6:	fc 81       	ldd	r31, Y+4	; 0x04
    32b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    32ba:	88 2f       	mov	r24, r24
    32bc:	90 e0       	ldi	r25, 0x00	; 0
    32be:	90 95       	com	r25
    32c0:	81 95       	neg	r24
    32c2:	9f 4f       	sbci	r25, 0xFF	; 255
    32c4:	82 0f       	add	r24, r18
    32c6:	93 1f       	adc	r25, r19
    32c8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ca:	fc 81       	ldd	r31, Y+4	; 0x04
    32cc:	97 83       	std	Z+7, r25	; 0x07
    32ce:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    32d0:	8f 81       	ldd	r24, Y+7	; 0x07
    32d2:	82 30       	cpi	r24, 0x02	; 2
    32d4:	31 f4       	brne	.+12     	; 0x32e2 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    32d6:	89 81       	ldd	r24, Y+1	; 0x01
    32d8:	88 23       	and	r24, r24
    32da:	19 f0       	breq	.+6      	; 0x32e2 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    32dc:	89 81       	ldd	r24, Y+1	; 0x01
    32de:	81 50       	subi	r24, 0x01	; 1
    32e0:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    32e2:	89 81       	ldd	r24, Y+1	; 0x01
    32e4:	8f 5f       	subi	r24, 0xFF	; 255
    32e6:	eb 81       	ldd	r30, Y+3	; 0x03
    32e8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ea:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    32ec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    32ee:	27 96       	adiw	r28, 0x07	; 7
    32f0:	0f b6       	in	r0, 0x3f	; 63
    32f2:	f8 94       	cli
    32f4:	de bf       	out	0x3e, r29	; 62
    32f6:	0f be       	out	0x3f, r0	; 63
    32f8:	cd bf       	out	0x3d, r28	; 61
    32fa:	cf 91       	pop	r28
    32fc:	df 91       	pop	r29
    32fe:	08 95       	ret

00003300 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3300:	df 93       	push	r29
    3302:	cf 93       	push	r28
    3304:	00 d0       	rcall	.+0      	; 0x3306 <prvCopyDataFromQueue+0x6>
    3306:	00 d0       	rcall	.+0      	; 0x3308 <prvCopyDataFromQueue+0x8>
    3308:	cd b7       	in	r28, 0x3d	; 61
    330a:	de b7       	in	r29, 0x3e	; 62
    330c:	9a 83       	std	Y+2, r25	; 0x02
    330e:	89 83       	std	Y+1, r24	; 0x01
    3310:	7c 83       	std	Y+4, r23	; 0x04
    3312:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3314:	e9 81       	ldd	r30, Y+1	; 0x01
    3316:	fa 81       	ldd	r31, Y+2	; 0x02
    3318:	84 8d       	ldd	r24, Z+28	; 0x1c
    331a:	88 23       	and	r24, r24
    331c:	89 f1       	breq	.+98     	; 0x3380 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    331e:	e9 81       	ldd	r30, Y+1	; 0x01
    3320:	fa 81       	ldd	r31, Y+2	; 0x02
    3322:	26 81       	ldd	r18, Z+6	; 0x06
    3324:	37 81       	ldd	r19, Z+7	; 0x07
    3326:	e9 81       	ldd	r30, Y+1	; 0x01
    3328:	fa 81       	ldd	r31, Y+2	; 0x02
    332a:	84 8d       	ldd	r24, Z+28	; 0x1c
    332c:	88 2f       	mov	r24, r24
    332e:	90 e0       	ldi	r25, 0x00	; 0
    3330:	82 0f       	add	r24, r18
    3332:	93 1f       	adc	r25, r19
    3334:	e9 81       	ldd	r30, Y+1	; 0x01
    3336:	fa 81       	ldd	r31, Y+2	; 0x02
    3338:	97 83       	std	Z+7, r25	; 0x07
    333a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    333c:	e9 81       	ldd	r30, Y+1	; 0x01
    333e:	fa 81       	ldd	r31, Y+2	; 0x02
    3340:	26 81       	ldd	r18, Z+6	; 0x06
    3342:	37 81       	ldd	r19, Z+7	; 0x07
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	84 81       	ldd	r24, Z+4	; 0x04
    334a:	95 81       	ldd	r25, Z+5	; 0x05
    334c:	28 17       	cp	r18, r24
    334e:	39 07       	cpc	r19, r25
    3350:	40 f0       	brcs	.+16     	; 0x3362 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3352:	e9 81       	ldd	r30, Y+1	; 0x01
    3354:	fa 81       	ldd	r31, Y+2	; 0x02
    3356:	80 81       	ld	r24, Z
    3358:	91 81       	ldd	r25, Z+1	; 0x01
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	97 83       	std	Z+7, r25	; 0x07
    3360:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3362:	e9 81       	ldd	r30, Y+1	; 0x01
    3364:	fa 81       	ldd	r31, Y+2	; 0x02
    3366:	46 81       	ldd	r20, Z+6	; 0x06
    3368:	57 81       	ldd	r21, Z+7	; 0x07
    336a:	e9 81       	ldd	r30, Y+1	; 0x01
    336c:	fa 81       	ldd	r31, Y+2	; 0x02
    336e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3370:	28 2f       	mov	r18, r24
    3372:	30 e0       	ldi	r19, 0x00	; 0
    3374:	8b 81       	ldd	r24, Y+3	; 0x03
    3376:	9c 81       	ldd	r25, Y+4	; 0x04
    3378:	ba 01       	movw	r22, r20
    337a:	a9 01       	movw	r20, r18
    337c:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>
    }
}
    3380:	0f 90       	pop	r0
    3382:	0f 90       	pop	r0
    3384:	0f 90       	pop	r0
    3386:	0f 90       	pop	r0
    3388:	cf 91       	pop	r28
    338a:	df 91       	pop	r29
    338c:	08 95       	ret

0000338e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    338e:	df 93       	push	r29
    3390:	cf 93       	push	r28
    3392:	00 d0       	rcall	.+0      	; 0x3394 <prvUnlockQueue+0x6>
    3394:	00 d0       	rcall	.+0      	; 0x3396 <prvUnlockQueue+0x8>
    3396:	cd b7       	in	r28, 0x3d	; 61
    3398:	de b7       	in	r29, 0x3e	; 62
    339a:	9c 83       	std	Y+4, r25	; 0x04
    339c:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    339e:	0f b6       	in	r0, 0x3f	; 63
    33a0:	f8 94       	cli
    33a2:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    33a4:	eb 81       	ldd	r30, Y+3	; 0x03
    33a6:	fc 81       	ldd	r31, Y+4	; 0x04
    33a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    33aa:	8a 83       	std	Y+2, r24	; 0x02
    33ac:	11 c0       	rjmp	.+34     	; 0x33d0 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33ae:	eb 81       	ldd	r30, Y+3	; 0x03
    33b0:	fc 81       	ldd	r31, Y+4	; 0x04
    33b2:	81 89       	ldd	r24, Z+17	; 0x11
    33b4:	88 23       	and	r24, r24
    33b6:	79 f0       	breq	.+30     	; 0x33d6 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33b8:	8b 81       	ldd	r24, Y+3	; 0x03
    33ba:	9c 81       	ldd	r25, Y+4	; 0x04
    33bc:	41 96       	adiw	r24, 0x11	; 17
    33be:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    33c2:	88 23       	and	r24, r24
    33c4:	11 f0       	breq	.+4      	; 0x33ca <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    33c6:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    33ca:	8a 81       	ldd	r24, Y+2	; 0x02
    33cc:	81 50       	subi	r24, 0x01	; 1
    33ce:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    33d0:	8a 81       	ldd	r24, Y+2	; 0x02
    33d2:	18 16       	cp	r1, r24
    33d4:	64 f3       	brlt	.-40     	; 0x33ae <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    33d6:	eb 81       	ldd	r30, Y+3	; 0x03
    33d8:	fc 81       	ldd	r31, Y+4	; 0x04
    33da:	8f ef       	ldi	r24, 0xFF	; 255
    33dc:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    33de:	0f 90       	pop	r0
    33e0:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    33e2:	0f b6       	in	r0, 0x3f	; 63
    33e4:	f8 94       	cli
    33e6:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    33e8:	eb 81       	ldd	r30, Y+3	; 0x03
    33ea:	fc 81       	ldd	r31, Y+4	; 0x04
    33ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    33ee:	89 83       	std	Y+1, r24	; 0x01
    33f0:	11 c0       	rjmp	.+34     	; 0x3414 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    33f2:	eb 81       	ldd	r30, Y+3	; 0x03
    33f4:	fc 81       	ldd	r31, Y+4	; 0x04
    33f6:	80 85       	ldd	r24, Z+8	; 0x08
    33f8:	88 23       	and	r24, r24
    33fa:	79 f0       	breq	.+30     	; 0x341a <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    33fc:	8b 81       	ldd	r24, Y+3	; 0x03
    33fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3400:	08 96       	adiw	r24, 0x08	; 8
    3402:	0e 94 0b 2a 	call	0x5416	; 0x5416 <xTaskRemoveFromEventList>
    3406:	88 23       	and	r24, r24
    3408:	11 f0       	breq	.+4      	; 0x340e <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    340a:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    340e:	89 81       	ldd	r24, Y+1	; 0x01
    3410:	81 50       	subi	r24, 0x01	; 1
    3412:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3414:	89 81       	ldd	r24, Y+1	; 0x01
    3416:	18 16       	cp	r1, r24
    3418:	64 f3       	brlt	.-40     	; 0x33f2 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    341a:	eb 81       	ldd	r30, Y+3	; 0x03
    341c:	fc 81       	ldd	r31, Y+4	; 0x04
    341e:	8f ef       	ldi	r24, 0xFF	; 255
    3420:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3422:	0f 90       	pop	r0
    3424:	0f be       	out	0x3f, r0	; 63
}
    3426:	0f 90       	pop	r0
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	cf 91       	pop	r28
    3430:	df 91       	pop	r29
    3432:	08 95       	ret

00003434 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3434:	df 93       	push	r29
    3436:	cf 93       	push	r28
    3438:	00 d0       	rcall	.+0      	; 0x343a <prvIsQueueEmpty+0x6>
    343a:	0f 92       	push	r0
    343c:	cd b7       	in	r28, 0x3d	; 61
    343e:	de b7       	in	r29, 0x3e	; 62
    3440:	9b 83       	std	Y+3, r25	; 0x03
    3442:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    344a:	ea 81       	ldd	r30, Y+2	; 0x02
    344c:	fb 81       	ldd	r31, Y+3	; 0x03
    344e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3450:	88 23       	and	r24, r24
    3452:	19 f4       	brne	.+6      	; 0x345a <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    3454:	81 e0       	ldi	r24, 0x01	; 1
    3456:	89 83       	std	Y+1, r24	; 0x01
    3458:	01 c0       	rjmp	.+2      	; 0x345c <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    345a:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    345c:	0f 90       	pop	r0
    345e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3460:	89 81       	ldd	r24, Y+1	; 0x01
}
    3462:	0f 90       	pop	r0
    3464:	0f 90       	pop	r0
    3466:	0f 90       	pop	r0
    3468:	cf 91       	pop	r28
    346a:	df 91       	pop	r29
    346c:	08 95       	ret

0000346e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    346e:	df 93       	push	r29
    3470:	cf 93       	push	r28
    3472:	00 d0       	rcall	.+0      	; 0x3474 <xQueueIsQueueEmptyFromISR+0x6>
    3474:	00 d0       	rcall	.+0      	; 0x3476 <xQueueIsQueueEmptyFromISR+0x8>
    3476:	0f 92       	push	r0
    3478:	cd b7       	in	r28, 0x3d	; 61
    347a:	de b7       	in	r29, 0x3e	; 62
    347c:	9d 83       	std	Y+5, r25	; 0x05
    347e:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    3480:	8c 81       	ldd	r24, Y+4	; 0x04
    3482:	9d 81       	ldd	r25, Y+5	; 0x05
    3484:	9a 83       	std	Y+2, r25	; 0x02
    3486:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3488:	e9 81       	ldd	r30, Y+1	; 0x01
    348a:	fa 81       	ldd	r31, Y+2	; 0x02
    348c:	82 8d       	ldd	r24, Z+26	; 0x1a
    348e:	88 23       	and	r24, r24
    3490:	19 f4       	brne	.+6      	; 0x3498 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    3492:	81 e0       	ldi	r24, 0x01	; 1
    3494:	8b 83       	std	Y+3, r24	; 0x03
    3496:	01 c0       	rjmp	.+2      	; 0x349a <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    3498:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	0f 90       	pop	r0
    34a2:	0f 90       	pop	r0
    34a4:	0f 90       	pop	r0
    34a6:	cf 91       	pop	r28
    34a8:	df 91       	pop	r29
    34aa:	08 95       	ret

000034ac <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    34ac:	df 93       	push	r29
    34ae:	cf 93       	push	r28
    34b0:	00 d0       	rcall	.+0      	; 0x34b2 <prvIsQueueFull+0x6>
    34b2:	0f 92       	push	r0
    34b4:	cd b7       	in	r28, 0x3d	; 61
    34b6:	de b7       	in	r29, 0x3e	; 62
    34b8:	9b 83       	std	Y+3, r25	; 0x03
    34ba:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    34bc:	0f b6       	in	r0, 0x3f	; 63
    34be:	f8 94       	cli
    34c0:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    34c2:	ea 81       	ldd	r30, Y+2	; 0x02
    34c4:	fb 81       	ldd	r31, Y+3	; 0x03
    34c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    34c8:	ea 81       	ldd	r30, Y+2	; 0x02
    34ca:	fb 81       	ldd	r31, Y+3	; 0x03
    34cc:	83 8d       	ldd	r24, Z+27	; 0x1b
    34ce:	98 17       	cp	r25, r24
    34d0:	19 f4       	brne	.+6      	; 0x34d8 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    34d2:	81 e0       	ldi	r24, 0x01	; 1
    34d4:	89 83       	std	Y+1, r24	; 0x01
    34d6:	01 c0       	rjmp	.+2      	; 0x34da <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    34d8:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    34da:	0f 90       	pop	r0
    34dc:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    34de:	89 81       	ldd	r24, Y+1	; 0x01
}
    34e0:	0f 90       	pop	r0
    34e2:	0f 90       	pop	r0
    34e4:	0f 90       	pop	r0
    34e6:	cf 91       	pop	r28
    34e8:	df 91       	pop	r29
    34ea:	08 95       	ret

000034ec <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    34ec:	df 93       	push	r29
    34ee:	cf 93       	push	r28
    34f0:	00 d0       	rcall	.+0      	; 0x34f2 <xQueueIsQueueFullFromISR+0x6>
    34f2:	00 d0       	rcall	.+0      	; 0x34f4 <xQueueIsQueueFullFromISR+0x8>
    34f4:	0f 92       	push	r0
    34f6:	cd b7       	in	r28, 0x3d	; 61
    34f8:	de b7       	in	r29, 0x3e	; 62
    34fa:	9d 83       	std	Y+5, r25	; 0x05
    34fc:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    34fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3500:	9d 81       	ldd	r25, Y+5	; 0x05
    3502:	9a 83       	std	Y+2, r25	; 0x02
    3504:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3506:	e9 81       	ldd	r30, Y+1	; 0x01
    3508:	fa 81       	ldd	r31, Y+2	; 0x02
    350a:	92 8d       	ldd	r25, Z+26	; 0x1a
    350c:	e9 81       	ldd	r30, Y+1	; 0x01
    350e:	fa 81       	ldd	r31, Y+2	; 0x02
    3510:	83 8d       	ldd	r24, Z+27	; 0x1b
    3512:	98 17       	cp	r25, r24
    3514:	19 f4       	brne	.+6      	; 0x351c <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    3516:	81 e0       	ldi	r24, 0x01	; 1
    3518:	8b 83       	std	Y+3, r24	; 0x03
    351a:	01 c0       	rjmp	.+2      	; 0x351e <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    351c:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    351e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3520:	0f 90       	pop	r0
    3522:	0f 90       	pop	r0
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	cf 91       	pop	r28
    352c:	df 91       	pop	r29
    352e:	08 95       	ret

00003530 <xStreamBufferGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
    3530:	0f 93       	push	r16
    3532:	df 93       	push	r29
    3534:	cf 93       	push	r28
    3536:	cd b7       	in	r28, 0x3d	; 61
    3538:	de b7       	in	r29, 0x3e	; 62
    353a:	28 97       	sbiw	r28, 0x08	; 8
    353c:	0f b6       	in	r0, 0x3f	; 63
    353e:	f8 94       	cli
    3540:	de bf       	out	0x3e, r29	; 62
    3542:	0f be       	out	0x3f, r0	; 63
    3544:	cd bf       	out	0x3d, r28	; 61
    3546:	9d 83       	std	Y+5, r25	; 0x05
    3548:	8c 83       	std	Y+4, r24	; 0x04
    354a:	7f 83       	std	Y+7, r23	; 0x07
    354c:	6e 83       	std	Y+6, r22	; 0x06
    354e:	48 87       	std	Y+8, r20	; 0x08

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    3550:	88 85       	ldd	r24, Y+8	; 0x08
    3552:	81 30       	cpi	r24, 0x01	; 1
    3554:	19 f4       	brne	.+6      	; 0x355c <xStreamBufferGenericCreate+0x2c>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3556:	81 e0       	ldi	r24, 0x01	; 1
    3558:	89 83       	std	Y+1, r24	; 0x01
    355a:	01 c0       	rjmp	.+2      	; 0x355e <xStreamBufferGenericCreate+0x2e>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    355c:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    355e:	8e 81       	ldd	r24, Y+6	; 0x06
    3560:	9f 81       	ldd	r25, Y+7	; 0x07
    3562:	00 97       	sbiw	r24, 0x00	; 0
    3564:	21 f4       	brne	.+8      	; 0x356e <xStreamBufferGenericCreate+0x3e>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    3566:	81 e0       	ldi	r24, 0x01	; 1
    3568:	90 e0       	ldi	r25, 0x00	; 0
    356a:	9f 83       	std	Y+7, r25	; 0x07
    356c:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    356e:	8c 81       	ldd	r24, Y+4	; 0x04
    3570:	9d 81       	ldd	r25, Y+5	; 0x05
    3572:	9c 01       	movw	r18, r24
    3574:	20 5f       	subi	r18, 0xF0	; 240
    3576:	3f 4f       	sbci	r19, 0xFF	; 255
    3578:	8c 81       	ldd	r24, Y+4	; 0x04
    357a:	9d 81       	ldd	r25, Y+5	; 0x05
    357c:	82 17       	cp	r24, r18
    357e:	93 07       	cpc	r25, r19
    3580:	68 f4       	brcc	.+26     	; 0x359c <xStreamBufferGenericCreate+0x6c>
        {
            xBufferSizeBytes++;
    3582:	8c 81       	ldd	r24, Y+4	; 0x04
    3584:	9d 81       	ldd	r25, Y+5	; 0x05
    3586:	01 96       	adiw	r24, 0x01	; 1
    3588:	9d 83       	std	Y+5, r25	; 0x05
    358a:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    358c:	8c 81       	ldd	r24, Y+4	; 0x04
    358e:	9d 81       	ldd	r25, Y+5	; 0x05
    3590:	0f 96       	adiw	r24, 0x0f	; 15
    3592:	0e 94 77 0e 	call	0x1cee	; 0x1cee <pvPortMalloc>
    3596:	9b 83       	std	Y+3, r25	; 0x03
    3598:	8a 83       	std	Y+2, r24	; 0x02
    359a:	02 c0       	rjmp	.+4      	; 0x35a0 <xStreamBufferGenericCreate+0x70>
        }
        else
        {
            pucAllocatedMemory = NULL;
    359c:	1b 82       	std	Y+3, r1	; 0x03
    359e:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    35a0:	8a 81       	ldd	r24, Y+2	; 0x02
    35a2:	9b 81       	ldd	r25, Y+3	; 0x03
    35a4:	00 97       	sbiw	r24, 0x00	; 0
    35a6:	89 f0       	breq	.+34     	; 0x35ca <xStreamBufferGenericCreate+0x9a>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    35a8:	6a 81       	ldd	r22, Y+2	; 0x02
    35aa:	7b 81       	ldd	r23, Y+3	; 0x03
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	9b 81       	ldd	r25, Y+3	; 0x03
    35b0:	9c 01       	movw	r18, r24
    35b2:	21 5f       	subi	r18, 0xF1	; 241
    35b4:	3f 4f       	sbci	r19, 0xFF	; 255
    35b6:	4c 81       	ldd	r20, Y+4	; 0x04
    35b8:	5d 81       	ldd	r21, Y+5	; 0x05
    35ba:	ee 81       	ldd	r30, Y+6	; 0x06
    35bc:	ff 81       	ldd	r31, Y+7	; 0x07
    35be:	cb 01       	movw	r24, r22
    35c0:	b9 01       	movw	r22, r18
    35c2:	9f 01       	movw	r18, r30
    35c4:	09 81       	ldd	r16, Y+1	; 0x01
    35c6:	0e 94 20 22 	call	0x4440	; 0x4440 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    35ca:	8a 81       	ldd	r24, Y+2	; 0x02
    35cc:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    35ce:	28 96       	adiw	r28, 0x08	; 8
    35d0:	0f b6       	in	r0, 0x3f	; 63
    35d2:	f8 94       	cli
    35d4:	de bf       	out	0x3e, r29	; 62
    35d6:	0f be       	out	0x3f, r0	; 63
    35d8:	cd bf       	out	0x3d, r28	; 61
    35da:	cf 91       	pop	r28
    35dc:	df 91       	pop	r29
    35de:	0f 91       	pop	r16
    35e0:	08 95       	ret

000035e2 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    35e2:	df 93       	push	r29
    35e4:	cf 93       	push	r28
    35e6:	00 d0       	rcall	.+0      	; 0x35e8 <vStreamBufferDelete+0x6>
    35e8:	00 d0       	rcall	.+0      	; 0x35ea <vStreamBufferDelete+0x8>
    35ea:	cd b7       	in	r28, 0x3d	; 61
    35ec:	de b7       	in	r29, 0x3e	; 62
    35ee:	9c 83       	std	Y+4, r25	; 0x04
    35f0:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    35f2:	8b 81       	ldd	r24, Y+3	; 0x03
    35f4:	9c 81       	ldd	r25, Y+4	; 0x04
    35f6:	9a 83       	std	Y+2, r25	; 0x02
    35f8:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    35fa:	e9 81       	ldd	r30, Y+1	; 0x01
    35fc:	fa 81       	ldd	r31, Y+2	; 0x02
    35fe:	86 85       	ldd	r24, Z+14	; 0x0e
    3600:	88 2f       	mov	r24, r24
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	82 70       	andi	r24, 0x02	; 2
    3606:	90 70       	andi	r25, 0x00	; 0
    3608:	00 97       	sbiw	r24, 0x00	; 0
    360a:	29 f4       	brne	.+10     	; 0x3616 <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
            {
                /* Both the structure and the buffer were allocated using a single call
                * to pvPortMalloc(), hence only one call to vPortFree() is required. */
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    360c:	89 81       	ldd	r24, Y+1	; 0x01
    360e:	9a 81       	ldd	r25, Y+2	; 0x02
    3610:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
    3614:	08 c0       	rjmp	.+16     	; 0x3626 <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3616:	89 81       	ldd	r24, Y+1	; 0x01
    3618:	9a 81       	ldd	r25, Y+2	; 0x02
    361a:	60 e0       	ldi	r22, 0x00	; 0
    361c:	70 e0       	ldi	r23, 0x00	; 0
    361e:	4f e0       	ldi	r20, 0x0F	; 15
    3620:	50 e0       	ldi	r21, 0x00	; 0
    3622:	0e 94 df 42 	call	0x85be	; 0x85be <memset>
    }
}
    3626:	0f 90       	pop	r0
    3628:	0f 90       	pop	r0
    362a:	0f 90       	pop	r0
    362c:	0f 90       	pop	r0
    362e:	cf 91       	pop	r28
    3630:	df 91       	pop	r29
    3632:	08 95       	ret

00003634 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3634:	0f 93       	push	r16
    3636:	df 93       	push	r29
    3638:	cf 93       	push	r28
    363a:	00 d0       	rcall	.+0      	; 0x363c <xStreamBufferReset+0x8>
    363c:	00 d0       	rcall	.+0      	; 0x363e <xStreamBufferReset+0xa>
    363e:	0f 92       	push	r0
    3640:	cd b7       	in	r28, 0x3d	; 61
    3642:	de b7       	in	r29, 0x3e	; 62
    3644:	9d 83       	std	Y+5, r25	; 0x05
    3646:	8c 83       	std	Y+4, r24	; 0x04
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3648:	8c 81       	ldd	r24, Y+4	; 0x04
    364a:	9d 81       	ldd	r25, Y+5	; 0x05
    364c:	9b 83       	std	Y+3, r25	; 0x03
    364e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn = pdFAIL;
    3650:	19 82       	std	Y+1, r1	; 0x01
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
        }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	f8 94       	cli
    3656:	0f 92       	push	r0
    {
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3658:	ea 81       	ldd	r30, Y+2	; 0x02
    365a:	fb 81       	ldd	r31, Y+3	; 0x03
    365c:	80 85       	ldd	r24, Z+8	; 0x08
    365e:	91 85       	ldd	r25, Z+9	; 0x09
    3660:	00 97       	sbiw	r24, 0x00	; 0
    3662:	f1 f4       	brne	.+60     	; 0x36a0 <xStreamBufferReset+0x6c>
        {
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3664:	ea 81       	ldd	r30, Y+2	; 0x02
    3666:	fb 81       	ldd	r31, Y+3	; 0x03
    3668:	82 85       	ldd	r24, Z+10	; 0x0a
    366a:	93 85       	ldd	r25, Z+11	; 0x0b
    366c:	00 97       	sbiw	r24, 0x00	; 0
    366e:	c1 f4       	brne	.+48     	; 0x36a0 <xStreamBufferReset+0x6c>
            {
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3670:	ea 81       	ldd	r30, Y+2	; 0x02
    3672:	fb 81       	ldd	r31, Y+3	; 0x03
    3674:	24 85       	ldd	r18, Z+12	; 0x0c
    3676:	35 85       	ldd	r19, Z+13	; 0x0d
    3678:	ea 81       	ldd	r30, Y+2	; 0x02
    367a:	fb 81       	ldd	r31, Y+3	; 0x03
    367c:	44 81       	ldd	r20, Z+4	; 0x04
    367e:	55 81       	ldd	r21, Z+5	; 0x05
    3680:	ea 81       	ldd	r30, Y+2	; 0x02
    3682:	fb 81       	ldd	r31, Y+3	; 0x03
    3684:	a6 81       	ldd	r26, Z+6	; 0x06
    3686:	b7 81       	ldd	r27, Z+7	; 0x07
    3688:	ea 81       	ldd	r30, Y+2	; 0x02
    368a:	fb 81       	ldd	r31, Y+3	; 0x03
    368c:	e6 85       	ldd	r30, Z+14	; 0x0e
    368e:	8a 81       	ldd	r24, Y+2	; 0x02
    3690:	9b 81       	ldd	r25, Y+3	; 0x03
    3692:	b9 01       	movw	r22, r18
    3694:	9d 01       	movw	r18, r26
    3696:	0e 2f       	mov	r16, r30
    3698:	0e 94 20 22 	call	0x4440	; 0x4440 <prvInitialiseNewStreamBuffer>
                                              pxStreamBuffer->pucBuffer,
                                              pxStreamBuffer->xLength,
                                              pxStreamBuffer->xTriggerLevelBytes,
                                              pxStreamBuffer->ucFlags );
                xReturn = pdPASS;
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	89 83       	std	Y+1, r24	; 0x01

                traceSTREAM_BUFFER_RESET( xStreamBuffer );
            }
        }
    }
    taskEXIT_CRITICAL();
    36a0:	0f 90       	pop	r0
    36a2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    36a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    36a6:	0f 90       	pop	r0
    36a8:	0f 90       	pop	r0
    36aa:	0f 90       	pop	r0
    36ac:	0f 90       	pop	r0
    36ae:	0f 90       	pop	r0
    36b0:	cf 91       	pop	r28
    36b2:	df 91       	pop	r29
    36b4:	0f 91       	pop	r16
    36b6:	08 95       	ret

000036b8 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    36b8:	df 93       	push	r29
    36ba:	cf 93       	push	r28
    36bc:	cd b7       	in	r28, 0x3d	; 61
    36be:	de b7       	in	r29, 0x3e	; 62
    36c0:	27 97       	sbiw	r28, 0x07	; 7
    36c2:	0f b6       	in	r0, 0x3f	; 63
    36c4:	f8 94       	cli
    36c6:	de bf       	out	0x3e, r29	; 62
    36c8:	0f be       	out	0x3f, r0	; 63
    36ca:	cd bf       	out	0x3d, r28	; 61
    36cc:	9d 83       	std	Y+5, r25	; 0x05
    36ce:	8c 83       	std	Y+4, r24	; 0x04
    36d0:	7f 83       	std	Y+7, r23	; 0x07
    36d2:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    36d4:	8c 81       	ldd	r24, Y+4	; 0x04
    36d6:	9d 81       	ldd	r25, Y+5	; 0x05
    36d8:	9b 83       	std	Y+3, r25	; 0x03
    36da:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    36dc:	8e 81       	ldd	r24, Y+6	; 0x06
    36de:	9f 81       	ldd	r25, Y+7	; 0x07
    36e0:	00 97       	sbiw	r24, 0x00	; 0
    36e2:	21 f4       	brne	.+8      	; 0x36ec <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	9f 83       	std	Y+7, r25	; 0x07
    36ea:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    36ec:	ea 81       	ldd	r30, Y+2	; 0x02
    36ee:	fb 81       	ldd	r31, Y+3	; 0x03
    36f0:	24 81       	ldd	r18, Z+4	; 0x04
    36f2:	35 81       	ldd	r19, Z+5	; 0x05
    36f4:	8e 81       	ldd	r24, Y+6	; 0x06
    36f6:	9f 81       	ldd	r25, Y+7	; 0x07
    36f8:	82 17       	cp	r24, r18
    36fa:	93 07       	cpc	r25, r19
    36fc:	48 f4       	brcc	.+18     	; 0x3710 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    36fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3700:	fb 81       	ldd	r31, Y+3	; 0x03
    3702:	8e 81       	ldd	r24, Y+6	; 0x06
    3704:	9f 81       	ldd	r25, Y+7	; 0x07
    3706:	97 83       	std	Z+7, r25	; 0x07
    3708:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    370a:	81 e0       	ldi	r24, 0x01	; 1
    370c:	89 83       	std	Y+1, r24	; 0x01
    370e:	01 c0       	rjmp	.+2      	; 0x3712 <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    3710:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    3712:	89 81       	ldd	r24, Y+1	; 0x01
}
    3714:	27 96       	adiw	r28, 0x07	; 7
    3716:	0f b6       	in	r0, 0x3f	; 63
    3718:	f8 94       	cli
    371a:	de bf       	out	0x3e, r29	; 62
    371c:	0f be       	out	0x3f, r0	; 63
    371e:	cd bf       	out	0x3d, r28	; 61
    3720:	cf 91       	pop	r28
    3722:	df 91       	pop	r29
    3724:	08 95       	ret

00003726 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3726:	df 93       	push	r29
    3728:	cf 93       	push	r28
    372a:	cd b7       	in	r28, 0x3d	; 61
    372c:	de b7       	in	r29, 0x3e	; 62
    372e:	28 97       	sbiw	r28, 0x08	; 8
    3730:	0f b6       	in	r0, 0x3f	; 63
    3732:	f8 94       	cli
    3734:	de bf       	out	0x3e, r29	; 62
    3736:	0f be       	out	0x3f, r0	; 63
    3738:	cd bf       	out	0x3d, r28	; 61
    373a:	98 87       	std	Y+8, r25	; 0x08
    373c:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    373e:	8f 81       	ldd	r24, Y+7	; 0x07
    3740:	98 85       	ldd	r25, Y+8	; 0x08
    3742:	9e 83       	std	Y+6, r25	; 0x06
    3744:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    3746:	ed 81       	ldd	r30, Y+5	; 0x05
    3748:	fe 81       	ldd	r31, Y+6	; 0x06
    374a:	80 81       	ld	r24, Z
    374c:	91 81       	ldd	r25, Z+1	; 0x01
    374e:	9a 83       	std	Y+2, r25	; 0x02
    3750:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3752:	ed 81       	ldd	r30, Y+5	; 0x05
    3754:	fe 81       	ldd	r31, Y+6	; 0x06
    3756:	24 81       	ldd	r18, Z+4	; 0x04
    3758:	35 81       	ldd	r19, Z+5	; 0x05
    375a:	ed 81       	ldd	r30, Y+5	; 0x05
    375c:	fe 81       	ldd	r31, Y+6	; 0x06
    375e:	80 81       	ld	r24, Z
    3760:	91 81       	ldd	r25, Z+1	; 0x01
    3762:	82 0f       	add	r24, r18
    3764:	93 1f       	adc	r25, r19
    3766:	9c 83       	std	Y+4, r25	; 0x04
    3768:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    376a:	ed 81       	ldd	r30, Y+5	; 0x05
    376c:	fe 81       	ldd	r31, Y+6	; 0x06
    376e:	22 81       	ldd	r18, Z+2	; 0x02
    3770:	33 81       	ldd	r19, Z+3	; 0x03
    3772:	8b 81       	ldd	r24, Y+3	; 0x03
    3774:	9c 81       	ldd	r25, Y+4	; 0x04
    3776:	82 1b       	sub	r24, r18
    3778:	93 0b       	sbc	r25, r19
    377a:	9c 83       	std	Y+4, r25	; 0x04
    377c:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    377e:	ed 81       	ldd	r30, Y+5	; 0x05
    3780:	fe 81       	ldd	r31, Y+6	; 0x06
    3782:	20 81       	ld	r18, Z
    3784:	31 81       	ldd	r19, Z+1	; 0x01
    3786:	89 81       	ldd	r24, Y+1	; 0x01
    3788:	9a 81       	ldd	r25, Y+2	; 0x02
    378a:	28 17       	cp	r18, r24
    378c:	39 07       	cpc	r19, r25
    378e:	d9 f6       	brne	.-74     	; 0x3746 <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    3790:	8b 81       	ldd	r24, Y+3	; 0x03
    3792:	9c 81       	ldd	r25, Y+4	; 0x04
    3794:	01 97       	sbiw	r24, 0x01	; 1
    3796:	9c 83       	std	Y+4, r25	; 0x04
    3798:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    379a:	ed 81       	ldd	r30, Y+5	; 0x05
    379c:	fe 81       	ldd	r31, Y+6	; 0x06
    379e:	24 81       	ldd	r18, Z+4	; 0x04
    37a0:	35 81       	ldd	r19, Z+5	; 0x05
    37a2:	8b 81       	ldd	r24, Y+3	; 0x03
    37a4:	9c 81       	ldd	r25, Y+4	; 0x04
    37a6:	82 17       	cp	r24, r18
    37a8:	93 07       	cpc	r25, r19
    37aa:	50 f0       	brcs	.+20     	; 0x37c0 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    37ac:	ed 81       	ldd	r30, Y+5	; 0x05
    37ae:	fe 81       	ldd	r31, Y+6	; 0x06
    37b0:	24 81       	ldd	r18, Z+4	; 0x04
    37b2:	35 81       	ldd	r19, Z+5	; 0x05
    37b4:	8b 81       	ldd	r24, Y+3	; 0x03
    37b6:	9c 81       	ldd	r25, Y+4	; 0x04
    37b8:	82 1b       	sub	r24, r18
    37ba:	93 0b       	sbc	r25, r19
    37bc:	9c 83       	std	Y+4, r25	; 0x04
    37be:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    37c0:	8b 81       	ldd	r24, Y+3	; 0x03
    37c2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    37c4:	28 96       	adiw	r28, 0x08	; 8
    37c6:	0f b6       	in	r0, 0x3f	; 63
    37c8:	f8 94       	cli
    37ca:	de bf       	out	0x3e, r29	; 62
    37cc:	0f be       	out	0x3f, r0	; 63
    37ce:	cd bf       	out	0x3d, r28	; 61
    37d0:	cf 91       	pop	r28
    37d2:	df 91       	pop	r29
    37d4:	08 95       	ret

000037d6 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    37d6:	df 93       	push	r29
    37d8:	cf 93       	push	r28
    37da:	00 d0       	rcall	.+0      	; 0x37dc <xStreamBufferBytesAvailable+0x6>
    37dc:	00 d0       	rcall	.+0      	; 0x37de <xStreamBufferBytesAvailable+0x8>
    37de:	00 d0       	rcall	.+0      	; 0x37e0 <xStreamBufferBytesAvailable+0xa>
    37e0:	cd b7       	in	r28, 0x3d	; 61
    37e2:	de b7       	in	r29, 0x3e	; 62
    37e4:	9e 83       	std	Y+6, r25	; 0x06
    37e6:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37e8:	8d 81       	ldd	r24, Y+5	; 0x05
    37ea:	9e 81       	ldd	r25, Y+6	; 0x06
    37ec:	9c 83       	std	Y+4, r25	; 0x04
    37ee:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    37f0:	8b 81       	ldd	r24, Y+3	; 0x03
    37f2:	9c 81       	ldd	r25, Y+4	; 0x04
    37f4:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    37f8:	9a 83       	std	Y+2, r25	; 0x02
    37fa:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    37fc:	89 81       	ldd	r24, Y+1	; 0x01
    37fe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3800:	26 96       	adiw	r28, 0x06	; 6
    3802:	0f b6       	in	r0, 0x3f	; 63
    3804:	f8 94       	cli
    3806:	de bf       	out	0x3e, r29	; 62
    3808:	0f be       	out	0x3f, r0	; 63
    380a:	cd bf       	out	0x3d, r28	; 61
    380c:	cf 91       	pop	r28
    380e:	df 91       	pop	r29
    3810:	08 95       	ret

00003812 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    3812:	cf 92       	push	r12
    3814:	df 92       	push	r13
    3816:	ef 92       	push	r14
    3818:	ff 92       	push	r15
    381a:	0f 93       	push	r16
    381c:	1f 93       	push	r17
    381e:	df 93       	push	r29
    3820:	cf 93       	push	r28
    3822:	cd b7       	in	r28, 0x3d	; 61
    3824:	de b7       	in	r29, 0x3e	; 62
    3826:	65 97       	sbiw	r28, 0x15	; 21
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	f8 94       	cli
    382c:	de bf       	out	0x3e, r29	; 62
    382e:	0f be       	out	0x3f, r0	; 63
    3830:	cd bf       	out	0x3d, r28	; 61
    3832:	9f 87       	std	Y+15, r25	; 0x0f
    3834:	8e 87       	std	Y+14, r24	; 0x0e
    3836:	79 8b       	std	Y+17, r23	; 0x11
    3838:	68 8b       	std	Y+16, r22	; 0x10
    383a:	5b 8b       	std	Y+19, r21	; 0x13
    383c:	4a 8b       	std	Y+18, r20	; 0x12
    383e:	3d 8b       	std	Y+21, r19	; 0x15
    3840:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3842:	8e 85       	ldd	r24, Y+14	; 0x0e
    3844:	9f 85       	ldd	r25, Y+15	; 0x0f
    3846:	9a 87       	std	Y+10, r25	; 0x0a
    3848:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    384a:	1e 82       	std	Y+6, r1	; 0x06
    384c:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    384e:	8a 89       	ldd	r24, Y+18	; 0x12
    3850:	9b 89       	ldd	r25, Y+19	; 0x13
    3852:	9c 83       	std	Y+4, r25	; 0x04
    3854:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    3856:	1a 82       	std	Y+2, r1	; 0x02
    3858:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    385a:	e9 85       	ldd	r30, Y+9	; 0x09
    385c:	fa 85       	ldd	r31, Y+10	; 0x0a
    385e:	84 81       	ldd	r24, Z+4	; 0x04
    3860:	95 81       	ldd	r25, Z+5	; 0x05
    3862:	01 97       	sbiw	r24, 0x01	; 1
    3864:	9a 83       	std	Y+2, r25	; 0x02
    3866:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3868:	e9 85       	ldd	r30, Y+9	; 0x09
    386a:	fa 85       	ldd	r31, Y+10	; 0x0a
    386c:	86 85       	ldd	r24, Z+14	; 0x0e
    386e:	88 2f       	mov	r24, r24
    3870:	90 e0       	ldi	r25, 0x00	; 0
    3872:	81 70       	andi	r24, 0x01	; 1
    3874:	90 70       	andi	r25, 0x00	; 0
    3876:	88 23       	and	r24, r24
    3878:	79 f0       	breq	.+30     	; 0x3898 <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	02 96       	adiw	r24, 0x02	; 2
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    3884:	2b 81       	ldd	r18, Y+3	; 0x03
    3886:	3c 81       	ldd	r19, Y+4	; 0x04
    3888:	89 81       	ldd	r24, Y+1	; 0x01
    388a:	9a 81       	ldd	r25, Y+2	; 0x02
    388c:	82 17       	cp	r24, r18
    388e:	93 07       	cpc	r25, r19
    3890:	70 f4       	brcc	.+28     	; 0x38ae <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    3892:	1d 8a       	std	Y+21, r1	; 0x15
    3894:	1c 8a       	std	Y+20, r1	; 0x14
    3896:	0b c0       	rjmp	.+22     	; 0x38ae <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    3898:	2b 81       	ldd	r18, Y+3	; 0x03
    389a:	3c 81       	ldd	r19, Y+4	; 0x04
    389c:	89 81       	ldd	r24, Y+1	; 0x01
    389e:	9a 81       	ldd	r25, Y+2	; 0x02
    38a0:	82 17       	cp	r24, r18
    38a2:	93 07       	cpc	r25, r19
    38a4:	20 f4       	brcc	.+8      	; 0x38ae <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    38a6:	89 81       	ldd	r24, Y+1	; 0x01
    38a8:	9a 81       	ldd	r25, Y+2	; 0x02
    38aa:	9c 83       	std	Y+4, r25	; 0x04
    38ac:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    38ae:	8c 89       	ldd	r24, Y+20	; 0x14
    38b0:	9d 89       	ldd	r25, Y+21	; 0x15
    38b2:	00 97       	sbiw	r24, 0x00	; 0
    38b4:	09 f4       	brne	.+2      	; 0x38b8 <xStreamBufferSend+0xa6>
    38b6:	43 c0       	rjmp	.+134    	; 0x393e <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    38b8:	ce 01       	movw	r24, r28
    38ba:	0b 96       	adiw	r24, 0x0b	; 11
    38bc:	0e 94 5d 2c 	call	0x58ba	; 0x58ba <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    38c0:	0f b6       	in	r0, 0x3f	; 63
    38c2:	f8 94       	cli
    38c4:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    38c6:	89 85       	ldd	r24, Y+9	; 0x09
    38c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    38ca:	0e 94 93 1b 	call	0x3726	; 0x3726 <xStreamBufferSpacesAvailable>
    38ce:	9e 83       	std	Y+6, r25	; 0x06
    38d0:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    38d2:	2d 81       	ldd	r18, Y+5	; 0x05
    38d4:	3e 81       	ldd	r19, Y+6	; 0x06
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	9c 81       	ldd	r25, Y+4	; 0x04
    38da:	28 17       	cp	r18, r24
    38dc:	39 07       	cpc	r19, r25
    38de:	68 f5       	brcc	.+90     	; 0x393a <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    38e0:	80 e0       	ldi	r24, 0x00	; 0
    38e2:	90 e0       	ldi	r25, 0x00	; 0
    38e4:	60 e0       	ldi	r22, 0x00	; 0
    38e6:	0e 94 ac 34 	call	0x6958	; 0x6958 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    38ea:	0e 94 b9 2d 	call	0x5b72	; 0x5b72 <xTaskGetCurrentTaskHandle>
    38ee:	e9 85       	ldd	r30, Y+9	; 0x09
    38f0:	fa 85       	ldd	r31, Y+10	; 0x0a
    38f2:	93 87       	std	Z+11, r25	; 0x0b
    38f4:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    38f6:	0f 90       	pop	r0
    38f8:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    38fa:	ec 89       	ldd	r30, Y+20	; 0x14
    38fc:	fd 89       	ldd	r31, Y+21	; 0x15
    38fe:	80 e0       	ldi	r24, 0x00	; 0
    3900:	40 e0       	ldi	r20, 0x00	; 0
    3902:	50 e0       	ldi	r21, 0x00	; 0
    3904:	60 e0       	ldi	r22, 0x00	; 0
    3906:	70 e0       	ldi	r23, 0x00	; 0
    3908:	00 e0       	ldi	r16, 0x00	; 0
    390a:	10 e0       	ldi	r17, 0x00	; 0
    390c:	20 e0       	ldi	r18, 0x00	; 0
    390e:	30 e0       	ldi	r19, 0x00	; 0
    3910:	ee 24       	eor	r14, r14
    3912:	ff 24       	eor	r15, r15
    3914:	6f 01       	movw	r12, r30
    3916:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    391a:	e9 85       	ldd	r30, Y+9	; 0x09
    391c:	fa 85       	ldd	r31, Y+10	; 0x0a
    391e:	13 86       	std	Z+11, r1	; 0x0b
    3920:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3922:	ce 01       	movw	r24, r28
    3924:	0b 96       	adiw	r24, 0x0b	; 11
    3926:	9e 01       	movw	r18, r28
    3928:	2c 5e       	subi	r18, 0xEC	; 236
    392a:	3f 4f       	sbci	r19, 0xFF	; 255
    392c:	b9 01       	movw	r22, r18
    392e:	0e 94 94 2c 	call	0x5928	; 0x5928 <xTaskCheckForTimeOut>
    3932:	88 23       	and	r24, r24
    3934:	09 f4       	brne	.+2      	; 0x3938 <xStreamBufferSend+0x126>
    3936:	c4 cf       	rjmp	.-120    	; 0x38c0 <xStreamBufferSend+0xae>
    3938:	02 c0       	rjmp	.+4      	; 0x393e <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    393a:	0f 90       	pop	r0
    393c:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    393e:	8d 81       	ldd	r24, Y+5	; 0x05
    3940:	9e 81       	ldd	r25, Y+6	; 0x06
    3942:	00 97       	sbiw	r24, 0x00	; 0
    3944:	31 f4       	brne	.+12     	; 0x3952 <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3946:	89 85       	ldd	r24, Y+9	; 0x09
    3948:	9a 85       	ldd	r25, Y+10	; 0x0a
    394a:	0e 94 93 1b 	call	0x3726	; 0x3726 <xStreamBufferSpacesAvailable>
    394e:	9e 83       	std	Y+6, r25	; 0x06
    3950:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3952:	89 85       	ldd	r24, Y+9	; 0x09
    3954:	9a 85       	ldd	r25, Y+10	; 0x0a
    3956:	28 89       	ldd	r18, Y+16	; 0x10
    3958:	39 89       	ldd	r19, Y+17	; 0x11
    395a:	4a 89       	ldd	r20, Y+18	; 0x12
    395c:	5b 89       	ldd	r21, Y+19	; 0x13
    395e:	ed 81       	ldd	r30, Y+5	; 0x05
    3960:	fe 81       	ldd	r31, Y+6	; 0x06
    3962:	ab 81       	ldd	r26, Y+3	; 0x03
    3964:	bc 81       	ldd	r27, Y+4	; 0x04
    3966:	b9 01       	movw	r22, r18
    3968:	9f 01       	movw	r18, r30
    396a:	8d 01       	movw	r16, r26
    396c:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <prvWriteMessageToBuffer>
    3970:	98 87       	std	Y+8, r25	; 0x08
    3972:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    3974:	8f 81       	ldd	r24, Y+7	; 0x07
    3976:	98 85       	ldd	r25, Y+8	; 0x08
    3978:	00 97       	sbiw	r24, 0x00	; 0
    397a:	41 f1       	breq	.+80     	; 0x39cc <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    397c:	89 85       	ldd	r24, Y+9	; 0x09
    397e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3980:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3984:	9c 01       	movw	r18, r24
    3986:	e9 85       	ldd	r30, Y+9	; 0x09
    3988:	fa 85       	ldd	r31, Y+10	; 0x0a
    398a:	86 81       	ldd	r24, Z+6	; 0x06
    398c:	97 81       	ldd	r25, Z+7	; 0x07
    398e:	28 17       	cp	r18, r24
    3990:	39 07       	cpc	r19, r25
    3992:	e0 f0       	brcs	.+56     	; 0x39cc <xStreamBufferSend+0x1ba>
        {
            sbSEND_COMPLETED( pxStreamBuffer );
    3994:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    3998:	e9 85       	ldd	r30, Y+9	; 0x09
    399a:	fa 85       	ldd	r31, Y+10	; 0x0a
    399c:	80 85       	ldd	r24, Z+8	; 0x08
    399e:	91 85       	ldd	r25, Z+9	; 0x09
    39a0:	00 97       	sbiw	r24, 0x00	; 0
    39a2:	91 f0       	breq	.+36     	; 0x39c8 <xStreamBufferSend+0x1b6>
    39a4:	e9 85       	ldd	r30, Y+9	; 0x09
    39a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    39a8:	80 85       	ldd	r24, Z+8	; 0x08
    39aa:	91 85       	ldd	r25, Z+9	; 0x09
    39ac:	60 e0       	ldi	r22, 0x00	; 0
    39ae:	20 e0       	ldi	r18, 0x00	; 0
    39b0:	30 e0       	ldi	r19, 0x00	; 0
    39b2:	40 e0       	ldi	r20, 0x00	; 0
    39b4:	50 e0       	ldi	r21, 0x00	; 0
    39b6:	00 e0       	ldi	r16, 0x00	; 0
    39b8:	ee 24       	eor	r14, r14
    39ba:	ff 24       	eor	r15, r15
    39bc:	0e 94 9f 2f 	call	0x5f3e	; 0x5f3e <xTaskGenericNotify>
    39c0:	e9 85       	ldd	r30, Y+9	; 0x09
    39c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    39c4:	11 86       	std	Z+9, r1	; 0x09
    39c6:	10 86       	std	Z+8, r1	; 0x08
    39c8:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    39cc:	8f 81       	ldd	r24, Y+7	; 0x07
    39ce:	98 85       	ldd	r25, Y+8	; 0x08
}
    39d0:	65 96       	adiw	r28, 0x15	; 21
    39d2:	0f b6       	in	r0, 0x3f	; 63
    39d4:	f8 94       	cli
    39d6:	de bf       	out	0x3e, r29	; 62
    39d8:	0f be       	out	0x3f, r0	; 63
    39da:	cd bf       	out	0x3d, r28	; 61
    39dc:	cf 91       	pop	r28
    39de:	df 91       	pop	r29
    39e0:	1f 91       	pop	r17
    39e2:	0f 91       	pop	r16
    39e4:	ff 90       	pop	r15
    39e6:	ef 90       	pop	r14
    39e8:	df 90       	pop	r13
    39ea:	cf 90       	pop	r12
    39ec:	08 95       	ret

000039ee <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    39ee:	cf 92       	push	r12
    39f0:	df 92       	push	r13
    39f2:	ef 92       	push	r14
    39f4:	ff 92       	push	r15
    39f6:	0f 93       	push	r16
    39f8:	1f 93       	push	r17
    39fa:	df 93       	push	r29
    39fc:	cf 93       	push	r28
    39fe:	cd b7       	in	r28, 0x3d	; 61
    3a00:	de b7       	in	r29, 0x3e	; 62
    3a02:	61 97       	sbiw	r28, 0x11	; 17
    3a04:	0f b6       	in	r0, 0x3f	; 63
    3a06:	f8 94       	cli
    3a08:	de bf       	out	0x3e, r29	; 62
    3a0a:	0f be       	out	0x3f, r0	; 63
    3a0c:	cd bf       	out	0x3d, r28	; 61
    3a0e:	9b 87       	std	Y+11, r25	; 0x0b
    3a10:	8a 87       	std	Y+10, r24	; 0x0a
    3a12:	7d 87       	std	Y+13, r23	; 0x0d
    3a14:	6c 87       	std	Y+12, r22	; 0x0c
    3a16:	5f 87       	std	Y+15, r21	; 0x0f
    3a18:	4e 87       	std	Y+14, r20	; 0x0e
    3a1a:	39 8b       	std	Y+17, r19	; 0x11
    3a1c:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a20:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a22:	99 87       	std	Y+9, r25	; 0x09
    3a24:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    3a26:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a28:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a2a:	9b 83       	std	Y+3, r25	; 0x03
    3a2c:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3a2e:	e8 85       	ldd	r30, Y+8	; 0x08
    3a30:	f9 85       	ldd	r31, Y+9	; 0x09
    3a32:	86 85       	ldd	r24, Z+14	; 0x0e
    3a34:	88 2f       	mov	r24, r24
    3a36:	90 e0       	ldi	r25, 0x00	; 0
    3a38:	81 70       	andi	r24, 0x01	; 1
    3a3a:	90 70       	andi	r25, 0x00	; 0
    3a3c:	88 23       	and	r24, r24
    3a3e:	29 f0       	breq	.+10     	; 0x3a4a <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3a40:	8a 81       	ldd	r24, Y+2	; 0x02
    3a42:	9b 81       	ldd	r25, Y+3	; 0x03
    3a44:	02 96       	adiw	r24, 0x02	; 2
    3a46:	9b 83       	std	Y+3, r25	; 0x03
    3a48:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3a4a:	88 85       	ldd	r24, Y+8	; 0x08
    3a4c:	99 85       	ldd	r25, Y+9	; 0x09
    3a4e:	0e 94 93 1b 	call	0x3726	; 0x3726 <xStreamBufferSpacesAvailable>
    3a52:	9d 83       	std	Y+5, r25	; 0x05
    3a54:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3a56:	88 85       	ldd	r24, Y+8	; 0x08
    3a58:	99 85       	ldd	r25, Y+9	; 0x09
    3a5a:	2c 85       	ldd	r18, Y+12	; 0x0c
    3a5c:	3d 85       	ldd	r19, Y+13	; 0x0d
    3a5e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3a60:	5f 85       	ldd	r21, Y+15	; 0x0f
    3a62:	ec 81       	ldd	r30, Y+4	; 0x04
    3a64:	fd 81       	ldd	r31, Y+5	; 0x05
    3a66:	aa 81       	ldd	r26, Y+2	; 0x02
    3a68:	bb 81       	ldd	r27, Y+3	; 0x03
    3a6a:	b9 01       	movw	r22, r18
    3a6c:	9f 01       	movw	r18, r30
    3a6e:	8d 01       	movw	r16, r26
    3a70:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <prvWriteMessageToBuffer>
    3a74:	9f 83       	std	Y+7, r25	; 0x07
    3a76:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    3a78:	8e 81       	ldd	r24, Y+6	; 0x06
    3a7a:	9f 81       	ldd	r25, Y+7	; 0x07
    3a7c:	00 97       	sbiw	r24, 0x00	; 0
    3a7e:	41 f1       	breq	.+80     	; 0x3ad0 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3a80:	88 85       	ldd	r24, Y+8	; 0x08
    3a82:	99 85       	ldd	r25, Y+9	; 0x09
    3a84:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3a88:	9c 01       	movw	r18, r24
    3a8a:	e8 85       	ldd	r30, Y+8	; 0x08
    3a8c:	f9 85       	ldd	r31, Y+9	; 0x09
    3a8e:	86 81       	ldd	r24, Z+6	; 0x06
    3a90:	97 81       	ldd	r25, Z+7	; 0x07
    3a92:	28 17       	cp	r18, r24
    3a94:	39 07       	cpc	r19, r25
    3a96:	e0 f0       	brcs	.+56     	; 0x3ad0 <xStreamBufferSendFromISR+0xe2>
        {
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3a98:	19 82       	std	Y+1, r1	; 0x01
    3a9a:	e8 85       	ldd	r30, Y+8	; 0x08
    3a9c:	f9 85       	ldd	r31, Y+9	; 0x09
    3a9e:	80 85       	ldd	r24, Z+8	; 0x08
    3aa0:	91 85       	ldd	r25, Z+9	; 0x09
    3aa2:	00 97       	sbiw	r24, 0x00	; 0
    3aa4:	a9 f0       	breq	.+42     	; 0x3ad0 <xStreamBufferSendFromISR+0xe2>
    3aa6:	e8 85       	ldd	r30, Y+8	; 0x08
    3aa8:	f9 85       	ldd	r31, Y+9	; 0x09
    3aaa:	80 85       	ldd	r24, Z+8	; 0x08
    3aac:	91 85       	ldd	r25, Z+9	; 0x09
    3aae:	e8 89       	ldd	r30, Y+16	; 0x10
    3ab0:	f9 89       	ldd	r31, Y+17	; 0x11
    3ab2:	60 e0       	ldi	r22, 0x00	; 0
    3ab4:	20 e0       	ldi	r18, 0x00	; 0
    3ab6:	30 e0       	ldi	r19, 0x00	; 0
    3ab8:	40 e0       	ldi	r20, 0x00	; 0
    3aba:	50 e0       	ldi	r21, 0x00	; 0
    3abc:	00 e0       	ldi	r16, 0x00	; 0
    3abe:	ee 24       	eor	r14, r14
    3ac0:	ff 24       	eor	r15, r15
    3ac2:	6f 01       	movw	r12, r30
    3ac4:	0e 94 5d 31 	call	0x62ba	; 0x62ba <xTaskGenericNotifyFromISR>
    3ac8:	e8 85       	ldd	r30, Y+8	; 0x08
    3aca:	f9 85       	ldd	r31, Y+9	; 0x09
    3acc:	11 86       	std	Z+9, r1	; 0x09
    3ace:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    3ad0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ad2:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3ad4:	61 96       	adiw	r28, 0x11	; 17
    3ad6:	0f b6       	in	r0, 0x3f	; 63
    3ad8:	f8 94       	cli
    3ada:	de bf       	out	0x3e, r29	; 62
    3adc:	0f be       	out	0x3f, r0	; 63
    3ade:	cd bf       	out	0x3d, r28	; 61
    3ae0:	cf 91       	pop	r28
    3ae2:	df 91       	pop	r29
    3ae4:	1f 91       	pop	r17
    3ae6:	0f 91       	pop	r16
    3ae8:	ff 90       	pop	r15
    3aea:	ef 90       	pop	r14
    3aec:	df 90       	pop	r13
    3aee:	cf 90       	pop	r12
    3af0:	08 95       	ret

00003af2 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    3af2:	0f 93       	push	r16
    3af4:	1f 93       	push	r17
    3af6:	df 93       	push	r29
    3af8:	cf 93       	push	r28
    3afa:	cd b7       	in	r28, 0x3d	; 61
    3afc:	de b7       	in	r29, 0x3e	; 62
    3afe:	60 97       	sbiw	r28, 0x10	; 16
    3b00:	0f b6       	in	r0, 0x3f	; 63
    3b02:	f8 94       	cli
    3b04:	de bf       	out	0x3e, r29	; 62
    3b06:	0f be       	out	0x3f, r0	; 63
    3b08:	cd bf       	out	0x3d, r28	; 61
    3b0a:	9c 83       	std	Y+4, r25	; 0x04
    3b0c:	8b 83       	std	Y+3, r24	; 0x03
    3b0e:	7e 83       	std	Y+6, r23	; 0x06
    3b10:	6d 83       	std	Y+5, r22	; 0x05
    3b12:	58 87       	std	Y+8, r21	; 0x08
    3b14:	4f 83       	std	Y+7, r20	; 0x07
    3b16:	3a 87       	std	Y+10, r19	; 0x0a
    3b18:	29 87       	std	Y+9, r18	; 0x09
    3b1a:	1c 87       	std	Y+12, r17	; 0x0c
    3b1c:	0b 87       	std	Y+11, r16	; 0x0b
    size_t xNextHead = pxStreamBuffer->xHead;
    3b1e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b20:	fc 81       	ldd	r31, Y+4	; 0x04
    3b22:	82 81       	ldd	r24, Z+2	; 0x02
    3b24:	93 81       	ldd	r25, Z+3	; 0x03
    3b26:	9a 83       	std	Y+2, r25	; 0x02
    3b28:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b2e:	86 85       	ldd	r24, Z+14	; 0x0e
    3b30:	88 2f       	mov	r24, r24
    3b32:	90 e0       	ldi	r25, 0x00	; 0
    3b34:	81 70       	andi	r24, 0x01	; 1
    3b36:	90 70       	andi	r25, 0x00	; 0
    3b38:	88 23       	and	r24, r24
    3b3a:	d1 f0       	breq	.+52     	; 0x3b70 <prvWriteMessageToBuffer+0x7e>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        if( xSpace >= xRequiredSpace )
    3b3c:	29 85       	ldd	r18, Y+9	; 0x09
    3b3e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b40:	8b 85       	ldd	r24, Y+11	; 0x0b
    3b42:	9c 85       	ldd	r25, Y+12	; 0x0c
    3b44:	28 17       	cp	r18, r24
    3b46:	39 07       	cpc	r19, r25
    3b48:	80 f0       	brcs	.+32     	; 0x3b6a <prvWriteMessageToBuffer+0x78>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    3b4a:	9e 01       	movw	r18, r28
    3b4c:	29 5f       	subi	r18, 0xF9	; 249
    3b4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3b50:	8b 81       	ldd	r24, Y+3	; 0x03
    3b52:	9c 81       	ldd	r25, Y+4	; 0x04
    3b54:	e9 81       	ldd	r30, Y+1	; 0x01
    3b56:	fa 81       	ldd	r31, Y+2	; 0x02
    3b58:	b9 01       	movw	r22, r18
    3b5a:	42 e0       	ldi	r20, 0x02	; 2
    3b5c:	50 e0       	ldi	r21, 0x00	; 0
    3b5e:	9f 01       	movw	r18, r30
    3b60:	0e 94 de 20 	call	0x41bc	; 0x41bc <prvWriteBytesToBuffer>
    3b64:	9a 83       	std	Y+2, r25	; 0x02
    3b66:	89 83       	std	Y+1, r24	; 0x01
    3b68:	1a c0       	rjmp	.+52     	; 0x3b9e <prvWriteMessageToBuffer+0xac>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    3b6a:	18 86       	std	Y+8, r1	; 0x08
    3b6c:	1f 82       	std	Y+7, r1	; 0x07
    3b6e:	17 c0       	rjmp	.+46     	; 0x3b9e <prvWriteMessageToBuffer+0xac>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3b70:	2f 81       	ldd	r18, Y+7	; 0x07
    3b72:	38 85       	ldd	r19, Y+8	; 0x08
    3b74:	38 8b       	std	Y+16, r19	; 0x10
    3b76:	2f 87       	std	Y+15, r18	; 0x0f
    3b78:	89 85       	ldd	r24, Y+9	; 0x09
    3b7a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b7c:	9e 87       	std	Y+14, r25	; 0x0e
    3b7e:	8d 87       	std	Y+13, r24	; 0x0d
    3b80:	2d 85       	ldd	r18, Y+13	; 0x0d
    3b82:	3e 85       	ldd	r19, Y+14	; 0x0e
    3b84:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b86:	98 89       	ldd	r25, Y+16	; 0x10
    3b88:	82 17       	cp	r24, r18
    3b8a:	93 07       	cpc	r25, r19
    3b8c:	20 f4       	brcc	.+8      	; 0x3b96 <prvWriteMessageToBuffer+0xa4>
    3b8e:	2f 85       	ldd	r18, Y+15	; 0x0f
    3b90:	38 89       	ldd	r19, Y+16	; 0x10
    3b92:	3e 87       	std	Y+14, r19	; 0x0e
    3b94:	2d 87       	std	Y+13, r18	; 0x0d
    3b96:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b98:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b9a:	98 87       	std	Y+8, r25	; 0x08
    3b9c:	8f 83       	std	Y+7, r24	; 0x07
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    3b9e:	8f 81       	ldd	r24, Y+7	; 0x07
    3ba0:	98 85       	ldd	r25, Y+8	; 0x08
    3ba2:	00 97       	sbiw	r24, 0x00	; 0
    3ba4:	81 f0       	breq	.+32     	; 0x3bc6 <prvWriteMessageToBuffer+0xd4>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    3ba6:	4d 81       	ldd	r20, Y+5	; 0x05
    3ba8:	5e 81       	ldd	r21, Y+6	; 0x06
    3baa:	ef 81       	ldd	r30, Y+7	; 0x07
    3bac:	f8 85       	ldd	r31, Y+8	; 0x08
    3bae:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb2:	29 81       	ldd	r18, Y+1	; 0x01
    3bb4:	3a 81       	ldd	r19, Y+2	; 0x02
    3bb6:	ba 01       	movw	r22, r20
    3bb8:	af 01       	movw	r20, r30
    3bba:	0e 94 de 20 	call	0x41bc	; 0x41bc <prvWriteBytesToBuffer>
    3bbe:	eb 81       	ldd	r30, Y+3	; 0x03
    3bc0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bc2:	93 83       	std	Z+3, r25	; 0x03
    3bc4:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    3bc6:	8f 81       	ldd	r24, Y+7	; 0x07
    3bc8:	98 85       	ldd	r25, Y+8	; 0x08
}
    3bca:	60 96       	adiw	r28, 0x10	; 16
    3bcc:	0f b6       	in	r0, 0x3f	; 63
    3bce:	f8 94       	cli
    3bd0:	de bf       	out	0x3e, r29	; 62
    3bd2:	0f be       	out	0x3f, r0	; 63
    3bd4:	cd bf       	out	0x3d, r28	; 61
    3bd6:	cf 91       	pop	r28
    3bd8:	df 91       	pop	r29
    3bda:	1f 91       	pop	r17
    3bdc:	0f 91       	pop	r16
    3bde:	08 95       	ret

00003be0 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    3be0:	cf 92       	push	r12
    3be2:	df 92       	push	r13
    3be4:	ef 92       	push	r14
    3be6:	ff 92       	push	r15
    3be8:	0f 93       	push	r16
    3bea:	1f 93       	push	r17
    3bec:	df 93       	push	r29
    3bee:	cf 93       	push	r28
    3bf0:	cd b7       	in	r28, 0x3d	; 61
    3bf2:	de b7       	in	r29, 0x3e	; 62
    3bf4:	60 97       	sbiw	r28, 0x10	; 16
    3bf6:	0f b6       	in	r0, 0x3f	; 63
    3bf8:	f8 94       	cli
    3bfa:	de bf       	out	0x3e, r29	; 62
    3bfc:	0f be       	out	0x3f, r0	; 63
    3bfe:	cd bf       	out	0x3d, r28	; 61
    3c00:	9a 87       	std	Y+10, r25	; 0x0a
    3c02:	89 87       	std	Y+9, r24	; 0x09
    3c04:	7c 87       	std	Y+12, r23	; 0x0c
    3c06:	6b 87       	std	Y+11, r22	; 0x0b
    3c08:	5e 87       	std	Y+14, r21	; 0x0e
    3c0a:	4d 87       	std	Y+13, r20	; 0x0d
    3c0c:	38 8b       	std	Y+16, r19	; 0x10
    3c0e:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3c10:	89 85       	ldd	r24, Y+9	; 0x09
    3c12:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c14:	98 87       	std	Y+8, r25	; 0x08
    3c16:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3c18:	1e 82       	std	Y+6, r1	; 0x06
    3c1a:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3c1c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c1e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c20:	86 85       	ldd	r24, Z+14	; 0x0e
    3c22:	88 2f       	mov	r24, r24
    3c24:	90 e0       	ldi	r25, 0x00	; 0
    3c26:	81 70       	andi	r24, 0x01	; 1
    3c28:	90 70       	andi	r25, 0x00	; 0
    3c2a:	88 23       	and	r24, r24
    3c2c:	29 f0       	breq	.+10     	; 0x3c38 <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3c2e:	82 e0       	ldi	r24, 0x02	; 2
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	9a 83       	std	Y+2, r25	; 0x02
    3c34:	89 83       	std	Y+1, r24	; 0x01
    3c36:	02 c0       	rjmp	.+4      	; 0x3c3c <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    3c38:	1a 82       	std	Y+2, r1	; 0x02
    3c3a:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    3c3c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c3e:	98 89       	ldd	r25, Y+16	; 0x10
    3c40:	00 97       	sbiw	r24, 0x00	; 0
    3c42:	09 f4       	brne	.+2      	; 0x3c46 <xStreamBufferReceive+0x66>
    3c44:	3f c0       	rjmp	.+126    	; 0x3cc4 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    3c46:	0f b6       	in	r0, 0x3f	; 63
    3c48:	f8 94       	cli
    3c4a:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3c4c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c4e:	98 85       	ldd	r25, Y+8	; 0x08
    3c50:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3c54:	9c 83       	std	Y+4, r25	; 0x04
    3c56:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    3c58:	2b 81       	ldd	r18, Y+3	; 0x03
    3c5a:	3c 81       	ldd	r19, Y+4	; 0x04
    3c5c:	89 81       	ldd	r24, Y+1	; 0x01
    3c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c60:	82 17       	cp	r24, r18
    3c62:	93 07       	cpc	r25, r19
    3c64:	58 f0       	brcs	.+22     	; 0x3c7c <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    3c66:	80 e0       	ldi	r24, 0x00	; 0
    3c68:	90 e0       	ldi	r25, 0x00	; 0
    3c6a:	60 e0       	ldi	r22, 0x00	; 0
    3c6c:	0e 94 ac 34 	call	0x6958	; 0x6958 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3c70:	0e 94 b9 2d 	call	0x5b72	; 0x5b72 <xTaskGetCurrentTaskHandle>
    3c74:	ef 81       	ldd	r30, Y+7	; 0x07
    3c76:	f8 85       	ldd	r31, Y+8	; 0x08
    3c78:	91 87       	std	Z+9, r25	; 0x09
    3c7a:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3c7c:	0f 90       	pop	r0
    3c7e:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    3c80:	2b 81       	ldd	r18, Y+3	; 0x03
    3c82:	3c 81       	ldd	r19, Y+4	; 0x04
    3c84:	89 81       	ldd	r24, Y+1	; 0x01
    3c86:	9a 81       	ldd	r25, Y+2	; 0x02
    3c88:	82 17       	cp	r24, r18
    3c8a:	93 07       	cpc	r25, r19
    3c8c:	08 f1       	brcs	.+66     	; 0x3cd0 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3c8e:	ef 85       	ldd	r30, Y+15	; 0x0f
    3c90:	f8 89       	ldd	r31, Y+16	; 0x10
    3c92:	80 e0       	ldi	r24, 0x00	; 0
    3c94:	40 e0       	ldi	r20, 0x00	; 0
    3c96:	50 e0       	ldi	r21, 0x00	; 0
    3c98:	60 e0       	ldi	r22, 0x00	; 0
    3c9a:	70 e0       	ldi	r23, 0x00	; 0
    3c9c:	00 e0       	ldi	r16, 0x00	; 0
    3c9e:	10 e0       	ldi	r17, 0x00	; 0
    3ca0:	20 e0       	ldi	r18, 0x00	; 0
    3ca2:	30 e0       	ldi	r19, 0x00	; 0
    3ca4:	ee 24       	eor	r14, r14
    3ca6:	ff 24       	eor	r15, r15
    3ca8:	6f 01       	movw	r12, r30
    3caa:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3cae:	ef 81       	ldd	r30, Y+7	; 0x07
    3cb0:	f8 85       	ldd	r31, Y+8	; 0x08
    3cb2:	11 86       	std	Z+9, r1	; 0x09
    3cb4:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3cb6:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb8:	98 85       	ldd	r25, Y+8	; 0x08
    3cba:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3cbe:	9c 83       	std	Y+4, r25	; 0x04
    3cc0:	8b 83       	std	Y+3, r24	; 0x03
    3cc2:	06 c0       	rjmp	.+12     	; 0x3cd0 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3cc4:	8f 81       	ldd	r24, Y+7	; 0x07
    3cc6:	98 85       	ldd	r25, Y+8	; 0x08
    3cc8:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3ccc:	9c 83       	std	Y+4, r25	; 0x04
    3cce:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    3cd0:	2b 81       	ldd	r18, Y+3	; 0x03
    3cd2:	3c 81       	ldd	r19, Y+4	; 0x04
    3cd4:	89 81       	ldd	r24, Y+1	; 0x01
    3cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd8:	82 17       	cp	r24, r18
    3cda:	93 07       	cpc	r25, r19
    3cdc:	70 f5       	brcc	.+92     	; 0x3d3a <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    3cde:	8f 81       	ldd	r24, Y+7	; 0x07
    3ce0:	98 85       	ldd	r25, Y+8	; 0x08
    3ce2:	2b 85       	ldd	r18, Y+11	; 0x0b
    3ce4:	3c 85       	ldd	r19, Y+12	; 0x0c
    3ce6:	4d 85       	ldd	r20, Y+13	; 0x0d
    3ce8:	5e 85       	ldd	r21, Y+14	; 0x0e
    3cea:	eb 81       	ldd	r30, Y+3	; 0x03
    3cec:	fc 81       	ldd	r31, Y+4	; 0x04
    3cee:	b9 01       	movw	r22, r18
    3cf0:	9f 01       	movw	r18, r30
    3cf2:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <prvReadMessageFromBuffer>
    3cf6:	9e 83       	std	Y+6, r25	; 0x06
    3cf8:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    3cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3cfe:	00 97       	sbiw	r24, 0x00	; 0
    3d00:	e1 f0       	breq	.+56     	; 0x3d3a <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    3d02:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    3d06:	ef 81       	ldd	r30, Y+7	; 0x07
    3d08:	f8 85       	ldd	r31, Y+8	; 0x08
    3d0a:	82 85       	ldd	r24, Z+10	; 0x0a
    3d0c:	93 85       	ldd	r25, Z+11	; 0x0b
    3d0e:	00 97       	sbiw	r24, 0x00	; 0
    3d10:	91 f0       	breq	.+36     	; 0x3d36 <xStreamBufferReceive+0x156>
    3d12:	ef 81       	ldd	r30, Y+7	; 0x07
    3d14:	f8 85       	ldd	r31, Y+8	; 0x08
    3d16:	82 85       	ldd	r24, Z+10	; 0x0a
    3d18:	93 85       	ldd	r25, Z+11	; 0x0b
    3d1a:	60 e0       	ldi	r22, 0x00	; 0
    3d1c:	20 e0       	ldi	r18, 0x00	; 0
    3d1e:	30 e0       	ldi	r19, 0x00	; 0
    3d20:	40 e0       	ldi	r20, 0x00	; 0
    3d22:	50 e0       	ldi	r21, 0x00	; 0
    3d24:	00 e0       	ldi	r16, 0x00	; 0
    3d26:	ee 24       	eor	r14, r14
    3d28:	ff 24       	eor	r15, r15
    3d2a:	0e 94 9f 2f 	call	0x5f3e	; 0x5f3e <xTaskGenericNotify>
    3d2e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d30:	f8 85       	ldd	r31, Y+8	; 0x08
    3d32:	13 86       	std	Z+11, r1	; 0x0b
    3d34:	12 86       	std	Z+10, r1	; 0x0a
    3d36:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    3d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d3c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3d3e:	60 96       	adiw	r28, 0x10	; 16
    3d40:	0f b6       	in	r0, 0x3f	; 63
    3d42:	f8 94       	cli
    3d44:	de bf       	out	0x3e, r29	; 62
    3d46:	0f be       	out	0x3f, r0	; 63
    3d48:	cd bf       	out	0x3d, r28	; 61
    3d4a:	cf 91       	pop	r28
    3d4c:	df 91       	pop	r29
    3d4e:	1f 91       	pop	r17
    3d50:	0f 91       	pop	r16
    3d52:	ff 90       	pop	r15
    3d54:	ef 90       	pop	r14
    3d56:	df 90       	pop	r13
    3d58:	cf 90       	pop	r12
    3d5a:	08 95       	ret

00003d5c <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3d5c:	df 93       	push	r29
    3d5e:	cf 93       	push	r28
    3d60:	cd b7       	in	r28, 0x3d	; 61
    3d62:	de b7       	in	r29, 0x3e	; 62
    3d64:	2a 97       	sbiw	r28, 0x0a	; 10
    3d66:	0f b6       	in	r0, 0x3f	; 63
    3d68:	f8 94       	cli
    3d6a:	de bf       	out	0x3e, r29	; 62
    3d6c:	0f be       	out	0x3f, r0	; 63
    3d6e:	cd bf       	out	0x3d, r28	; 61
    3d70:	9a 87       	std	Y+10, r25	; 0x0a
    3d72:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3d74:	89 85       	ldd	r24, Y+9	; 0x09
    3d76:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d78:	9e 83       	std	Y+6, r25	; 0x06
    3d7a:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3d7c:	ed 81       	ldd	r30, Y+5	; 0x05
    3d7e:	fe 81       	ldd	r31, Y+6	; 0x06
    3d80:	86 85       	ldd	r24, Z+14	; 0x0e
    3d82:	88 2f       	mov	r24, r24
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	81 70       	andi	r24, 0x01	; 1
    3d88:	90 70       	andi	r25, 0x00	; 0
    3d8a:	88 23       	and	r24, r24
    3d8c:	19 f1       	breq	.+70     	; 0x3dd4 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3d90:	9e 81       	ldd	r25, Y+6	; 0x06
    3d92:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3d96:	9a 83       	std	Y+2, r25	; 0x02
    3d98:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3d9a:	89 81       	ldd	r24, Y+1	; 0x01
    3d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9e:	83 30       	cpi	r24, 0x03	; 3
    3da0:	91 05       	cpc	r25, r1
    3da2:	a8 f0       	brcs	.+42     	; 0x3dce <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    3da4:	9e 01       	movw	r18, r28
    3da6:	29 5f       	subi	r18, 0xF9	; 249
    3da8:	3f 4f       	sbci	r19, 0xFF	; 255
    3daa:	ed 81       	ldd	r30, Y+5	; 0x05
    3dac:	fe 81       	ldd	r31, Y+6	; 0x06
    3dae:	01 90       	ld	r0, Z+
    3db0:	f0 81       	ld	r31, Z
    3db2:	e0 2d       	mov	r30, r0
    3db4:	8d 81       	ldd	r24, Y+5	; 0x05
    3db6:	9e 81       	ldd	r25, Y+6	; 0x06
    3db8:	b9 01       	movw	r22, r18
    3dba:	42 e0       	ldi	r20, 0x02	; 2
    3dbc:	50 e0       	ldi	r21, 0x00	; 0
    3dbe:	9f 01       	movw	r18, r30
    3dc0:	0e 94 61 21 	call	0x42c2	; 0x42c2 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    3dc4:	8f 81       	ldd	r24, Y+7	; 0x07
    3dc6:	98 85       	ldd	r25, Y+8	; 0x08
    3dc8:	9c 83       	std	Y+4, r25	; 0x04
    3dca:	8b 83       	std	Y+3, r24	; 0x03
    3dcc:	05 c0       	rjmp	.+10     	; 0x3dd8 <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    3dce:	1c 82       	std	Y+4, r1	; 0x04
    3dd0:	1b 82       	std	Y+3, r1	; 0x03
    3dd2:	02 c0       	rjmp	.+4      	; 0x3dd8 <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    3dd4:	1c 82       	std	Y+4, r1	; 0x04
    3dd6:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    3dda:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3ddc:	2a 96       	adiw	r28, 0x0a	; 10
    3dde:	0f b6       	in	r0, 0x3f	; 63
    3de0:	f8 94       	cli
    3de2:	de bf       	out	0x3e, r29	; 62
    3de4:	0f be       	out	0x3f, r0	; 63
    3de6:	cd bf       	out	0x3d, r28	; 61
    3de8:	cf 91       	pop	r28
    3dea:	df 91       	pop	r29
    3dec:	08 95       	ret

00003dee <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    3dee:	cf 92       	push	r12
    3df0:	df 92       	push	r13
    3df2:	ef 92       	push	r14
    3df4:	ff 92       	push	r15
    3df6:	0f 93       	push	r16
    3df8:	df 93       	push	r29
    3dfa:	cf 93       	push	r28
    3dfc:	cd b7       	in	r28, 0x3d	; 61
    3dfe:	de b7       	in	r29, 0x3e	; 62
    3e00:	61 97       	sbiw	r28, 0x11	; 17
    3e02:	0f b6       	in	r0, 0x3f	; 63
    3e04:	f8 94       	cli
    3e06:	de bf       	out	0x3e, r29	; 62
    3e08:	0f be       	out	0x3f, r0	; 63
    3e0a:	cd bf       	out	0x3d, r28	; 61
    3e0c:	9b 87       	std	Y+11, r25	; 0x0b
    3e0e:	8a 87       	std	Y+10, r24	; 0x0a
    3e10:	7d 87       	std	Y+13, r23	; 0x0d
    3e12:	6c 87       	std	Y+12, r22	; 0x0c
    3e14:	5f 87       	std	Y+15, r21	; 0x0f
    3e16:	4e 87       	std	Y+14, r20	; 0x0e
    3e18:	39 8b       	std	Y+17, r19	; 0x11
    3e1a:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e20:	99 87       	std	Y+9, r25	; 0x09
    3e22:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3e24:	1f 82       	std	Y+7, r1	; 0x07
    3e26:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e28:	e8 85       	ldd	r30, Y+8	; 0x08
    3e2a:	f9 85       	ldd	r31, Y+9	; 0x09
    3e2c:	86 85       	ldd	r24, Z+14	; 0x0e
    3e2e:	88 2f       	mov	r24, r24
    3e30:	90 e0       	ldi	r25, 0x00	; 0
    3e32:	81 70       	andi	r24, 0x01	; 1
    3e34:	90 70       	andi	r25, 0x00	; 0
    3e36:	88 23       	and	r24, r24
    3e38:	29 f0       	breq	.+10     	; 0x3e44 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e3a:	82 e0       	ldi	r24, 0x02	; 2
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
    3e3e:	9b 83       	std	Y+3, r25	; 0x03
    3e40:	8a 83       	std	Y+2, r24	; 0x02
    3e42:	02 c0       	rjmp	.+4      	; 0x3e48 <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    3e44:	1b 82       	std	Y+3, r1	; 0x03
    3e46:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e48:	88 85       	ldd	r24, Y+8	; 0x08
    3e4a:	99 85       	ldd	r25, Y+9	; 0x09
    3e4c:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvBytesInBuffer>
    3e50:	9d 83       	std	Y+5, r25	; 0x05
    3e52:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    3e54:	2c 81       	ldd	r18, Y+4	; 0x04
    3e56:	3d 81       	ldd	r19, Y+5	; 0x05
    3e58:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e5c:	82 17       	cp	r24, r18
    3e5e:	93 07       	cpc	r25, r19
    3e60:	70 f5       	brcc	.+92     	; 0x3ebe <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    3e62:	88 85       	ldd	r24, Y+8	; 0x08
    3e64:	99 85       	ldd	r25, Y+9	; 0x09
    3e66:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e68:	3d 85       	ldd	r19, Y+13	; 0x0d
    3e6a:	4e 85       	ldd	r20, Y+14	; 0x0e
    3e6c:	5f 85       	ldd	r21, Y+15	; 0x0f
    3e6e:	ec 81       	ldd	r30, Y+4	; 0x04
    3e70:	fd 81       	ldd	r31, Y+5	; 0x05
    3e72:	b9 01       	movw	r22, r18
    3e74:	9f 01       	movw	r18, r30
    3e76:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <prvReadMessageFromBuffer>
    3e7a:	9f 83       	std	Y+7, r25	; 0x07
    3e7c:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    3e7e:	8e 81       	ldd	r24, Y+6	; 0x06
    3e80:	9f 81       	ldd	r25, Y+7	; 0x07
    3e82:	00 97       	sbiw	r24, 0x00	; 0
    3e84:	e1 f0       	breq	.+56     	; 0x3ebe <xStreamBufferReceiveFromISR+0xd0>
        {
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3e86:	19 82       	std	Y+1, r1	; 0x01
    3e88:	e8 85       	ldd	r30, Y+8	; 0x08
    3e8a:	f9 85       	ldd	r31, Y+9	; 0x09
    3e8c:	82 85       	ldd	r24, Z+10	; 0x0a
    3e8e:	93 85       	ldd	r25, Z+11	; 0x0b
    3e90:	00 97       	sbiw	r24, 0x00	; 0
    3e92:	a9 f0       	breq	.+42     	; 0x3ebe <xStreamBufferReceiveFromISR+0xd0>
    3e94:	e8 85       	ldd	r30, Y+8	; 0x08
    3e96:	f9 85       	ldd	r31, Y+9	; 0x09
    3e98:	82 85       	ldd	r24, Z+10	; 0x0a
    3e9a:	93 85       	ldd	r25, Z+11	; 0x0b
    3e9c:	e8 89       	ldd	r30, Y+16	; 0x10
    3e9e:	f9 89       	ldd	r31, Y+17	; 0x11
    3ea0:	60 e0       	ldi	r22, 0x00	; 0
    3ea2:	20 e0       	ldi	r18, 0x00	; 0
    3ea4:	30 e0       	ldi	r19, 0x00	; 0
    3ea6:	40 e0       	ldi	r20, 0x00	; 0
    3ea8:	50 e0       	ldi	r21, 0x00	; 0
    3eaa:	00 e0       	ldi	r16, 0x00	; 0
    3eac:	ee 24       	eor	r14, r14
    3eae:	ff 24       	eor	r15, r15
    3eb0:	6f 01       	movw	r12, r30
    3eb2:	0e 94 5d 31 	call	0x62ba	; 0x62ba <xTaskGenericNotifyFromISR>
    3eb6:	e8 85       	ldd	r30, Y+8	; 0x08
    3eb8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eba:	13 86       	std	Z+11, r1	; 0x0b
    3ebc:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    3ebe:	8e 81       	ldd	r24, Y+6	; 0x06
    3ec0:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3ec2:	61 96       	adiw	r28, 0x11	; 17
    3ec4:	0f b6       	in	r0, 0x3f	; 63
    3ec6:	f8 94       	cli
    3ec8:	de bf       	out	0x3e, r29	; 62
    3eca:	0f be       	out	0x3f, r0	; 63
    3ecc:	cd bf       	out	0x3d, r28	; 61
    3ece:	cf 91       	pop	r28
    3ed0:	df 91       	pop	r29
    3ed2:	0f 91       	pop	r16
    3ed4:	ff 90       	pop	r15
    3ed6:	ef 90       	pop	r14
    3ed8:	df 90       	pop	r13
    3eda:	cf 90       	pop	r12
    3edc:	08 95       	ret

00003ede <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    3ede:	df 93       	push	r29
    3ee0:	cf 93       	push	r28
    3ee2:	cd b7       	in	r28, 0x3d	; 61
    3ee4:	de b7       	in	r29, 0x3e	; 62
    3ee6:	64 97       	sbiw	r28, 0x14	; 20
    3ee8:	0f b6       	in	r0, 0x3f	; 63
    3eea:	f8 94       	cli
    3eec:	de bf       	out	0x3e, r29	; 62
    3eee:	0f be       	out	0x3f, r0	; 63
    3ef0:	cd bf       	out	0x3d, r28	; 61
    3ef2:	9a 87       	std	Y+10, r25	; 0x0a
    3ef4:	89 87       	std	Y+9, r24	; 0x09
    3ef6:	7c 87       	std	Y+12, r23	; 0x0c
    3ef8:	6b 87       	std	Y+11, r22	; 0x0b
    3efa:	5e 87       	std	Y+14, r21	; 0x0e
    3efc:	4d 87       	std	Y+13, r20	; 0x0d
    3efe:	38 8b       	std	Y+16, r19	; 0x10
    3f00:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    3f02:	e9 85       	ldd	r30, Y+9	; 0x09
    3f04:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f06:	80 81       	ld	r24, Z
    3f08:	91 81       	ldd	r25, Z+1	; 0x01
    3f0a:	9a 83       	std	Y+2, r25	; 0x02
    3f0c:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3f0e:	e9 85       	ldd	r30, Y+9	; 0x09
    3f10:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f12:	86 85       	ldd	r24, Z+14	; 0x0e
    3f14:	88 2f       	mov	r24, r24
    3f16:	90 e0       	ldi	r25, 0x00	; 0
    3f18:	81 70       	andi	r24, 0x01	; 1
    3f1a:	90 70       	andi	r25, 0x00	; 0
    3f1c:	88 23       	and	r24, r24
    3f1e:	11 f1       	breq	.+68     	; 0x3f64 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    3f20:	9e 01       	movw	r18, r28
    3f22:	29 5f       	subi	r18, 0xF9	; 249
    3f24:	3f 4f       	sbci	r19, 0xFF	; 255
    3f26:	89 85       	ldd	r24, Y+9	; 0x09
    3f28:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f2e:	b9 01       	movw	r22, r18
    3f30:	42 e0       	ldi	r20, 0x02	; 2
    3f32:	50 e0       	ldi	r21, 0x00	; 0
    3f34:	9f 01       	movw	r18, r30
    3f36:	0e 94 61 21 	call	0x42c2	; 0x42c2 <prvReadBytesFromBuffer>
    3f3a:	9a 83       	std	Y+2, r25	; 0x02
    3f3c:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3f3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3f40:	98 85       	ldd	r25, Y+8	; 0x08
    3f42:	9c 83       	std	Y+4, r25	; 0x04
    3f44:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3f46:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f48:	98 89       	ldd	r25, Y+16	; 0x10
    3f4a:	02 97       	sbiw	r24, 0x02	; 2
    3f4c:	98 8b       	std	Y+16, r25	; 0x10
    3f4e:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    3f50:	2b 81       	ldd	r18, Y+3	; 0x03
    3f52:	3c 81       	ldd	r19, Y+4	; 0x04
    3f54:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f56:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f58:	82 17       	cp	r24, r18
    3f5a:	93 07       	cpc	r25, r19
    3f5c:	38 f4       	brcc	.+14     	; 0x3f6c <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    3f5e:	1c 82       	std	Y+4, r1	; 0x04
    3f60:	1b 82       	std	Y+3, r1	; 0x03
    3f62:	04 c0       	rjmp	.+8      	; 0x3f6c <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    3f64:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f66:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f68:	9c 83       	std	Y+4, r25	; 0x04
    3f6a:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    3f6c:	2b 81       	ldd	r18, Y+3	; 0x03
    3f6e:	3c 81       	ldd	r19, Y+4	; 0x04
    3f70:	3c 8b       	std	Y+20, r19	; 0x14
    3f72:	2b 8b       	std	Y+19, r18	; 0x13
    3f74:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f76:	98 89       	ldd	r25, Y+16	; 0x10
    3f78:	9a 8b       	std	Y+18, r25	; 0x12
    3f7a:	89 8b       	std	Y+17, r24	; 0x11
    3f7c:	29 89       	ldd	r18, Y+17	; 0x11
    3f7e:	3a 89       	ldd	r19, Y+18	; 0x12
    3f80:	8b 89       	ldd	r24, Y+19	; 0x13
    3f82:	9c 89       	ldd	r25, Y+20	; 0x14
    3f84:	82 17       	cp	r24, r18
    3f86:	93 07       	cpc	r25, r19
    3f88:	20 f4       	brcc	.+8      	; 0x3f92 <prvReadMessageFromBuffer+0xb4>
    3f8a:	2b 89       	ldd	r18, Y+19	; 0x13
    3f8c:	3c 89       	ldd	r19, Y+20	; 0x14
    3f8e:	3a 8b       	std	Y+18, r19	; 0x12
    3f90:	29 8b       	std	Y+17, r18	; 0x11
    3f92:	89 89       	ldd	r24, Y+17	; 0x11
    3f94:	9a 89       	ldd	r25, Y+18	; 0x12
    3f96:	9e 83       	std	Y+6, r25	; 0x06
    3f98:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    3f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	89 f0       	breq	.+34     	; 0x3fc4 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3fa2:	4b 85       	ldd	r20, Y+11	; 0x0b
    3fa4:	5c 85       	ldd	r21, Y+12	; 0x0c
    3fa6:	89 85       	ldd	r24, Y+9	; 0x09
    3fa8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3faa:	2d 81       	ldd	r18, Y+5	; 0x05
    3fac:	3e 81       	ldd	r19, Y+6	; 0x06
    3fae:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb2:	ba 01       	movw	r22, r20
    3fb4:	a9 01       	movw	r20, r18
    3fb6:	9f 01       	movw	r18, r30
    3fb8:	0e 94 61 21 	call	0x42c2	; 0x42c2 <prvReadBytesFromBuffer>
    3fbc:	e9 85       	ldd	r30, Y+9	; 0x09
    3fbe:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fc0:	91 83       	std	Z+1, r25	; 0x01
    3fc2:	80 83       	st	Z, r24
    }

    return xCount;
    3fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    3fc6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3fc8:	64 96       	adiw	r28, 0x14	; 20
    3fca:	0f b6       	in	r0, 0x3f	; 63
    3fcc:	f8 94       	cli
    3fce:	de bf       	out	0x3e, r29	; 62
    3fd0:	0f be       	out	0x3f, r0	; 63
    3fd2:	cd bf       	out	0x3d, r28	; 61
    3fd4:	cf 91       	pop	r28
    3fd6:	df 91       	pop	r29
    3fd8:	08 95       	ret

00003fda <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3fda:	df 93       	push	r29
    3fdc:	cf 93       	push	r28
    3fde:	cd b7       	in	r28, 0x3d	; 61
    3fe0:	de b7       	in	r29, 0x3e	; 62
    3fe2:	27 97       	sbiw	r28, 0x07	; 7
    3fe4:	0f b6       	in	r0, 0x3f	; 63
    3fe6:	f8 94       	cli
    3fe8:	de bf       	out	0x3e, r29	; 62
    3fea:	0f be       	out	0x3f, r0	; 63
    3fec:	cd bf       	out	0x3d, r28	; 61
    3fee:	9f 83       	std	Y+7, r25	; 0x07
    3ff0:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3ff2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ff4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ff6:	9d 83       	std	Y+5, r25	; 0x05
    3ff8:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    3ffa:	ec 81       	ldd	r30, Y+4	; 0x04
    3ffc:	fd 81       	ldd	r31, Y+5	; 0x05
    3ffe:	80 81       	ld	r24, Z
    4000:	91 81       	ldd	r25, Z+1	; 0x01
    4002:	9a 83       	std	Y+2, r25	; 0x02
    4004:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    4006:	ec 81       	ldd	r30, Y+4	; 0x04
    4008:	fd 81       	ldd	r31, Y+5	; 0x05
    400a:	22 81       	ldd	r18, Z+2	; 0x02
    400c:	33 81       	ldd	r19, Z+3	; 0x03
    400e:	89 81       	ldd	r24, Y+1	; 0x01
    4010:	9a 81       	ldd	r25, Y+2	; 0x02
    4012:	28 17       	cp	r18, r24
    4014:	39 07       	cpc	r19, r25
    4016:	19 f4       	brne	.+6      	; 0x401e <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    4018:	81 e0       	ldi	r24, 0x01	; 1
    401a:	8b 83       	std	Y+3, r24	; 0x03
    401c:	01 c0       	rjmp	.+2      	; 0x4020 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    401e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4020:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4022:	27 96       	adiw	r28, 0x07	; 7
    4024:	0f b6       	in	r0, 0x3f	; 63
    4026:	f8 94       	cli
    4028:	de bf       	out	0x3e, r29	; 62
    402a:	0f be       	out	0x3f, r0	; 63
    402c:	cd bf       	out	0x3d, r28	; 61
    402e:	cf 91       	pop	r28
    4030:	df 91       	pop	r29
    4032:	08 95       	ret

00004034 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    4034:	df 93       	push	r29
    4036:	cf 93       	push	r28
    4038:	cd b7       	in	r28, 0x3d	; 61
    403a:	de b7       	in	r29, 0x3e	; 62
    403c:	27 97       	sbiw	r28, 0x07	; 7
    403e:	0f b6       	in	r0, 0x3f	; 63
    4040:	f8 94       	cli
    4042:	de bf       	out	0x3e, r29	; 62
    4044:	0f be       	out	0x3f, r0	; 63
    4046:	cd bf       	out	0x3d, r28	; 61
    4048:	9f 83       	std	Y+7, r25	; 0x07
    404a:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    404c:	8e 81       	ldd	r24, Y+6	; 0x06
    404e:	9f 81       	ldd	r25, Y+7	; 0x07
    4050:	9a 83       	std	Y+2, r25	; 0x02
    4052:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4054:	e9 81       	ldd	r30, Y+1	; 0x01
    4056:	fa 81       	ldd	r31, Y+2	; 0x02
    4058:	86 85       	ldd	r24, Z+14	; 0x0e
    405a:	88 2f       	mov	r24, r24
    405c:	90 e0       	ldi	r25, 0x00	; 0
    405e:	81 70       	andi	r24, 0x01	; 1
    4060:	90 70       	andi	r25, 0x00	; 0
    4062:	88 23       	and	r24, r24
    4064:	29 f0       	breq	.+10     	; 0x4070 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4066:	82 e0       	ldi	r24, 0x02	; 2
    4068:	90 e0       	ldi	r25, 0x00	; 0
    406a:	9c 83       	std	Y+4, r25	; 0x04
    406c:	8b 83       	std	Y+3, r24	; 0x03
    406e:	02 c0       	rjmp	.+4      	; 0x4074 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    4070:	1c 82       	std	Y+4, r1	; 0x04
    4072:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4074:	8e 81       	ldd	r24, Y+6	; 0x06
    4076:	9f 81       	ldd	r25, Y+7	; 0x07
    4078:	0e 94 93 1b 	call	0x3726	; 0x3726 <xStreamBufferSpacesAvailable>
    407c:	9c 01       	movw	r18, r24
    407e:	8b 81       	ldd	r24, Y+3	; 0x03
    4080:	9c 81       	ldd	r25, Y+4	; 0x04
    4082:	82 17       	cp	r24, r18
    4084:	93 07       	cpc	r25, r19
    4086:	18 f0       	brcs	.+6      	; 0x408e <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    4088:	81 e0       	ldi	r24, 0x01	; 1
    408a:	8d 83       	std	Y+5, r24	; 0x05
    408c:	01 c0       	rjmp	.+2      	; 0x4090 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    408e:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    4090:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4092:	27 96       	adiw	r28, 0x07	; 7
    4094:	0f b6       	in	r0, 0x3f	; 63
    4096:	f8 94       	cli
    4098:	de bf       	out	0x3e, r29	; 62
    409a:	0f be       	out	0x3f, r0	; 63
    409c:	cd bf       	out	0x3d, r28	; 61
    409e:	cf 91       	pop	r28
    40a0:	df 91       	pop	r29
    40a2:	08 95       	ret

000040a4 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    40a4:	cf 92       	push	r12
    40a6:	df 92       	push	r13
    40a8:	ef 92       	push	r14
    40aa:	ff 92       	push	r15
    40ac:	0f 93       	push	r16
    40ae:	df 93       	push	r29
    40b0:	cf 93       	push	r28
    40b2:	cd b7       	in	r28, 0x3d	; 61
    40b4:	de b7       	in	r29, 0x3e	; 62
    40b6:	28 97       	sbiw	r28, 0x08	; 8
    40b8:	0f b6       	in	r0, 0x3f	; 63
    40ba:	f8 94       	cli
    40bc:	de bf       	out	0x3e, r29	; 62
    40be:	0f be       	out	0x3f, r0	; 63
    40c0:	cd bf       	out	0x3d, r28	; 61
    40c2:	9e 83       	std	Y+6, r25	; 0x06
    40c4:	8d 83       	std	Y+5, r24	; 0x05
    40c6:	78 87       	std	Y+8, r23	; 0x08
    40c8:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    40ca:	8d 81       	ldd	r24, Y+5	; 0x05
    40cc:	9e 81       	ldd	r25, Y+6	; 0x06
    40ce:	9c 83       	std	Y+4, r25	; 0x04
    40d0:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    40d2:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    40d4:	eb 81       	ldd	r30, Y+3	; 0x03
    40d6:	fc 81       	ldd	r31, Y+4	; 0x04
    40d8:	80 85       	ldd	r24, Z+8	; 0x08
    40da:	91 85       	ldd	r25, Z+9	; 0x09
    40dc:	00 97       	sbiw	r24, 0x00	; 0
    40de:	c1 f0       	breq	.+48     	; 0x4110 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    40e0:	eb 81       	ldd	r30, Y+3	; 0x03
    40e2:	fc 81       	ldd	r31, Y+4	; 0x04
    40e4:	80 85       	ldd	r24, Z+8	; 0x08
    40e6:	91 85       	ldd	r25, Z+9	; 0x09
    40e8:	ef 81       	ldd	r30, Y+7	; 0x07
    40ea:	f8 85       	ldd	r31, Y+8	; 0x08
    40ec:	60 e0       	ldi	r22, 0x00	; 0
    40ee:	20 e0       	ldi	r18, 0x00	; 0
    40f0:	30 e0       	ldi	r19, 0x00	; 0
    40f2:	40 e0       	ldi	r20, 0x00	; 0
    40f4:	50 e0       	ldi	r21, 0x00	; 0
    40f6:	00 e0       	ldi	r16, 0x00	; 0
    40f8:	ee 24       	eor	r14, r14
    40fa:	ff 24       	eor	r15, r15
    40fc:	6f 01       	movw	r12, r30
    40fe:	0e 94 5d 31 	call	0x62ba	; 0x62ba <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4102:	eb 81       	ldd	r30, Y+3	; 0x03
    4104:	fc 81       	ldd	r31, Y+4	; 0x04
    4106:	11 86       	std	Z+9, r1	; 0x09
    4108:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	8a 83       	std	Y+2, r24	; 0x02
    410e:	01 c0       	rjmp	.+2      	; 0x4112 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    4110:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4112:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4114:	28 96       	adiw	r28, 0x08	; 8
    4116:	0f b6       	in	r0, 0x3f	; 63
    4118:	f8 94       	cli
    411a:	de bf       	out	0x3e, r29	; 62
    411c:	0f be       	out	0x3f, r0	; 63
    411e:	cd bf       	out	0x3d, r28	; 61
    4120:	cf 91       	pop	r28
    4122:	df 91       	pop	r29
    4124:	0f 91       	pop	r16
    4126:	ff 90       	pop	r15
    4128:	ef 90       	pop	r14
    412a:	df 90       	pop	r13
    412c:	cf 90       	pop	r12
    412e:	08 95       	ret

00004130 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    4130:	cf 92       	push	r12
    4132:	df 92       	push	r13
    4134:	ef 92       	push	r14
    4136:	ff 92       	push	r15
    4138:	0f 93       	push	r16
    413a:	df 93       	push	r29
    413c:	cf 93       	push	r28
    413e:	cd b7       	in	r28, 0x3d	; 61
    4140:	de b7       	in	r29, 0x3e	; 62
    4142:	28 97       	sbiw	r28, 0x08	; 8
    4144:	0f b6       	in	r0, 0x3f	; 63
    4146:	f8 94       	cli
    4148:	de bf       	out	0x3e, r29	; 62
    414a:	0f be       	out	0x3f, r0	; 63
    414c:	cd bf       	out	0x3d, r28	; 61
    414e:	9e 83       	std	Y+6, r25	; 0x06
    4150:	8d 83       	std	Y+5, r24	; 0x05
    4152:	78 87       	std	Y+8, r23	; 0x08
    4154:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4156:	8d 81       	ldd	r24, Y+5	; 0x05
    4158:	9e 81       	ldd	r25, Y+6	; 0x06
    415a:	9c 83       	std	Y+4, r25	; 0x04
    415c:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    415e:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    4160:	eb 81       	ldd	r30, Y+3	; 0x03
    4162:	fc 81       	ldd	r31, Y+4	; 0x04
    4164:	82 85       	ldd	r24, Z+10	; 0x0a
    4166:	93 85       	ldd	r25, Z+11	; 0x0b
    4168:	00 97       	sbiw	r24, 0x00	; 0
    416a:	c1 f0       	breq	.+48     	; 0x419c <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    416c:	eb 81       	ldd	r30, Y+3	; 0x03
    416e:	fc 81       	ldd	r31, Y+4	; 0x04
    4170:	82 85       	ldd	r24, Z+10	; 0x0a
    4172:	93 85       	ldd	r25, Z+11	; 0x0b
    4174:	ef 81       	ldd	r30, Y+7	; 0x07
    4176:	f8 85       	ldd	r31, Y+8	; 0x08
    4178:	60 e0       	ldi	r22, 0x00	; 0
    417a:	20 e0       	ldi	r18, 0x00	; 0
    417c:	30 e0       	ldi	r19, 0x00	; 0
    417e:	40 e0       	ldi	r20, 0x00	; 0
    4180:	50 e0       	ldi	r21, 0x00	; 0
    4182:	00 e0       	ldi	r16, 0x00	; 0
    4184:	ee 24       	eor	r14, r14
    4186:	ff 24       	eor	r15, r15
    4188:	6f 01       	movw	r12, r30
    418a:	0e 94 5d 31 	call	0x62ba	; 0x62ba <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    418e:	eb 81       	ldd	r30, Y+3	; 0x03
    4190:	fc 81       	ldd	r31, Y+4	; 0x04
    4192:	13 86       	std	Z+11, r1	; 0x0b
    4194:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    4196:	81 e0       	ldi	r24, 0x01	; 1
    4198:	8a 83       	std	Y+2, r24	; 0x02
    419a:	01 c0       	rjmp	.+2      	; 0x419e <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    419c:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    419e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    41a0:	28 96       	adiw	r28, 0x08	; 8
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	de bf       	out	0x3e, r29	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	cd bf       	out	0x3d, r28	; 61
    41ac:	cf 91       	pop	r28
    41ae:	df 91       	pop	r29
    41b0:	0f 91       	pop	r16
    41b2:	ff 90       	pop	r15
    41b4:	ef 90       	pop	r14
    41b6:	df 90       	pop	r13
    41b8:	cf 90       	pop	r12
    41ba:	08 95       	ret

000041bc <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    41bc:	df 93       	push	r29
    41be:	cf 93       	push	r28
    41c0:	cd b7       	in	r28, 0x3d	; 61
    41c2:	de b7       	in	r29, 0x3e	; 62
    41c4:	2e 97       	sbiw	r28, 0x0e	; 14
    41c6:	0f b6       	in	r0, 0x3f	; 63
    41c8:	f8 94       	cli
    41ca:	de bf       	out	0x3e, r29	; 62
    41cc:	0f be       	out	0x3f, r0	; 63
    41ce:	cd bf       	out	0x3d, r28	; 61
    41d0:	9c 83       	std	Y+4, r25	; 0x04
    41d2:	8b 83       	std	Y+3, r24	; 0x03
    41d4:	7e 83       	std	Y+6, r23	; 0x06
    41d6:	6d 83       	std	Y+5, r22	; 0x05
    41d8:	58 87       	std	Y+8, r21	; 0x08
    41da:	4f 83       	std	Y+7, r20	; 0x07
    41dc:	3a 87       	std	Y+10, r19	; 0x0a
    41de:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    41e0:	eb 81       	ldd	r30, Y+3	; 0x03
    41e2:	fc 81       	ldd	r31, Y+4	; 0x04
    41e4:	24 81       	ldd	r18, Z+4	; 0x04
    41e6:	35 81       	ldd	r19, Z+5	; 0x05
    41e8:	89 85       	ldd	r24, Y+9	; 0x09
    41ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    41ec:	a9 01       	movw	r20, r18
    41ee:	48 1b       	sub	r20, r24
    41f0:	59 0b       	sbc	r21, r25
    41f2:	ca 01       	movw	r24, r20
    41f4:	2f 81       	ldd	r18, Y+7	; 0x07
    41f6:	38 85       	ldd	r19, Y+8	; 0x08
    41f8:	3e 87       	std	Y+14, r19	; 0x0e
    41fa:	2d 87       	std	Y+13, r18	; 0x0d
    41fc:	9c 87       	std	Y+12, r25	; 0x0c
    41fe:	8b 87       	std	Y+11, r24	; 0x0b
    4200:	4b 85       	ldd	r20, Y+11	; 0x0b
    4202:	5c 85       	ldd	r21, Y+12	; 0x0c
    4204:	8d 85       	ldd	r24, Y+13	; 0x0d
    4206:	9e 85       	ldd	r25, Y+14	; 0x0e
    4208:	84 17       	cp	r24, r20
    420a:	95 07       	cpc	r25, r21
    420c:	20 f4       	brcc	.+8      	; 0x4216 <prvWriteBytesToBuffer+0x5a>
    420e:	2d 85       	ldd	r18, Y+13	; 0x0d
    4210:	3e 85       	ldd	r19, Y+14	; 0x0e
    4212:	3c 87       	std	Y+12, r19	; 0x0c
    4214:	2b 87       	std	Y+11, r18	; 0x0b
    4216:	4b 85       	ldd	r20, Y+11	; 0x0b
    4218:	5c 85       	ldd	r21, Y+12	; 0x0c
    421a:	5a 83       	std	Y+2, r21	; 0x02
    421c:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    421e:	eb 81       	ldd	r30, Y+3	; 0x03
    4220:	fc 81       	ldd	r31, Y+4	; 0x04
    4222:	24 85       	ldd	r18, Z+12	; 0x0c
    4224:	35 85       	ldd	r19, Z+13	; 0x0d
    4226:	89 85       	ldd	r24, Y+9	; 0x09
    4228:	9a 85       	ldd	r25, Y+10	; 0x0a
    422a:	82 0f       	add	r24, r18
    422c:	93 1f       	adc	r25, r19
    422e:	2d 81       	ldd	r18, Y+5	; 0x05
    4230:	3e 81       	ldd	r19, Y+6	; 0x06
    4232:	49 81       	ldd	r20, Y+1	; 0x01
    4234:	5a 81       	ldd	r21, Y+2	; 0x02
    4236:	b9 01       	movw	r22, r18
    4238:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    423c:	2f 81       	ldd	r18, Y+7	; 0x07
    423e:	38 85       	ldd	r19, Y+8	; 0x08
    4240:	89 81       	ldd	r24, Y+1	; 0x01
    4242:	9a 81       	ldd	r25, Y+2	; 0x02
    4244:	82 17       	cp	r24, r18
    4246:	93 07       	cpc	r25, r19
    4248:	b0 f4       	brcc	.+44     	; 0x4276 <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    424a:	eb 81       	ldd	r30, Y+3	; 0x03
    424c:	fc 81       	ldd	r31, Y+4	; 0x04
    424e:	64 85       	ldd	r22, Z+12	; 0x0c
    4250:	75 85       	ldd	r23, Z+13	; 0x0d
    4252:	2d 81       	ldd	r18, Y+5	; 0x05
    4254:	3e 81       	ldd	r19, Y+6	; 0x06
    4256:	89 81       	ldd	r24, Y+1	; 0x01
    4258:	9a 81       	ldd	r25, Y+2	; 0x02
    425a:	a9 01       	movw	r20, r18
    425c:	48 0f       	add	r20, r24
    425e:	59 1f       	adc	r21, r25
    4260:	2f 81       	ldd	r18, Y+7	; 0x07
    4262:	38 85       	ldd	r19, Y+8	; 0x08
    4264:	89 81       	ldd	r24, Y+1	; 0x01
    4266:	9a 81       	ldd	r25, Y+2	; 0x02
    4268:	28 1b       	sub	r18, r24
    426a:	39 0b       	sbc	r19, r25
    426c:	cb 01       	movw	r24, r22
    426e:	ba 01       	movw	r22, r20
    4270:	a9 01       	movw	r20, r18
    4272:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    4276:	29 85       	ldd	r18, Y+9	; 0x09
    4278:	3a 85       	ldd	r19, Y+10	; 0x0a
    427a:	8f 81       	ldd	r24, Y+7	; 0x07
    427c:	98 85       	ldd	r25, Y+8	; 0x08
    427e:	82 0f       	add	r24, r18
    4280:	93 1f       	adc	r25, r19
    4282:	9a 87       	std	Y+10, r25	; 0x0a
    4284:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    4286:	eb 81       	ldd	r30, Y+3	; 0x03
    4288:	fc 81       	ldd	r31, Y+4	; 0x04
    428a:	24 81       	ldd	r18, Z+4	; 0x04
    428c:	35 81       	ldd	r19, Z+5	; 0x05
    428e:	89 85       	ldd	r24, Y+9	; 0x09
    4290:	9a 85       	ldd	r25, Y+10	; 0x0a
    4292:	82 17       	cp	r24, r18
    4294:	93 07       	cpc	r25, r19
    4296:	50 f0       	brcs	.+20     	; 0x42ac <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    4298:	eb 81       	ldd	r30, Y+3	; 0x03
    429a:	fc 81       	ldd	r31, Y+4	; 0x04
    429c:	24 81       	ldd	r18, Z+4	; 0x04
    429e:	35 81       	ldd	r19, Z+5	; 0x05
    42a0:	89 85       	ldd	r24, Y+9	; 0x09
    42a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    42a4:	82 1b       	sub	r24, r18
    42a6:	93 0b       	sbc	r25, r19
    42a8:	9a 87       	std	Y+10, r25	; 0x0a
    42aa:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    42ac:	89 85       	ldd	r24, Y+9	; 0x09
    42ae:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    42b0:	2e 96       	adiw	r28, 0x0e	; 14
    42b2:	0f b6       	in	r0, 0x3f	; 63
    42b4:	f8 94       	cli
    42b6:	de bf       	out	0x3e, r29	; 62
    42b8:	0f be       	out	0x3f, r0	; 63
    42ba:	cd bf       	out	0x3d, r28	; 61
    42bc:	cf 91       	pop	r28
    42be:	df 91       	pop	r29
    42c0:	08 95       	ret

000042c2 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    42c2:	df 93       	push	r29
    42c4:	cf 93       	push	r28
    42c6:	cd b7       	in	r28, 0x3d	; 61
    42c8:	de b7       	in	r29, 0x3e	; 62
    42ca:	2e 97       	sbiw	r28, 0x0e	; 14
    42cc:	0f b6       	in	r0, 0x3f	; 63
    42ce:	f8 94       	cli
    42d0:	de bf       	out	0x3e, r29	; 62
    42d2:	0f be       	out	0x3f, r0	; 63
    42d4:	cd bf       	out	0x3d, r28	; 61
    42d6:	9c 83       	std	Y+4, r25	; 0x04
    42d8:	8b 83       	std	Y+3, r24	; 0x03
    42da:	7e 83       	std	Y+6, r23	; 0x06
    42dc:	6d 83       	std	Y+5, r22	; 0x05
    42de:	58 87       	std	Y+8, r21	; 0x08
    42e0:	4f 83       	std	Y+7, r20	; 0x07
    42e2:	3a 87       	std	Y+10, r19	; 0x0a
    42e4:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    42e6:	eb 81       	ldd	r30, Y+3	; 0x03
    42e8:	fc 81       	ldd	r31, Y+4	; 0x04
    42ea:	24 81       	ldd	r18, Z+4	; 0x04
    42ec:	35 81       	ldd	r19, Z+5	; 0x05
    42ee:	89 85       	ldd	r24, Y+9	; 0x09
    42f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    42f2:	a9 01       	movw	r20, r18
    42f4:	48 1b       	sub	r20, r24
    42f6:	59 0b       	sbc	r21, r25
    42f8:	ca 01       	movw	r24, r20
    42fa:	2f 81       	ldd	r18, Y+7	; 0x07
    42fc:	38 85       	ldd	r19, Y+8	; 0x08
    42fe:	3e 87       	std	Y+14, r19	; 0x0e
    4300:	2d 87       	std	Y+13, r18	; 0x0d
    4302:	9c 87       	std	Y+12, r25	; 0x0c
    4304:	8b 87       	std	Y+11, r24	; 0x0b
    4306:	4b 85       	ldd	r20, Y+11	; 0x0b
    4308:	5c 85       	ldd	r21, Y+12	; 0x0c
    430a:	8d 85       	ldd	r24, Y+13	; 0x0d
    430c:	9e 85       	ldd	r25, Y+14	; 0x0e
    430e:	84 17       	cp	r24, r20
    4310:	95 07       	cpc	r25, r21
    4312:	20 f4       	brcc	.+8      	; 0x431c <prvReadBytesFromBuffer+0x5a>
    4314:	2d 85       	ldd	r18, Y+13	; 0x0d
    4316:	3e 85       	ldd	r19, Y+14	; 0x0e
    4318:	3c 87       	std	Y+12, r19	; 0x0c
    431a:	2b 87       	std	Y+11, r18	; 0x0b
    431c:	4b 85       	ldd	r20, Y+11	; 0x0b
    431e:	5c 85       	ldd	r21, Y+12	; 0x0c
    4320:	5a 83       	std	Y+2, r21	; 0x02
    4322:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4324:	eb 81       	ldd	r30, Y+3	; 0x03
    4326:	fc 81       	ldd	r31, Y+4	; 0x04
    4328:	24 85       	ldd	r18, Z+12	; 0x0c
    432a:	35 85       	ldd	r19, Z+13	; 0x0d
    432c:	89 85       	ldd	r24, Y+9	; 0x09
    432e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4330:	a9 01       	movw	r20, r18
    4332:	48 0f       	add	r20, r24
    4334:	59 1f       	adc	r21, r25
    4336:	8d 81       	ldd	r24, Y+5	; 0x05
    4338:	9e 81       	ldd	r25, Y+6	; 0x06
    433a:	29 81       	ldd	r18, Y+1	; 0x01
    433c:	3a 81       	ldd	r19, Y+2	; 0x02
    433e:	ba 01       	movw	r22, r20
    4340:	a9 01       	movw	r20, r18
    4342:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    4346:	2f 81       	ldd	r18, Y+7	; 0x07
    4348:	38 85       	ldd	r19, Y+8	; 0x08
    434a:	89 81       	ldd	r24, Y+1	; 0x01
    434c:	9a 81       	ldd	r25, Y+2	; 0x02
    434e:	82 17       	cp	r24, r18
    4350:	93 07       	cpc	r25, r19
    4352:	b0 f4       	brcc	.+44     	; 0x4380 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4354:	2d 81       	ldd	r18, Y+5	; 0x05
    4356:	3e 81       	ldd	r19, Y+6	; 0x06
    4358:	89 81       	ldd	r24, Y+1	; 0x01
    435a:	9a 81       	ldd	r25, Y+2	; 0x02
    435c:	b9 01       	movw	r22, r18
    435e:	68 0f       	add	r22, r24
    4360:	79 1f       	adc	r23, r25
    4362:	eb 81       	ldd	r30, Y+3	; 0x03
    4364:	fc 81       	ldd	r31, Y+4	; 0x04
    4366:	44 85       	ldd	r20, Z+12	; 0x0c
    4368:	55 85       	ldd	r21, Z+13	; 0x0d
    436a:	2f 81       	ldd	r18, Y+7	; 0x07
    436c:	38 85       	ldd	r19, Y+8	; 0x08
    436e:	89 81       	ldd	r24, Y+1	; 0x01
    4370:	9a 81       	ldd	r25, Y+2	; 0x02
    4372:	28 1b       	sub	r18, r24
    4374:	39 0b       	sbc	r19, r25
    4376:	cb 01       	movw	r24, r22
    4378:	ba 01       	movw	r22, r20
    437a:	a9 01       	movw	r20, r18
    437c:	0e 94 d6 42 	call	0x85ac	; 0x85ac <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    4380:	29 85       	ldd	r18, Y+9	; 0x09
    4382:	3a 85       	ldd	r19, Y+10	; 0x0a
    4384:	8f 81       	ldd	r24, Y+7	; 0x07
    4386:	98 85       	ldd	r25, Y+8	; 0x08
    4388:	82 0f       	add	r24, r18
    438a:	93 1f       	adc	r25, r19
    438c:	9a 87       	std	Y+10, r25	; 0x0a
    438e:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    4390:	eb 81       	ldd	r30, Y+3	; 0x03
    4392:	fc 81       	ldd	r31, Y+4	; 0x04
    4394:	24 81       	ldd	r18, Z+4	; 0x04
    4396:	35 81       	ldd	r19, Z+5	; 0x05
    4398:	89 85       	ldd	r24, Y+9	; 0x09
    439a:	9a 85       	ldd	r25, Y+10	; 0x0a
    439c:	82 17       	cp	r24, r18
    439e:	93 07       	cpc	r25, r19
    43a0:	50 f0       	brcs	.+20     	; 0x43b6 <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    43a2:	eb 81       	ldd	r30, Y+3	; 0x03
    43a4:	fc 81       	ldd	r31, Y+4	; 0x04
    43a6:	24 81       	ldd	r18, Z+4	; 0x04
    43a8:	35 81       	ldd	r19, Z+5	; 0x05
    43aa:	89 85       	ldd	r24, Y+9	; 0x09
    43ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    43ae:	82 1b       	sub	r24, r18
    43b0:	93 0b       	sbc	r25, r19
    43b2:	9a 87       	std	Y+10, r25	; 0x0a
    43b4:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    43b6:	89 85       	ldd	r24, Y+9	; 0x09
    43b8:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    43ba:	2e 96       	adiw	r28, 0x0e	; 14
    43bc:	0f b6       	in	r0, 0x3f	; 63
    43be:	f8 94       	cli
    43c0:	de bf       	out	0x3e, r29	; 62
    43c2:	0f be       	out	0x3f, r0	; 63
    43c4:	cd bf       	out	0x3d, r28	; 61
    43c6:	cf 91       	pop	r28
    43c8:	df 91       	pop	r29
    43ca:	08 95       	ret

000043cc <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    43cc:	df 93       	push	r29
    43ce:	cf 93       	push	r28
    43d0:	00 d0       	rcall	.+0      	; 0x43d2 <prvBytesInBuffer+0x6>
    43d2:	00 d0       	rcall	.+0      	; 0x43d4 <prvBytesInBuffer+0x8>
    43d4:	cd b7       	in	r28, 0x3d	; 61
    43d6:	de b7       	in	r29, 0x3e	; 62
    43d8:	9c 83       	std	Y+4, r25	; 0x04
    43da:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    43dc:	eb 81       	ldd	r30, Y+3	; 0x03
    43de:	fc 81       	ldd	r31, Y+4	; 0x04
    43e0:	24 81       	ldd	r18, Z+4	; 0x04
    43e2:	35 81       	ldd	r19, Z+5	; 0x05
    43e4:	eb 81       	ldd	r30, Y+3	; 0x03
    43e6:	fc 81       	ldd	r31, Y+4	; 0x04
    43e8:	82 81       	ldd	r24, Z+2	; 0x02
    43ea:	93 81       	ldd	r25, Z+3	; 0x03
    43ec:	82 0f       	add	r24, r18
    43ee:	93 1f       	adc	r25, r19
    43f0:	9a 83       	std	Y+2, r25	; 0x02
    43f2:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    43f4:	eb 81       	ldd	r30, Y+3	; 0x03
    43f6:	fc 81       	ldd	r31, Y+4	; 0x04
    43f8:	20 81       	ld	r18, Z
    43fa:	31 81       	ldd	r19, Z+1	; 0x01
    43fc:	89 81       	ldd	r24, Y+1	; 0x01
    43fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4400:	82 1b       	sub	r24, r18
    4402:	93 0b       	sbc	r25, r19
    4404:	9a 83       	std	Y+2, r25	; 0x02
    4406:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    4408:	eb 81       	ldd	r30, Y+3	; 0x03
    440a:	fc 81       	ldd	r31, Y+4	; 0x04
    440c:	24 81       	ldd	r18, Z+4	; 0x04
    440e:	35 81       	ldd	r19, Z+5	; 0x05
    4410:	89 81       	ldd	r24, Y+1	; 0x01
    4412:	9a 81       	ldd	r25, Y+2	; 0x02
    4414:	82 17       	cp	r24, r18
    4416:	93 07       	cpc	r25, r19
    4418:	50 f0       	brcs	.+20     	; 0x442e <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    441a:	eb 81       	ldd	r30, Y+3	; 0x03
    441c:	fc 81       	ldd	r31, Y+4	; 0x04
    441e:	24 81       	ldd	r18, Z+4	; 0x04
    4420:	35 81       	ldd	r19, Z+5	; 0x05
    4422:	89 81       	ldd	r24, Y+1	; 0x01
    4424:	9a 81       	ldd	r25, Y+2	; 0x02
    4426:	82 1b       	sub	r24, r18
    4428:	93 0b       	sbc	r25, r19
    442a:	9a 83       	std	Y+2, r25	; 0x02
    442c:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    442e:	89 81       	ldd	r24, Y+1	; 0x01
    4430:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4432:	0f 90       	pop	r0
    4434:	0f 90       	pop	r0
    4436:	0f 90       	pop	r0
    4438:	0f 90       	pop	r0
    443a:	cf 91       	pop	r28
    443c:	df 91       	pop	r29
    443e:	08 95       	ret

00004440 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
                                          uint8_t * const pucBuffer,
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags )
{
    4440:	0f 93       	push	r16
    4442:	df 93       	push	r29
    4444:	cf 93       	push	r28
    4446:	cd b7       	in	r28, 0x3d	; 61
    4448:	de b7       	in	r29, 0x3e	; 62
    444a:	29 97       	sbiw	r28, 0x09	; 9
    444c:	0f b6       	in	r0, 0x3f	; 63
    444e:	f8 94       	cli
    4450:	de bf       	out	0x3e, r29	; 62
    4452:	0f be       	out	0x3f, r0	; 63
    4454:	cd bf       	out	0x3d, r28	; 61
    4456:	9a 83       	std	Y+2, r25	; 0x02
    4458:	89 83       	std	Y+1, r24	; 0x01
    445a:	7c 83       	std	Y+4, r23	; 0x04
    445c:	6b 83       	std	Y+3, r22	; 0x03
    445e:	5e 83       	std	Y+6, r21	; 0x06
    4460:	4d 83       	std	Y+5, r20	; 0x05
    4462:	38 87       	std	Y+8, r19	; 0x08
    4464:	2f 83       	std	Y+7, r18	; 0x07
    4466:	09 87       	std	Y+9, r16	; 0x09
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    4468:	89 81       	ldd	r24, Y+1	; 0x01
    446a:	9a 81       	ldd	r25, Y+2	; 0x02
    446c:	60 e0       	ldi	r22, 0x00	; 0
    446e:	70 e0       	ldi	r23, 0x00	; 0
    4470:	4f e0       	ldi	r20, 0x0F	; 15
    4472:	50 e0       	ldi	r21, 0x00	; 0
    4474:	0e 94 df 42 	call	0x85be	; 0x85be <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    4478:	e9 81       	ldd	r30, Y+1	; 0x01
    447a:	fa 81       	ldd	r31, Y+2	; 0x02
    447c:	8b 81       	ldd	r24, Y+3	; 0x03
    447e:	9c 81       	ldd	r25, Y+4	; 0x04
    4480:	95 87       	std	Z+13, r25	; 0x0d
    4482:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    4484:	e9 81       	ldd	r30, Y+1	; 0x01
    4486:	fa 81       	ldd	r31, Y+2	; 0x02
    4488:	8d 81       	ldd	r24, Y+5	; 0x05
    448a:	9e 81       	ldd	r25, Y+6	; 0x06
    448c:	95 83       	std	Z+5, r25	; 0x05
    448e:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    4490:	e9 81       	ldd	r30, Y+1	; 0x01
    4492:	fa 81       	ldd	r31, Y+2	; 0x02
    4494:	8f 81       	ldd	r24, Y+7	; 0x07
    4496:	98 85       	ldd	r25, Y+8	; 0x08
    4498:	97 83       	std	Z+7, r25	; 0x07
    449a:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    449c:	e9 81       	ldd	r30, Y+1	; 0x01
    449e:	fa 81       	ldd	r31, Y+2	; 0x02
    44a0:	89 85       	ldd	r24, Y+9	; 0x09
    44a2:	86 87       	std	Z+14, r24	; 0x0e
}
    44a4:	29 96       	adiw	r28, 0x09	; 9
    44a6:	0f b6       	in	r0, 0x3f	; 63
    44a8:	f8 94       	cli
    44aa:	de bf       	out	0x3e, r29	; 62
    44ac:	0f be       	out	0x3f, r0	; 63
    44ae:	cd bf       	out	0x3d, r28	; 61
    44b0:	cf 91       	pop	r28
    44b2:	df 91       	pop	r29
    44b4:	0f 91       	pop	r16
    44b6:	08 95       	ret

000044b8 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    44b8:	8f 92       	push	r8
    44ba:	9f 92       	push	r9
    44bc:	af 92       	push	r10
    44be:	bf 92       	push	r11
    44c0:	cf 92       	push	r12
    44c2:	df 92       	push	r13
    44c4:	ef 92       	push	r14
    44c6:	ff 92       	push	r15
    44c8:	0f 93       	push	r16
    44ca:	1f 93       	push	r17
    44cc:	df 93       	push	r29
    44ce:	cf 93       	push	r28
    44d0:	cd b7       	in	r28, 0x3d	; 61
    44d2:	de b7       	in	r29, 0x3e	; 62
    44d4:	60 97       	sbiw	r28, 0x10	; 16
    44d6:	0f b6       	in	r0, 0x3f	; 63
    44d8:	f8 94       	cli
    44da:	de bf       	out	0x3e, r29	; 62
    44dc:	0f be       	out	0x3f, r0	; 63
    44de:	cd bf       	out	0x3d, r28	; 61
    44e0:	9f 83       	std	Y+7, r25	; 0x07
    44e2:	8e 83       	std	Y+6, r24	; 0x06
    44e4:	79 87       	std	Y+9, r23	; 0x09
    44e6:	68 87       	std	Y+8, r22	; 0x08
    44e8:	5b 87       	std	Y+11, r21	; 0x0b
    44ea:	4a 87       	std	Y+10, r20	; 0x0a
    44ec:	3d 87       	std	Y+13, r19	; 0x0d
    44ee:	2c 87       	std	Y+12, r18	; 0x0c
    44f0:	0e 87       	std	Y+14, r16	; 0x0e
    44f2:	f8 8a       	std	Y+16, r15	; 0x10
    44f4:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    44f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    44f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    44fa:	0e 94 77 0e 	call	0x1cee	; 0x1cee <pvPortMalloc>
    44fe:	9a 83       	std	Y+2, r25	; 0x02
    4500:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    4502:	89 81       	ldd	r24, Y+1	; 0x01
    4504:	9a 81       	ldd	r25, Y+2	; 0x02
    4506:	00 97       	sbiw	r24, 0x00	; 0
    4508:	b1 f0       	breq	.+44     	; 0x4536 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    450a:	8c e3       	ldi	r24, 0x3C	; 60
    450c:	90 e0       	ldi	r25, 0x00	; 0
    450e:	0e 94 77 0e 	call	0x1cee	; 0x1cee <pvPortMalloc>
    4512:	9d 83       	std	Y+5, r25	; 0x05
    4514:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    4516:	8c 81       	ldd	r24, Y+4	; 0x04
    4518:	9d 81       	ldd	r25, Y+5	; 0x05
    451a:	00 97       	sbiw	r24, 0x00	; 0
    451c:	39 f0       	breq	.+14     	; 0x452c <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    451e:	ec 81       	ldd	r30, Y+4	; 0x04
    4520:	fd 81       	ldd	r31, Y+5	; 0x05
    4522:	89 81       	ldd	r24, Y+1	; 0x01
    4524:	9a 81       	ldd	r25, Y+2	; 0x02
    4526:	90 8f       	std	Z+24, r25	; 0x18
    4528:	87 8b       	std	Z+23, r24	; 0x17
    452a:	07 c0       	rjmp	.+14     	; 0x453a <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    452c:	89 81       	ldd	r24, Y+1	; 0x01
    452e:	9a 81       	ldd	r25, Y+2	; 0x02
    4530:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
    4534:	02 c0       	rjmp	.+4      	; 0x453a <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    4536:	1d 82       	std	Y+5, r1	; 0x05
    4538:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    453a:	8c 81       	ldd	r24, Y+4	; 0x04
    453c:	9d 81       	ldd	r25, Y+5	; 0x05
    453e:	00 97       	sbiw	r24, 0x00	; 0
    4540:	e9 f0       	breq	.+58     	; 0x457c <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4542:	8a 85       	ldd	r24, Y+10	; 0x0a
    4544:	9b 85       	ldd	r25, Y+11	; 0x0b
    4546:	9c 01       	movw	r18, r24
    4548:	40 e0       	ldi	r20, 0x00	; 0
    454a:	50 e0       	ldi	r21, 0x00	; 0
    454c:	8e 81       	ldd	r24, Y+6	; 0x06
    454e:	9f 81       	ldd	r25, Y+7	; 0x07
    4550:	68 85       	ldd	r22, Y+8	; 0x08
    4552:	79 85       	ldd	r23, Y+9	; 0x09
    4554:	ec 85       	ldd	r30, Y+12	; 0x0c
    4556:	fd 85       	ldd	r31, Y+13	; 0x0d
    4558:	af 85       	ldd	r26, Y+15	; 0x0f
    455a:	b8 89       	ldd	r27, Y+16	; 0x10
    455c:	ac 80       	ldd	r10, Y+4	; 0x04
    455e:	bd 80       	ldd	r11, Y+5	; 0x05
    4560:	8f 01       	movw	r16, r30
    4562:	ee 84       	ldd	r14, Y+14	; 0x0e
    4564:	6d 01       	movw	r12, r26
    4566:	88 24       	eor	r8, r8
    4568:	99 24       	eor	r9, r9
    456a:	0e 94 d4 22 	call	0x45a8	; 0x45a8 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    456e:	8c 81       	ldd	r24, Y+4	; 0x04
    4570:	9d 81       	ldd	r25, Y+5	; 0x05
    4572:	0e 94 99 23 	call	0x4732	; 0x4732 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    4576:	81 e0       	ldi	r24, 0x01	; 1
    4578:	8b 83       	std	Y+3, r24	; 0x03
    457a:	02 c0       	rjmp	.+4      	; 0x4580 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    457c:	8f ef       	ldi	r24, 0xFF	; 255
    457e:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    4580:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4582:	60 96       	adiw	r28, 0x10	; 16
    4584:	0f b6       	in	r0, 0x3f	; 63
    4586:	f8 94       	cli
    4588:	de bf       	out	0x3e, r29	; 62
    458a:	0f be       	out	0x3f, r0	; 63
    458c:	cd bf       	out	0x3d, r28	; 61
    458e:	cf 91       	pop	r28
    4590:	df 91       	pop	r29
    4592:	1f 91       	pop	r17
    4594:	0f 91       	pop	r16
    4596:	ff 90       	pop	r15
    4598:	ef 90       	pop	r14
    459a:	df 90       	pop	r13
    459c:	cf 90       	pop	r12
    459e:	bf 90       	pop	r11
    45a0:	af 90       	pop	r10
    45a2:	9f 90       	pop	r9
    45a4:	8f 90       	pop	r8
    45a6:	08 95       	ret

000045a8 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    45a8:	8f 92       	push	r8
    45aa:	9f 92       	push	r9
    45ac:	af 92       	push	r10
    45ae:	bf 92       	push	r11
    45b0:	cf 92       	push	r12
    45b2:	df 92       	push	r13
    45b4:	ef 92       	push	r14
    45b6:	0f 93       	push	r16
    45b8:	1f 93       	push	r17
    45ba:	df 93       	push	r29
    45bc:	cf 93       	push	r28
    45be:	cd b7       	in	r28, 0x3d	; 61
    45c0:	de b7       	in	r29, 0x3e	; 62
    45c2:	64 97       	sbiw	r28, 0x14	; 20
    45c4:	0f b6       	in	r0, 0x3f	; 63
    45c6:	f8 94       	cli
    45c8:	de bf       	out	0x3e, r29	; 62
    45ca:	0f be       	out	0x3f, r0	; 63
    45cc:	cd bf       	out	0x3d, r28	; 61
    45ce:	9d 83       	std	Y+5, r25	; 0x05
    45d0:	8c 83       	std	Y+4, r24	; 0x04
    45d2:	7f 83       	std	Y+7, r23	; 0x07
    45d4:	6e 83       	std	Y+6, r22	; 0x06
    45d6:	28 87       	std	Y+8, r18	; 0x08
    45d8:	39 87       	std	Y+9, r19	; 0x09
    45da:	4a 87       	std	Y+10, r20	; 0x0a
    45dc:	5b 87       	std	Y+11, r21	; 0x0b
    45de:	1d 87       	std	Y+13, r17	; 0x0d
    45e0:	0c 87       	std	Y+12, r16	; 0x0c
    45e2:	ee 86       	std	Y+14, r14	; 0x0e
    45e4:	d8 8a       	std	Y+16, r13	; 0x10
    45e6:	cf 86       	std	Y+15, r12	; 0x0f
    45e8:	ba 8a       	std	Y+18, r11	; 0x12
    45ea:	a9 8a       	std	Y+17, r10	; 0x11
    45ec:	9c 8a       	std	Y+20, r9	; 0x14
    45ee:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    45f0:	e9 89       	ldd	r30, Y+17	; 0x11
    45f2:	fa 89       	ldd	r31, Y+18	; 0x12
    45f4:	27 89       	ldd	r18, Z+23	; 0x17
    45f6:	30 8d       	ldd	r19, Z+24	; 0x18
    45f8:	88 85       	ldd	r24, Y+8	; 0x08
    45fa:	99 85       	ldd	r25, Y+9	; 0x09
    45fc:	01 97       	sbiw	r24, 0x01	; 1
    45fe:	82 0f       	add	r24, r18
    4600:	93 1f       	adc	r25, r19
    4602:	9b 83       	std	Y+3, r25	; 0x03
    4604:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    4606:	8e 81       	ldd	r24, Y+6	; 0x06
    4608:	9f 81       	ldd	r25, Y+7	; 0x07
    460a:	00 97       	sbiw	r24, 0x00	; 0
    460c:	51 f1       	breq	.+84     	; 0x4662 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    460e:	19 82       	std	Y+1, r1	; 0x01
    4610:	21 c0       	rjmp	.+66     	; 0x4654 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4612:	89 81       	ldd	r24, Y+1	; 0x01
    4614:	48 2f       	mov	r20, r24
    4616:	50 e0       	ldi	r21, 0x00	; 0
    4618:	89 81       	ldd	r24, Y+1	; 0x01
    461a:	28 2f       	mov	r18, r24
    461c:	30 e0       	ldi	r19, 0x00	; 0
    461e:	8e 81       	ldd	r24, Y+6	; 0x06
    4620:	9f 81       	ldd	r25, Y+7	; 0x07
    4622:	fc 01       	movw	r30, r24
    4624:	e2 0f       	add	r30, r18
    4626:	f3 1f       	adc	r31, r19
    4628:	20 81       	ld	r18, Z
    462a:	89 89       	ldd	r24, Y+17	; 0x11
    462c:	9a 89       	ldd	r25, Y+18	; 0x12
    462e:	84 0f       	add	r24, r20
    4630:	95 1f       	adc	r25, r21
    4632:	fc 01       	movw	r30, r24
    4634:	79 96       	adiw	r30, 0x19	; 25
    4636:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    4638:	89 81       	ldd	r24, Y+1	; 0x01
    463a:	28 2f       	mov	r18, r24
    463c:	30 e0       	ldi	r19, 0x00	; 0
    463e:	8e 81       	ldd	r24, Y+6	; 0x06
    4640:	9f 81       	ldd	r25, Y+7	; 0x07
    4642:	fc 01       	movw	r30, r24
    4644:	e2 0f       	add	r30, r18
    4646:	f3 1f       	adc	r31, r19
    4648:	80 81       	ld	r24, Z
    464a:	88 23       	and	r24, r24
    464c:	31 f0       	breq	.+12     	; 0x465a <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    464e:	89 81       	ldd	r24, Y+1	; 0x01
    4650:	8f 5f       	subi	r24, 0xFF	; 255
    4652:	89 83       	std	Y+1, r24	; 0x01
    4654:	89 81       	ldd	r24, Y+1	; 0x01
    4656:	8e 31       	cpi	r24, 0x1E	; 30
    4658:	e0 f2       	brcs	.-72     	; 0x4612 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    465a:	e9 89       	ldd	r30, Y+17	; 0x11
    465c:	fa 89       	ldd	r31, Y+18	; 0x12
    465e:	16 aa       	std	Z+54, r1	; 0x36
    4660:	03 c0       	rjmp	.+6      	; 0x4668 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4662:	e9 89       	ldd	r30, Y+17	; 0x11
    4664:	fa 89       	ldd	r31, Y+18	; 0x12
    4666:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4668:	8e 85       	ldd	r24, Y+14	; 0x0e
    466a:	8a 30       	cpi	r24, 0x0A	; 10
    466c:	10 f0       	brcs	.+4      	; 0x4672 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    466e:	89 e0       	ldi	r24, 0x09	; 9
    4670:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    4672:	e9 89       	ldd	r30, Y+17	; 0x11
    4674:	fa 89       	ldd	r31, Y+18	; 0x12
    4676:	8e 85       	ldd	r24, Y+14	; 0x0e
    4678:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    467a:	89 89       	ldd	r24, Y+17	; 0x11
    467c:	9a 89       	ldd	r25, Y+18	; 0x12
    467e:	02 96       	adiw	r24, 0x02	; 2
    4680:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4684:	89 89       	ldd	r24, Y+17	; 0x11
    4686:	9a 89       	ldd	r25, Y+18	; 0x12
    4688:	0c 96       	adiw	r24, 0x0c	; 12
    468a:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    468e:	e9 89       	ldd	r30, Y+17	; 0x11
    4690:	fa 89       	ldd	r31, Y+18	; 0x12
    4692:	89 89       	ldd	r24, Y+17	; 0x11
    4694:	9a 89       	ldd	r25, Y+18	; 0x12
    4696:	91 87       	std	Z+9, r25	; 0x09
    4698:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    469a:	8e 85       	ldd	r24, Y+14	; 0x0e
    469c:	28 2f       	mov	r18, r24
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	8a e0       	ldi	r24, 0x0A	; 10
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	82 1b       	sub	r24, r18
    46a6:	93 0b       	sbc	r25, r19
    46a8:	e9 89       	ldd	r30, Y+17	; 0x11
    46aa:	fa 89       	ldd	r31, Y+18	; 0x12
    46ac:	95 87       	std	Z+13, r25	; 0x0d
    46ae:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    46b0:	e9 89       	ldd	r30, Y+17	; 0x11
    46b2:	fa 89       	ldd	r31, Y+18	; 0x12
    46b4:	89 89       	ldd	r24, Y+17	; 0x11
    46b6:	9a 89       	ldd	r25, Y+18	; 0x12
    46b8:	93 8b       	std	Z+19, r25	; 0x13
    46ba:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    46bc:	89 89       	ldd	r24, Y+17	; 0x11
    46be:	9a 89       	ldd	r25, Y+18	; 0x12
    46c0:	c7 96       	adiw	r24, 0x37	; 55
    46c2:	60 e0       	ldi	r22, 0x00	; 0
    46c4:	70 e0       	ldi	r23, 0x00	; 0
    46c6:	44 e0       	ldi	r20, 0x04	; 4
    46c8:	50 e0       	ldi	r21, 0x00	; 0
    46ca:	0e 94 df 42 	call	0x85be	; 0x85be <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    46ce:	89 89       	ldd	r24, Y+17	; 0x11
    46d0:	9a 89       	ldd	r25, Y+18	; 0x12
    46d2:	cb 96       	adiw	r24, 0x3b	; 59
    46d4:	60 e0       	ldi	r22, 0x00	; 0
    46d6:	70 e0       	ldi	r23, 0x00	; 0
    46d8:	41 e0       	ldi	r20, 0x01	; 1
    46da:	50 e0       	ldi	r21, 0x00	; 0
    46dc:	0e 94 df 42 	call	0x85be	; 0x85be <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    46e0:	8a 81       	ldd	r24, Y+2	; 0x02
    46e2:	9b 81       	ldd	r25, Y+3	; 0x03
    46e4:	2c 81       	ldd	r18, Y+4	; 0x04
    46e6:	3d 81       	ldd	r19, Y+5	; 0x05
    46e8:	4c 85       	ldd	r20, Y+12	; 0x0c
    46ea:	5d 85       	ldd	r21, Y+13	; 0x0d
    46ec:	b9 01       	movw	r22, r18
    46ee:	0e 94 2d 10 	call	0x205a	; 0x205a <pxPortInitialiseStack>
    46f2:	e9 89       	ldd	r30, Y+17	; 0x11
    46f4:	fa 89       	ldd	r31, Y+18	; 0x12
    46f6:	91 83       	std	Z+1, r25	; 0x01
    46f8:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    46fa:	8f 85       	ldd	r24, Y+15	; 0x0f
    46fc:	98 89       	ldd	r25, Y+16	; 0x10
    46fe:	00 97       	sbiw	r24, 0x00	; 0
    4700:	31 f0       	breq	.+12     	; 0x470e <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4702:	ef 85       	ldd	r30, Y+15	; 0x0f
    4704:	f8 89       	ldd	r31, Y+16	; 0x10
    4706:	89 89       	ldd	r24, Y+17	; 0x11
    4708:	9a 89       	ldd	r25, Y+18	; 0x12
    470a:	91 83       	std	Z+1, r25	; 0x01
    470c:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    470e:	64 96       	adiw	r28, 0x14	; 20
    4710:	0f b6       	in	r0, 0x3f	; 63
    4712:	f8 94       	cli
    4714:	de bf       	out	0x3e, r29	; 62
    4716:	0f be       	out	0x3f, r0	; 63
    4718:	cd bf       	out	0x3d, r28	; 61
    471a:	cf 91       	pop	r28
    471c:	df 91       	pop	r29
    471e:	1f 91       	pop	r17
    4720:	0f 91       	pop	r16
    4722:	ef 90       	pop	r14
    4724:	df 90       	pop	r13
    4726:	cf 90       	pop	r12
    4728:	bf 90       	pop	r11
    472a:	af 90       	pop	r10
    472c:	9f 90       	pop	r9
    472e:	8f 90       	pop	r8
    4730:	08 95       	ret

00004732 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    4732:	df 93       	push	r29
    4734:	cf 93       	push	r28
    4736:	00 d0       	rcall	.+0      	; 0x4738 <prvAddNewTaskToReadyList+0x6>
    4738:	00 d0       	rcall	.+0      	; 0x473a <prvAddNewTaskToReadyList+0x8>
    473a:	cd b7       	in	r28, 0x3d	; 61
    473c:	de b7       	in	r29, 0x3e	; 62
    473e:	9c 83       	std	Y+4, r25	; 0x04
    4740:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    4742:	0f b6       	in	r0, 0x3f	; 63
    4744:	f8 94       	cli
    4746:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    4748:	80 91 89 07 	lds	r24, 0x0789
    474c:	8f 5f       	subi	r24, 0xFF	; 255
    474e:	80 93 89 07 	sts	0x0789, r24

        if( pxCurrentTCB == NULL )
    4752:	80 91 86 07 	lds	r24, 0x0786
    4756:	90 91 87 07 	lds	r25, 0x0787
    475a:	00 97       	sbiw	r24, 0x00	; 0
    475c:	69 f4       	brne	.+26     	; 0x4778 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    475e:	8b 81       	ldd	r24, Y+3	; 0x03
    4760:	9c 81       	ldd	r25, Y+4	; 0x04
    4762:	90 93 87 07 	sts	0x0787, r25
    4766:	80 93 86 07 	sts	0x0786, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    476a:	80 91 89 07 	lds	r24, 0x0789
    476e:	81 30       	cpi	r24, 0x01	; 1
    4770:	b9 f4       	brne	.+46     	; 0x47a0 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    4772:	0e 94 15 2d 	call	0x5a2a	; 0x5a2a <prvInitialiseTaskLists>
    4776:	14 c0       	rjmp	.+40     	; 0x47a0 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    4778:	80 91 8d 07 	lds	r24, 0x078D
    477c:	88 23       	and	r24, r24
    477e:	81 f4       	brne	.+32     	; 0x47a0 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4780:	e0 91 86 07 	lds	r30, 0x0786
    4784:	f0 91 87 07 	lds	r31, 0x0787
    4788:	96 89       	ldd	r25, Z+22	; 0x16
    478a:	eb 81       	ldd	r30, Y+3	; 0x03
    478c:	fc 81       	ldd	r31, Y+4	; 0x04
    478e:	86 89       	ldd	r24, Z+22	; 0x16
    4790:	89 17       	cp	r24, r25
    4792:	30 f0       	brcs	.+12     	; 0x47a0 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    4794:	8b 81       	ldd	r24, Y+3	; 0x03
    4796:	9c 81       	ldd	r25, Y+4	; 0x04
    4798:	90 93 87 07 	sts	0x0787, r25
    479c:	80 93 86 07 	sts	0x0786, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    47a0:	80 91 92 07 	lds	r24, 0x0792
    47a4:	8f 5f       	subi	r24, 0xFF	; 255
    47a6:	80 93 92 07 	sts	0x0792, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    47aa:	eb 81       	ldd	r30, Y+3	; 0x03
    47ac:	fc 81       	ldd	r31, Y+4	; 0x04
    47ae:	96 89       	ldd	r25, Z+22	; 0x16
    47b0:	80 91 8c 07 	lds	r24, 0x078C
    47b4:	89 17       	cp	r24, r25
    47b6:	28 f4       	brcc	.+10     	; 0x47c2 <prvAddNewTaskToReadyList+0x90>
    47b8:	eb 81       	ldd	r30, Y+3	; 0x03
    47ba:	fc 81       	ldd	r31, Y+4	; 0x04
    47bc:	86 89       	ldd	r24, Z+22	; 0x16
    47be:	80 93 8c 07 	sts	0x078C, r24
    47c2:	eb 81       	ldd	r30, Y+3	; 0x03
    47c4:	fc 81       	ldd	r31, Y+4	; 0x04
    47c6:	86 89       	ldd	r24, Z+22	; 0x16
    47c8:	28 2f       	mov	r18, r24
    47ca:	30 e0       	ldi	r19, 0x00	; 0
    47cc:	c9 01       	movw	r24, r18
    47ce:	88 0f       	add	r24, r24
    47d0:	99 1f       	adc	r25, r25
    47d2:	88 0f       	add	r24, r24
    47d4:	99 1f       	adc	r25, r25
    47d6:	88 0f       	add	r24, r24
    47d8:	99 1f       	adc	r25, r25
    47da:	82 0f       	add	r24, r18
    47dc:	93 1f       	adc	r25, r19
    47de:	fc 01       	movw	r30, r24
    47e0:	e8 56       	subi	r30, 0x68	; 104
    47e2:	f8 4f       	sbci	r31, 0xF8	; 248
    47e4:	81 81       	ldd	r24, Z+1	; 0x01
    47e6:	92 81       	ldd	r25, Z+2	; 0x02
    47e8:	9a 83       	std	Y+2, r25	; 0x02
    47ea:	89 83       	std	Y+1, r24	; 0x01
    47ec:	eb 81       	ldd	r30, Y+3	; 0x03
    47ee:	fc 81       	ldd	r31, Y+4	; 0x04
    47f0:	89 81       	ldd	r24, Y+1	; 0x01
    47f2:	9a 81       	ldd	r25, Y+2	; 0x02
    47f4:	95 83       	std	Z+5, r25	; 0x05
    47f6:	84 83       	std	Z+4, r24	; 0x04
    47f8:	e9 81       	ldd	r30, Y+1	; 0x01
    47fa:	fa 81       	ldd	r31, Y+2	; 0x02
    47fc:	84 81       	ldd	r24, Z+4	; 0x04
    47fe:	95 81       	ldd	r25, Z+5	; 0x05
    4800:	eb 81       	ldd	r30, Y+3	; 0x03
    4802:	fc 81       	ldd	r31, Y+4	; 0x04
    4804:	97 83       	std	Z+7, r25	; 0x07
    4806:	86 83       	std	Z+6, r24	; 0x06
    4808:	e9 81       	ldd	r30, Y+1	; 0x01
    480a:	fa 81       	ldd	r31, Y+2	; 0x02
    480c:	04 80       	ldd	r0, Z+4	; 0x04
    480e:	f5 81       	ldd	r31, Z+5	; 0x05
    4810:	e0 2d       	mov	r30, r0
    4812:	8b 81       	ldd	r24, Y+3	; 0x03
    4814:	9c 81       	ldd	r25, Y+4	; 0x04
    4816:	02 96       	adiw	r24, 0x02	; 2
    4818:	93 83       	std	Z+3, r25	; 0x03
    481a:	82 83       	std	Z+2, r24	; 0x02
    481c:	8b 81       	ldd	r24, Y+3	; 0x03
    481e:	9c 81       	ldd	r25, Y+4	; 0x04
    4820:	02 96       	adiw	r24, 0x02	; 2
    4822:	e9 81       	ldd	r30, Y+1	; 0x01
    4824:	fa 81       	ldd	r31, Y+2	; 0x02
    4826:	95 83       	std	Z+5, r25	; 0x05
    4828:	84 83       	std	Z+4, r24	; 0x04
    482a:	eb 81       	ldd	r30, Y+3	; 0x03
    482c:	fc 81       	ldd	r31, Y+4	; 0x04
    482e:	86 89       	ldd	r24, Z+22	; 0x16
    4830:	28 2f       	mov	r18, r24
    4832:	30 e0       	ldi	r19, 0x00	; 0
    4834:	c9 01       	movw	r24, r18
    4836:	88 0f       	add	r24, r24
    4838:	99 1f       	adc	r25, r25
    483a:	88 0f       	add	r24, r24
    483c:	99 1f       	adc	r25, r25
    483e:	88 0f       	add	r24, r24
    4840:	99 1f       	adc	r25, r25
    4842:	82 0f       	add	r24, r18
    4844:	93 1f       	adc	r25, r19
    4846:	88 56       	subi	r24, 0x68	; 104
    4848:	98 4f       	sbci	r25, 0xF8	; 248
    484a:	eb 81       	ldd	r30, Y+3	; 0x03
    484c:	fc 81       	ldd	r31, Y+4	; 0x04
    484e:	93 87       	std	Z+11, r25	; 0x0b
    4850:	82 87       	std	Z+10, r24	; 0x0a
    4852:	eb 81       	ldd	r30, Y+3	; 0x03
    4854:	fc 81       	ldd	r31, Y+4	; 0x04
    4856:	86 89       	ldd	r24, Z+22	; 0x16
    4858:	28 2f       	mov	r18, r24
    485a:	30 e0       	ldi	r19, 0x00	; 0
    485c:	c9 01       	movw	r24, r18
    485e:	88 0f       	add	r24, r24
    4860:	99 1f       	adc	r25, r25
    4862:	88 0f       	add	r24, r24
    4864:	99 1f       	adc	r25, r25
    4866:	88 0f       	add	r24, r24
    4868:	99 1f       	adc	r25, r25
    486a:	82 0f       	add	r24, r18
    486c:	93 1f       	adc	r25, r19
    486e:	fc 01       	movw	r30, r24
    4870:	e8 56       	subi	r30, 0x68	; 104
    4872:	f8 4f       	sbci	r31, 0xF8	; 248
    4874:	80 81       	ld	r24, Z
    4876:	8f 5f       	subi	r24, 0xFF	; 255
    4878:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    487a:	0f 90       	pop	r0
    487c:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    487e:	80 91 8d 07 	lds	r24, 0x078D
    4882:	88 23       	and	r24, r24
    4884:	61 f0       	breq	.+24     	; 0x489e <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4886:	e0 91 86 07 	lds	r30, 0x0786
    488a:	f0 91 87 07 	lds	r31, 0x0787
    488e:	96 89       	ldd	r25, Z+22	; 0x16
    4890:	eb 81       	ldd	r30, Y+3	; 0x03
    4892:	fc 81       	ldd	r31, Y+4	; 0x04
    4894:	86 89       	ldd	r24, Z+22	; 0x16
    4896:	98 17       	cp	r25, r24
    4898:	10 f4       	brcc	.+4      	; 0x489e <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    489a:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    489e:	0f 90       	pop	r0
    48a0:	0f 90       	pop	r0
    48a2:	0f 90       	pop	r0
    48a4:	0f 90       	pop	r0
    48a6:	cf 91       	pop	r28
    48a8:	df 91       	pop	r29
    48aa:	08 95       	ret

000048ac <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    48ac:	df 93       	push	r29
    48ae:	cf 93       	push	r28
    48b0:	00 d0       	rcall	.+0      	; 0x48b2 <vTaskDelete+0x6>
    48b2:	00 d0       	rcall	.+0      	; 0x48b4 <vTaskDelete+0x8>
    48b4:	00 d0       	rcall	.+0      	; 0x48b6 <vTaskDelete+0xa>
    48b6:	cd b7       	in	r28, 0x3d	; 61
    48b8:	de b7       	in	r29, 0x3e	; 62
    48ba:	9c 83       	std	Y+4, r25	; 0x04
    48bc:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    48be:	0f b6       	in	r0, 0x3f	; 63
    48c0:	f8 94       	cli
    48c2:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	9c 81       	ldd	r25, Y+4	; 0x04
    48c8:	00 97       	sbiw	r24, 0x00	; 0
    48ca:	39 f4       	brne	.+14     	; 0x48da <vTaskDelete+0x2e>
    48cc:	80 91 86 07 	lds	r24, 0x0786
    48d0:	90 91 87 07 	lds	r25, 0x0787
    48d4:	9e 83       	std	Y+6, r25	; 0x06
    48d6:	8d 83       	std	Y+5, r24	; 0x05
    48d8:	04 c0       	rjmp	.+8      	; 0x48e2 <vTaskDelete+0x36>
    48da:	8b 81       	ldd	r24, Y+3	; 0x03
    48dc:	9c 81       	ldd	r25, Y+4	; 0x04
    48de:	9e 83       	std	Y+6, r25	; 0x06
    48e0:	8d 83       	std	Y+5, r24	; 0x05
    48e2:	8d 81       	ldd	r24, Y+5	; 0x05
    48e4:	9e 81       	ldd	r25, Y+6	; 0x06
    48e6:	9a 83       	std	Y+2, r25	; 0x02
    48e8:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    48ea:	89 81       	ldd	r24, Y+1	; 0x01
    48ec:	9a 81       	ldd	r25, Y+2	; 0x02
    48ee:	02 96       	adiw	r24, 0x02	; 2
    48f0:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    48f4:	e9 81       	ldd	r30, Y+1	; 0x01
    48f6:	fa 81       	ldd	r31, Y+2	; 0x02
    48f8:	84 89       	ldd	r24, Z+20	; 0x14
    48fa:	95 89       	ldd	r25, Z+21	; 0x15
    48fc:	00 97       	sbiw	r24, 0x00	; 0
    48fe:	29 f0       	breq	.+10     	; 0x490a <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4900:	89 81       	ldd	r24, Y+1	; 0x01
    4902:	9a 81       	ldd	r25, Y+2	; 0x02
    4904:	0c 96       	adiw	r24, 0x0c	; 12
    4906:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    490a:	80 91 92 07 	lds	r24, 0x0792
    490e:	8f 5f       	subi	r24, 0xFF	; 255
    4910:	80 93 92 07 	sts	0x0792, r24

            if( pxTCB == pxCurrentTCB )
    4914:	20 91 86 07 	lds	r18, 0x0786
    4918:	30 91 87 07 	lds	r19, 0x0787
    491c:	89 81       	ldd	r24, Y+1	; 0x01
    491e:	9a 81       	ldd	r25, Y+2	; 0x02
    4920:	82 17       	cp	r24, r18
    4922:	93 07       	cpc	r25, r19
    4924:	81 f4       	brne	.+32     	; 0x4946 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4926:	89 81       	ldd	r24, Y+1	; 0x01
    4928:	9a 81       	ldd	r25, Y+2	; 0x02
    492a:	9c 01       	movw	r18, r24
    492c:	2e 5f       	subi	r18, 0xFE	; 254
    492e:	3f 4f       	sbci	r19, 0xFF	; 255
    4930:	81 e1       	ldi	r24, 0x11	; 17
    4932:	98 e0       	ldi	r25, 0x08	; 8
    4934:	b9 01       	movw	r22, r18
    4936:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    493a:	80 91 88 07 	lds	r24, 0x0788
    493e:	8f 5f       	subi	r24, 0xFF	; 255
    4940:	80 93 88 07 	sts	0x0788, r24
    4944:	07 c0       	rjmp	.+14     	; 0x4954 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    4946:	80 91 89 07 	lds	r24, 0x0789
    494a:	81 50       	subi	r24, 0x01	; 1
    494c:	80 93 89 07 	sts	0x0789, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    4950:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    4954:	0f 90       	pop	r0
    4956:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    4958:	20 91 86 07 	lds	r18, 0x0786
    495c:	30 91 87 07 	lds	r19, 0x0787
    4960:	89 81       	ldd	r24, Y+1	; 0x01
    4962:	9a 81       	ldd	r25, Y+2	; 0x02
    4964:	82 17       	cp	r24, r18
    4966:	93 07       	cpc	r25, r19
    4968:	21 f0       	breq	.+8      	; 0x4972 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    496a:	89 81       	ldd	r24, Y+1	; 0x01
    496c:	9a 81       	ldd	r25, Y+2	; 0x02
    496e:	0e 94 81 2d 	call	0x5b02	; 0x5b02 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    4972:	80 91 8d 07 	lds	r24, 0x078D
    4976:	88 23       	and	r24, r24
    4978:	59 f0       	breq	.+22     	; 0x4990 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    497a:	20 91 86 07 	lds	r18, 0x0786
    497e:	30 91 87 07 	lds	r19, 0x0787
    4982:	89 81       	ldd	r24, Y+1	; 0x01
    4984:	9a 81       	ldd	r25, Y+2	; 0x02
    4986:	82 17       	cp	r24, r18
    4988:	93 07       	cpc	r25, r19
    498a:	11 f4       	brne	.+4      	; 0x4990 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    498c:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    4990:	26 96       	adiw	r28, 0x06	; 6
    4992:	0f b6       	in	r0, 0x3f	; 63
    4994:	f8 94       	cli
    4996:	de bf       	out	0x3e, r29	; 62
    4998:	0f be       	out	0x3f, r0	; 63
    499a:	cd bf       	out	0x3d, r28	; 61
    499c:	cf 91       	pop	r28
    499e:	df 91       	pop	r29
    49a0:	08 95       	ret

000049a2 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    49a2:	df 93       	push	r29
    49a4:	cf 93       	push	r28
    49a6:	cd b7       	in	r28, 0x3d	; 61
    49a8:	de b7       	in	r29, 0x3e	; 62
    49aa:	2a 97       	sbiw	r28, 0x0a	; 10
    49ac:	0f b6       	in	r0, 0x3f	; 63
    49ae:	f8 94       	cli
    49b0:	de bf       	out	0x3e, r29	; 62
    49b2:	0f be       	out	0x3f, r0	; 63
    49b4:	cd bf       	out	0x3d, r28	; 61
    49b6:	98 87       	std	Y+8, r25	; 0x08
    49b8:	8f 83       	std	Y+7, r24	; 0x07
    49ba:	7a 87       	std	Y+10, r23	; 0x0a
    49bc:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    49be:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    49c0:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    49c4:	80 91 8a 07 	lds	r24, 0x078A
    49c8:	90 91 8b 07 	lds	r25, 0x078B
    49cc:	9a 83       	std	Y+2, r25	; 0x02
    49ce:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    49d0:	ef 81       	ldd	r30, Y+7	; 0x07
    49d2:	f8 85       	ldd	r31, Y+8	; 0x08
    49d4:	20 81       	ld	r18, Z
    49d6:	31 81       	ldd	r19, Z+1	; 0x01
    49d8:	89 85       	ldd	r24, Y+9	; 0x09
    49da:	9a 85       	ldd	r25, Y+10	; 0x0a
    49dc:	82 0f       	add	r24, r18
    49de:	93 1f       	adc	r25, r19
    49e0:	9e 83       	std	Y+6, r25	; 0x06
    49e2:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    49e4:	ef 81       	ldd	r30, Y+7	; 0x07
    49e6:	f8 85       	ldd	r31, Y+8	; 0x08
    49e8:	20 81       	ld	r18, Z
    49ea:	31 81       	ldd	r19, Z+1	; 0x01
    49ec:	89 81       	ldd	r24, Y+1	; 0x01
    49ee:	9a 81       	ldd	r25, Y+2	; 0x02
    49f0:	82 17       	cp	r24, r18
    49f2:	93 07       	cpc	r25, r19
    49f4:	98 f4       	brcc	.+38     	; 0x4a1c <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    49f6:	ef 81       	ldd	r30, Y+7	; 0x07
    49f8:	f8 85       	ldd	r31, Y+8	; 0x08
    49fa:	20 81       	ld	r18, Z
    49fc:	31 81       	ldd	r19, Z+1	; 0x01
    49fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4a00:	9e 81       	ldd	r25, Y+6	; 0x06
    4a02:	82 17       	cp	r24, r18
    4a04:	93 07       	cpc	r25, r19
    4a06:	e0 f4       	brcc	.+56     	; 0x4a40 <xTaskDelayUntil+0x9e>
    4a08:	2d 81       	ldd	r18, Y+5	; 0x05
    4a0a:	3e 81       	ldd	r19, Y+6	; 0x06
    4a0c:	89 81       	ldd	r24, Y+1	; 0x01
    4a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a10:	82 17       	cp	r24, r18
    4a12:	93 07       	cpc	r25, r19
    4a14:	a8 f4       	brcc	.+42     	; 0x4a40 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4a16:	81 e0       	ldi	r24, 0x01	; 1
    4a18:	8b 83       	std	Y+3, r24	; 0x03
    4a1a:	12 c0       	rjmp	.+36     	; 0x4a40 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4a1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a20:	20 81       	ld	r18, Z
    4a22:	31 81       	ldd	r19, Z+1	; 0x01
    4a24:	8d 81       	ldd	r24, Y+5	; 0x05
    4a26:	9e 81       	ldd	r25, Y+6	; 0x06
    4a28:	82 17       	cp	r24, r18
    4a2a:	93 07       	cpc	r25, r19
    4a2c:	38 f0       	brcs	.+14     	; 0x4a3c <xTaskDelayUntil+0x9a>
    4a2e:	2d 81       	ldd	r18, Y+5	; 0x05
    4a30:	3e 81       	ldd	r19, Y+6	; 0x06
    4a32:	89 81       	ldd	r24, Y+1	; 0x01
    4a34:	9a 81       	ldd	r25, Y+2	; 0x02
    4a36:	82 17       	cp	r24, r18
    4a38:	93 07       	cpc	r25, r19
    4a3a:	10 f4       	brcc	.+4      	; 0x4a40 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4a3c:	81 e0       	ldi	r24, 0x01	; 1
    4a3e:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    4a40:	ef 81       	ldd	r30, Y+7	; 0x07
    4a42:	f8 85       	ldd	r31, Y+8	; 0x08
    4a44:	8d 81       	ldd	r24, Y+5	; 0x05
    4a46:	9e 81       	ldd	r25, Y+6	; 0x06
    4a48:	91 83       	std	Z+1, r25	; 0x01
    4a4a:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    4a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a4e:	88 23       	and	r24, r24
    4a50:	49 f0       	breq	.+18     	; 0x4a64 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4a52:	8d 81       	ldd	r24, Y+5	; 0x05
    4a54:	9e 81       	ldd	r25, Y+6	; 0x06
    4a56:	29 81       	ldd	r18, Y+1	; 0x01
    4a58:	3a 81       	ldd	r19, Y+2	; 0x02
    4a5a:	82 1b       	sub	r24, r18
    4a5c:	93 0b       	sbc	r25, r19
    4a5e:	60 e0       	ldi	r22, 0x00	; 0
    4a60:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    4a64:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    4a68:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4a6a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a6c:	88 23       	and	r24, r24
    4a6e:	11 f4       	brne	.+4      	; 0x4a74 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    4a70:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    4a74:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4a76:	2a 96       	adiw	r28, 0x0a	; 10
    4a78:	0f b6       	in	r0, 0x3f	; 63
    4a7a:	f8 94       	cli
    4a7c:	de bf       	out	0x3e, r29	; 62
    4a7e:	0f be       	out	0x3f, r0	; 63
    4a80:	cd bf       	out	0x3d, r28	; 61
    4a82:	cf 91       	pop	r28
    4a84:	df 91       	pop	r29
    4a86:	08 95       	ret

00004a88 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    4a88:	df 93       	push	r29
    4a8a:	cf 93       	push	r28
    4a8c:	00 d0       	rcall	.+0      	; 0x4a8e <vTaskDelay+0x6>
    4a8e:	0f 92       	push	r0
    4a90:	cd b7       	in	r28, 0x3d	; 61
    4a92:	de b7       	in	r29, 0x3e	; 62
    4a94:	9b 83       	std	Y+3, r25	; 0x03
    4a96:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    4a98:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    4a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a9c:	9b 81       	ldd	r25, Y+3	; 0x03
    4a9e:	00 97       	sbiw	r24, 0x00	; 0
    4aa0:	51 f0       	breq	.+20     	; 0x4ab6 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    4aa2:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    4aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    4aaa:	60 e0       	ldi	r22, 0x00	; 0
    4aac:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    4ab0:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    4ab4:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4ab6:	89 81       	ldd	r24, Y+1	; 0x01
    4ab8:	88 23       	and	r24, r24
    4aba:	11 f4       	brne	.+4      	; 0x4ac0 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    4abc:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    4ac0:	0f 90       	pop	r0
    4ac2:	0f 90       	pop	r0
    4ac4:	0f 90       	pop	r0
    4ac6:	cf 91       	pop	r28
    4ac8:	df 91       	pop	r29
    4aca:	08 95       	ret

00004acc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4acc:	ef 92       	push	r14
    4ace:	ff 92       	push	r15
    4ad0:	0f 93       	push	r16
    4ad2:	df 93       	push	r29
    4ad4:	cf 93       	push	r28
    4ad6:	00 d0       	rcall	.+0      	; 0x4ad8 <vTaskStartScheduler+0xc>
    4ad8:	cd b7       	in	r28, 0x3d	; 61
    4ada:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    4adc:	85 e0       	ldi	r24, 0x05	; 5
    4ade:	9d e2       	ldi	r25, 0x2D	; 45
    4ae0:	20 e6       	ldi	r18, 0x60	; 96
    4ae2:	30 e0       	ldi	r19, 0x00	; 0
    4ae4:	e5 e9       	ldi	r30, 0x95	; 149
    4ae6:	f7 e0       	ldi	r31, 0x07	; 7
    4ae8:	b9 01       	movw	r22, r18
    4aea:	45 e5       	ldi	r20, 0x55	; 85
    4aec:	50 e0       	ldi	r21, 0x00	; 0
    4aee:	20 e0       	ldi	r18, 0x00	; 0
    4af0:	30 e0       	ldi	r19, 0x00	; 0
    4af2:	00 e0       	ldi	r16, 0x00	; 0
    4af4:	7f 01       	movw	r14, r30
    4af6:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>
    4afa:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    4afc:	89 81       	ldd	r24, Y+1	; 0x01
    4afe:	81 30       	cpi	r24, 0x01	; 1
    4b00:	81 f4       	brne	.+32     	; 0x4b22 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    4b02:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    4b04:	8f ef       	ldi	r24, 0xFF	; 255
    4b06:	9f ef       	ldi	r25, 0xFF	; 255
    4b08:	90 93 94 07 	sts	0x0794, r25
    4b0c:	80 93 93 07 	sts	0x0793, r24
        xSchedulerRunning = pdTRUE;
    4b10:	81 e0       	ldi	r24, 0x01	; 1
    4b12:	80 93 8d 07 	sts	0x078D, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4b16:	10 92 8b 07 	sts	0x078B, r1
    4b1a:	10 92 8a 07 	sts	0x078A, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    4b1e:	0e 94 b0 11 	call	0x2360	; 0x2360 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    4b22:	80 91 ea 00 	lds	r24, 0x00EA
}
    4b26:	0f 90       	pop	r0
    4b28:	0f 90       	pop	r0
    4b2a:	cf 91       	pop	r28
    4b2c:	df 91       	pop	r29
    4b2e:	0f 91       	pop	r16
    4b30:	ff 90       	pop	r15
    4b32:	ef 90       	pop	r14
    4b34:	08 95       	ret

00004b36 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4b36:	df 93       	push	r29
    4b38:	cf 93       	push	r28
    4b3a:	cd b7       	in	r28, 0x3d	; 61
    4b3c:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    4b3e:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    4b40:	10 92 8d 07 	sts	0x078D, r1
    vPortEndScheduler();
    4b44:	0e 94 e5 11 	call	0x23ca	; 0x23ca <vPortEndScheduler>
}
    4b48:	cf 91       	pop	r28
    4b4a:	df 91       	pop	r29
    4b4c:	08 95       	ret

00004b4e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4b4e:	df 93       	push	r29
    4b50:	cf 93       	push	r28
    4b52:	cd b7       	in	r28, 0x3d	; 61
    4b54:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4b56:	80 91 97 07 	lds	r24, 0x0797
    4b5a:	8f 5f       	subi	r24, 0xFF	; 255
    4b5c:	80 93 97 07 	sts	0x0797, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    4b60:	cf 91       	pop	r28
    4b62:	df 91       	pop	r29
    4b64:	08 95       	ret

00004b66 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4b66:	df 93       	push	r29
    4b68:	cf 93       	push	r28
    4b6a:	cd b7       	in	r28, 0x3d	; 61
    4b6c:	de b7       	in	r29, 0x3e	; 62
    4b6e:	2b 97       	sbiw	r28, 0x0b	; 11
    4b70:	0f b6       	in	r0, 0x3f	; 63
    4b72:	f8 94       	cli
    4b74:	de bf       	out	0x3e, r29	; 62
    4b76:	0f be       	out	0x3f, r0	; 63
    4b78:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    4b7a:	1b 86       	std	Y+11, r1	; 0x0b
    4b7c:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    4b7e:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    4b80:	0f b6       	in	r0, 0x3f	; 63
    4b82:	f8 94       	cli
    4b84:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    4b86:	80 91 97 07 	lds	r24, 0x0797
    4b8a:	81 50       	subi	r24, 0x01	; 1
    4b8c:	80 93 97 07 	sts	0x0797, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b90:	80 91 97 07 	lds	r24, 0x0797
    4b94:	88 23       	and	r24, r24
    4b96:	09 f0       	breq	.+2      	; 0x4b9a <xTaskResumeAll+0x34>
    4b98:	2a c1       	rjmp	.+596    	; 0x4dee <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4b9a:	80 91 89 07 	lds	r24, 0x0789
    4b9e:	88 23       	and	r24, r24
    4ba0:	09 f4       	brne	.+2      	; 0x4ba4 <xTaskResumeAll+0x3e>
    4ba2:	25 c1       	rjmp	.+586    	; 0x4dee <xTaskResumeAll+0x288>
    4ba4:	f3 c0       	rjmp	.+486    	; 0x4d8c <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ba6:	e0 91 0d 08 	lds	r30, 0x080D
    4baa:	f0 91 0e 08 	lds	r31, 0x080E
    4bae:	86 81       	ldd	r24, Z+6	; 0x06
    4bb0:	97 81       	ldd	r25, Z+7	; 0x07
    4bb2:	9b 87       	std	Y+11, r25	; 0x0b
    4bb4:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    4bb6:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bb8:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bba:	84 89       	ldd	r24, Z+20	; 0x14
    4bbc:	95 89       	ldd	r25, Z+21	; 0x15
    4bbe:	98 87       	std	Y+8, r25	; 0x08
    4bc0:	8f 83       	std	Y+7, r24	; 0x07
    4bc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bc6:	a6 85       	ldd	r26, Z+14	; 0x0e
    4bc8:	b7 85       	ldd	r27, Z+15	; 0x0f
    4bca:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bcc:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bce:	80 89       	ldd	r24, Z+16	; 0x10
    4bd0:	91 89       	ldd	r25, Z+17	; 0x11
    4bd2:	15 96       	adiw	r26, 0x05	; 5
    4bd4:	9c 93       	st	X, r25
    4bd6:	8e 93       	st	-X, r24
    4bd8:	14 97       	sbiw	r26, 0x04	; 4
    4bda:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bdc:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bde:	a0 89       	ldd	r26, Z+16	; 0x10
    4be0:	b1 89       	ldd	r27, Z+17	; 0x11
    4be2:	ea 85       	ldd	r30, Y+10	; 0x0a
    4be4:	fb 85       	ldd	r31, Y+11	; 0x0b
    4be6:	86 85       	ldd	r24, Z+14	; 0x0e
    4be8:	97 85       	ldd	r25, Z+15	; 0x0f
    4bea:	13 96       	adiw	r26, 0x03	; 3
    4bec:	9c 93       	st	X, r25
    4bee:	8e 93       	st	-X, r24
    4bf0:	12 97       	sbiw	r26, 0x02	; 2
    4bf2:	ef 81       	ldd	r30, Y+7	; 0x07
    4bf4:	f8 85       	ldd	r31, Y+8	; 0x08
    4bf6:	21 81       	ldd	r18, Z+1	; 0x01
    4bf8:	32 81       	ldd	r19, Z+2	; 0x02
    4bfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bfc:	9b 85       	ldd	r25, Y+11	; 0x0b
    4bfe:	0c 96       	adiw	r24, 0x0c	; 12
    4c00:	28 17       	cp	r18, r24
    4c02:	39 07       	cpc	r19, r25
    4c04:	41 f4       	brne	.+16     	; 0x4c16 <xTaskResumeAll+0xb0>
    4c06:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c08:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c0a:	80 89       	ldd	r24, Z+16	; 0x10
    4c0c:	91 89       	ldd	r25, Z+17	; 0x11
    4c0e:	ef 81       	ldd	r30, Y+7	; 0x07
    4c10:	f8 85       	ldd	r31, Y+8	; 0x08
    4c12:	92 83       	std	Z+2, r25	; 0x02
    4c14:	81 83       	std	Z+1, r24	; 0x01
    4c16:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c18:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c1a:	15 8a       	std	Z+21, r1	; 0x15
    4c1c:	14 8a       	std	Z+20, r1	; 0x14
    4c1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4c20:	f8 85       	ldd	r31, Y+8	; 0x08
    4c22:	80 81       	ld	r24, Z
    4c24:	81 50       	subi	r24, 0x01	; 1
    4c26:	ef 81       	ldd	r30, Y+7	; 0x07
    4c28:	f8 85       	ldd	r31, Y+8	; 0x08
    4c2a:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4c2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c30:	82 85       	ldd	r24, Z+10	; 0x0a
    4c32:	93 85       	ldd	r25, Z+11	; 0x0b
    4c34:	9e 83       	std	Y+6, r25	; 0x06
    4c36:	8d 83       	std	Y+5, r24	; 0x05
    4c38:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c3c:	a4 81       	ldd	r26, Z+4	; 0x04
    4c3e:	b5 81       	ldd	r27, Z+5	; 0x05
    4c40:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c42:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c44:	86 81       	ldd	r24, Z+6	; 0x06
    4c46:	97 81       	ldd	r25, Z+7	; 0x07
    4c48:	15 96       	adiw	r26, 0x05	; 5
    4c4a:	9c 93       	st	X, r25
    4c4c:	8e 93       	st	-X, r24
    4c4e:	14 97       	sbiw	r26, 0x04	; 4
    4c50:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c52:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c54:	a6 81       	ldd	r26, Z+6	; 0x06
    4c56:	b7 81       	ldd	r27, Z+7	; 0x07
    4c58:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c5a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c5c:	84 81       	ldd	r24, Z+4	; 0x04
    4c5e:	95 81       	ldd	r25, Z+5	; 0x05
    4c60:	13 96       	adiw	r26, 0x03	; 3
    4c62:	9c 93       	st	X, r25
    4c64:	8e 93       	st	-X, r24
    4c66:	12 97       	sbiw	r26, 0x02	; 2
    4c68:	ed 81       	ldd	r30, Y+5	; 0x05
    4c6a:	fe 81       	ldd	r31, Y+6	; 0x06
    4c6c:	21 81       	ldd	r18, Z+1	; 0x01
    4c6e:	32 81       	ldd	r19, Z+2	; 0x02
    4c70:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c72:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c74:	02 96       	adiw	r24, 0x02	; 2
    4c76:	28 17       	cp	r18, r24
    4c78:	39 07       	cpc	r19, r25
    4c7a:	41 f4       	brne	.+16     	; 0x4c8c <xTaskResumeAll+0x126>
    4c7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c80:	86 81       	ldd	r24, Z+6	; 0x06
    4c82:	97 81       	ldd	r25, Z+7	; 0x07
    4c84:	ed 81       	ldd	r30, Y+5	; 0x05
    4c86:	fe 81       	ldd	r31, Y+6	; 0x06
    4c88:	92 83       	std	Z+2, r25	; 0x02
    4c8a:	81 83       	std	Z+1, r24	; 0x01
    4c8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c90:	13 86       	std	Z+11, r1	; 0x0b
    4c92:	12 86       	std	Z+10, r1	; 0x0a
    4c94:	ed 81       	ldd	r30, Y+5	; 0x05
    4c96:	fe 81       	ldd	r31, Y+6	; 0x06
    4c98:	80 81       	ld	r24, Z
    4c9a:	81 50       	subi	r24, 0x01	; 1
    4c9c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c9e:	fe 81       	ldd	r31, Y+6	; 0x06
    4ca0:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4ca2:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ca4:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ca6:	96 89       	ldd	r25, Z+22	; 0x16
    4ca8:	80 91 8c 07 	lds	r24, 0x078C
    4cac:	89 17       	cp	r24, r25
    4cae:	28 f4       	brcc	.+10     	; 0x4cba <xTaskResumeAll+0x154>
    4cb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cb4:	86 89       	ldd	r24, Z+22	; 0x16
    4cb6:	80 93 8c 07 	sts	0x078C, r24
    4cba:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cbc:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cbe:	86 89       	ldd	r24, Z+22	; 0x16
    4cc0:	28 2f       	mov	r18, r24
    4cc2:	30 e0       	ldi	r19, 0x00	; 0
    4cc4:	c9 01       	movw	r24, r18
    4cc6:	88 0f       	add	r24, r24
    4cc8:	99 1f       	adc	r25, r25
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	82 0f       	add	r24, r18
    4cd4:	93 1f       	adc	r25, r19
    4cd6:	fc 01       	movw	r30, r24
    4cd8:	e8 56       	subi	r30, 0x68	; 104
    4cda:	f8 4f       	sbci	r31, 0xF8	; 248
    4cdc:	81 81       	ldd	r24, Z+1	; 0x01
    4cde:	92 81       	ldd	r25, Z+2	; 0x02
    4ce0:	9c 83       	std	Y+4, r25	; 0x04
    4ce2:	8b 83       	std	Y+3, r24	; 0x03
    4ce4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ce6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cea:	9c 81       	ldd	r25, Y+4	; 0x04
    4cec:	95 83       	std	Z+5, r25	; 0x05
    4cee:	84 83       	std	Z+4, r24	; 0x04
    4cf0:	eb 81       	ldd	r30, Y+3	; 0x03
    4cf2:	fc 81       	ldd	r31, Y+4	; 0x04
    4cf4:	84 81       	ldd	r24, Z+4	; 0x04
    4cf6:	95 81       	ldd	r25, Z+5	; 0x05
    4cf8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cfa:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cfc:	97 83       	std	Z+7, r25	; 0x07
    4cfe:	86 83       	std	Z+6, r24	; 0x06
    4d00:	eb 81       	ldd	r30, Y+3	; 0x03
    4d02:	fc 81       	ldd	r31, Y+4	; 0x04
    4d04:	04 80       	ldd	r0, Z+4	; 0x04
    4d06:	f5 81       	ldd	r31, Z+5	; 0x05
    4d08:	e0 2d       	mov	r30, r0
    4d0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d0e:	02 96       	adiw	r24, 0x02	; 2
    4d10:	93 83       	std	Z+3, r25	; 0x03
    4d12:	82 83       	std	Z+2, r24	; 0x02
    4d14:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d16:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d18:	02 96       	adiw	r24, 0x02	; 2
    4d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    4d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    4d1e:	95 83       	std	Z+5, r25	; 0x05
    4d20:	84 83       	std	Z+4, r24	; 0x04
    4d22:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d24:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d26:	86 89       	ldd	r24, Z+22	; 0x16
    4d28:	28 2f       	mov	r18, r24
    4d2a:	30 e0       	ldi	r19, 0x00	; 0
    4d2c:	c9 01       	movw	r24, r18
    4d2e:	88 0f       	add	r24, r24
    4d30:	99 1f       	adc	r25, r25
    4d32:	88 0f       	add	r24, r24
    4d34:	99 1f       	adc	r25, r25
    4d36:	88 0f       	add	r24, r24
    4d38:	99 1f       	adc	r25, r25
    4d3a:	82 0f       	add	r24, r18
    4d3c:	93 1f       	adc	r25, r19
    4d3e:	88 56       	subi	r24, 0x68	; 104
    4d40:	98 4f       	sbci	r25, 0xF8	; 248
    4d42:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d44:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d46:	93 87       	std	Z+11, r25	; 0x0b
    4d48:	82 87       	std	Z+10, r24	; 0x0a
    4d4a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d4c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d4e:	86 89       	ldd	r24, Z+22	; 0x16
    4d50:	28 2f       	mov	r18, r24
    4d52:	30 e0       	ldi	r19, 0x00	; 0
    4d54:	c9 01       	movw	r24, r18
    4d56:	88 0f       	add	r24, r24
    4d58:	99 1f       	adc	r25, r25
    4d5a:	88 0f       	add	r24, r24
    4d5c:	99 1f       	adc	r25, r25
    4d5e:	88 0f       	add	r24, r24
    4d60:	99 1f       	adc	r25, r25
    4d62:	82 0f       	add	r24, r18
    4d64:	93 1f       	adc	r25, r19
    4d66:	fc 01       	movw	r30, r24
    4d68:	e8 56       	subi	r30, 0x68	; 104
    4d6a:	f8 4f       	sbci	r31, 0xF8	; 248
    4d6c:	80 81       	ld	r24, Z
    4d6e:	8f 5f       	subi	r24, 0xFF	; 255
    4d70:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d72:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d74:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d76:	96 89       	ldd	r25, Z+22	; 0x16
    4d78:	e0 91 86 07 	lds	r30, 0x0786
    4d7c:	f0 91 87 07 	lds	r31, 0x0787
    4d80:	86 89       	ldd	r24, Z+22	; 0x16
    4d82:	98 17       	cp	r25, r24
    4d84:	18 f0       	brcs	.+6      	; 0x4d8c <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    4d86:	81 e0       	ldi	r24, 0x01	; 1
    4d88:	80 93 90 07 	sts	0x0790, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4d8c:	80 91 08 08 	lds	r24, 0x0808
    4d90:	88 23       	and	r24, r24
    4d92:	09 f0       	breq	.+2      	; 0x4d96 <xTaskResumeAll+0x230>
    4d94:	08 cf       	rjmp	.-496    	; 0x4ba6 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    4d96:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d98:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d9a:	00 97       	sbiw	r24, 0x00	; 0
    4d9c:	11 f0       	breq	.+4      	; 0x4da2 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    4d9e:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    4da2:	80 91 8e 07 	lds	r24, 0x078E
    4da6:	90 91 8f 07 	lds	r25, 0x078F
    4daa:	9a 83       	std	Y+2, r25	; 0x02
    4dac:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    4dae:	89 81       	ldd	r24, Y+1	; 0x01
    4db0:	9a 81       	ldd	r25, Y+2	; 0x02
    4db2:	00 97       	sbiw	r24, 0x00	; 0
    4db4:	a1 f0       	breq	.+40     	; 0x4dde <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    4db6:	0e 94 80 27 	call	0x4f00	; 0x4f00 <xTaskIncrementTick>
    4dba:	88 23       	and	r24, r24
    4dbc:	19 f0       	breq	.+6      	; 0x4dc4 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    4dbe:	81 e0       	ldi	r24, 0x01	; 1
    4dc0:	80 93 90 07 	sts	0x0790, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    4dc4:	89 81       	ldd	r24, Y+1	; 0x01
    4dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc8:	01 97       	sbiw	r24, 0x01	; 1
    4dca:	9a 83       	std	Y+2, r25	; 0x02
    4dcc:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    4dce:	89 81       	ldd	r24, Y+1	; 0x01
    4dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd2:	00 97       	sbiw	r24, 0x00	; 0
    4dd4:	81 f7       	brne	.-32     	; 0x4db6 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    4dd6:	10 92 8f 07 	sts	0x078F, r1
    4dda:	10 92 8e 07 	sts	0x078E, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    4dde:	80 91 90 07 	lds	r24, 0x0790
    4de2:	88 23       	and	r24, r24
    4de4:	21 f0       	breq	.+8      	; 0x4dee <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    4de6:	81 e0       	ldi	r24, 0x01	; 1
    4de8:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    4dea:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    4dee:	0f 90       	pop	r0
    4df0:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    4df2:	89 85       	ldd	r24, Y+9	; 0x09
}
    4df4:	2b 96       	adiw	r28, 0x0b	; 11
    4df6:	0f b6       	in	r0, 0x3f	; 63
    4df8:	f8 94       	cli
    4dfa:	de bf       	out	0x3e, r29	; 62
    4dfc:	0f be       	out	0x3f, r0	; 63
    4dfe:	cd bf       	out	0x3d, r28	; 61
    4e00:	cf 91       	pop	r28
    4e02:	df 91       	pop	r29
    4e04:	08 95       	ret

00004e06 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4e06:	df 93       	push	r29
    4e08:	cf 93       	push	r28
    4e0a:	00 d0       	rcall	.+0      	; 0x4e0c <xTaskGetTickCount+0x6>
    4e0c:	cd b7       	in	r28, 0x3d	; 61
    4e0e:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4e10:	0f b6       	in	r0, 0x3f	; 63
    4e12:	f8 94       	cli
    4e14:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4e16:	80 91 8a 07 	lds	r24, 0x078A
    4e1a:	90 91 8b 07 	lds	r25, 0x078B
    4e1e:	9a 83       	std	Y+2, r25	; 0x02
    4e20:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4e22:	0f 90       	pop	r0
    4e24:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    4e26:	89 81       	ldd	r24, Y+1	; 0x01
    4e28:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e2a:	0f 90       	pop	r0
    4e2c:	0f 90       	pop	r0
    4e2e:	cf 91       	pop	r28
    4e30:	df 91       	pop	r29
    4e32:	08 95       	ret

00004e34 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4e34:	df 93       	push	r29
    4e36:	cf 93       	push	r28
    4e38:	00 d0       	rcall	.+0      	; 0x4e3a <xTaskGetTickCountFromISR+0x6>
    4e3a:	0f 92       	push	r0
    4e3c:	cd b7       	in	r28, 0x3d	; 61
    4e3e:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4e40:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4e42:	80 91 8a 07 	lds	r24, 0x078A
    4e46:	90 91 8b 07 	lds	r25, 0x078B
    4e4a:	9b 83       	std	Y+3, r25	; 0x03
    4e4c:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e50:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4e52:	0f 90       	pop	r0
    4e54:	0f 90       	pop	r0
    4e56:	0f 90       	pop	r0
    4e58:	cf 91       	pop	r28
    4e5a:	df 91       	pop	r29
    4e5c:	08 95       	ret

00004e5e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4e5e:	df 93       	push	r29
    4e60:	cf 93       	push	r28
    4e62:	cd b7       	in	r28, 0x3d	; 61
    4e64:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4e66:	80 91 89 07 	lds	r24, 0x0789
}
    4e6a:	cf 91       	pop	r28
    4e6c:	df 91       	pop	r29
    4e6e:	08 95       	ret

00004e70 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4e70:	df 93       	push	r29
    4e72:	cf 93       	push	r28
    4e74:	00 d0       	rcall	.+0      	; 0x4e76 <pcTaskGetName+0x6>
    4e76:	00 d0       	rcall	.+0      	; 0x4e78 <pcTaskGetName+0x8>
    4e78:	00 d0       	rcall	.+0      	; 0x4e7a <pcTaskGetName+0xa>
    4e7a:	cd b7       	in	r28, 0x3d	; 61
    4e7c:	de b7       	in	r29, 0x3e	; 62
    4e7e:	9c 83       	std	Y+4, r25	; 0x04
    4e80:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4e82:	8b 81       	ldd	r24, Y+3	; 0x03
    4e84:	9c 81       	ldd	r25, Y+4	; 0x04
    4e86:	00 97       	sbiw	r24, 0x00	; 0
    4e88:	39 f4       	brne	.+14     	; 0x4e98 <pcTaskGetName+0x28>
    4e8a:	80 91 86 07 	lds	r24, 0x0786
    4e8e:	90 91 87 07 	lds	r25, 0x0787
    4e92:	9e 83       	std	Y+6, r25	; 0x06
    4e94:	8d 83       	std	Y+5, r24	; 0x05
    4e96:	04 c0       	rjmp	.+8      	; 0x4ea0 <pcTaskGetName+0x30>
    4e98:	8b 81       	ldd	r24, Y+3	; 0x03
    4e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e9c:	9e 83       	std	Y+6, r25	; 0x06
    4e9e:	8d 83       	std	Y+5, r24	; 0x05
    4ea0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ea2:	9e 81       	ldd	r25, Y+6	; 0x06
    4ea4:	9a 83       	std	Y+2, r25	; 0x02
    4ea6:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    4ea8:	89 81       	ldd	r24, Y+1	; 0x01
    4eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    4eac:	49 96       	adiw	r24, 0x19	; 25
}
    4eae:	26 96       	adiw	r28, 0x06	; 6
    4eb0:	0f b6       	in	r0, 0x3f	; 63
    4eb2:	f8 94       	cli
    4eb4:	de bf       	out	0x3e, r29	; 62
    4eb6:	0f be       	out	0x3f, r0	; 63
    4eb8:	cd bf       	out	0x3d, r28	; 61
    4eba:	cf 91       	pop	r28
    4ebc:	df 91       	pop	r29
    4ebe:	08 95       	ret

00004ec0 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4ec0:	df 93       	push	r29
    4ec2:	cf 93       	push	r28
    4ec4:	00 d0       	rcall	.+0      	; 0x4ec6 <xTaskCatchUpTicks+0x6>
    4ec6:	0f 92       	push	r0
    4ec8:	cd b7       	in	r28, 0x3d	; 61
    4eca:	de b7       	in	r29, 0x3e	; 62
    4ecc:	9b 83       	std	Y+3, r25	; 0x03
    4ece:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4ed0:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    4ed4:	20 91 8e 07 	lds	r18, 0x078E
    4ed8:	30 91 8f 07 	lds	r19, 0x078F
    4edc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ede:	9b 81       	ldd	r25, Y+3	; 0x03
    4ee0:	82 0f       	add	r24, r18
    4ee2:	93 1f       	adc	r25, r19
    4ee4:	90 93 8f 07 	sts	0x078F, r25
    4ee8:	80 93 8e 07 	sts	0x078E, r24
    xYieldOccurred = xTaskResumeAll();
    4eec:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskResumeAll>
    4ef0:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    4ef2:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ef4:	0f 90       	pop	r0
    4ef6:	0f 90       	pop	r0
    4ef8:	0f 90       	pop	r0
    4efa:	cf 91       	pop	r28
    4efc:	df 91       	pop	r29
    4efe:	08 95       	ret

00004f00 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4f00:	df 93       	push	r29
    4f02:	cf 93       	push	r28
    4f04:	cd b7       	in	r28, 0x3d	; 61
    4f06:	de b7       	in	r29, 0x3e	; 62
    4f08:	2f 97       	sbiw	r28, 0x0f	; 15
    4f0a:	0f b6       	in	r0, 0x3f	; 63
    4f0c:	f8 94       	cli
    4f0e:	de bf       	out	0x3e, r29	; 62
    4f10:	0f be       	out	0x3f, r0	; 63
    4f12:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    4f14:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f16:	80 91 97 07 	lds	r24, 0x0797
    4f1a:	88 23       	and	r24, r24
    4f1c:	09 f0       	breq	.+2      	; 0x4f20 <xTaskIncrementTick+0x20>
    4f1e:	74 c1       	rjmp	.+744    	; 0x5208 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f20:	80 91 8a 07 	lds	r24, 0x078A
    4f24:	90 91 8b 07 	lds	r25, 0x078B
    4f28:	01 96       	adiw	r24, 0x01	; 1
    4f2a:	9a 87       	std	Y+10, r25	; 0x0a
    4f2c:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4f2e:	89 85       	ldd	r24, Y+9	; 0x09
    4f30:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f32:	90 93 8b 07 	sts	0x078B, r25
    4f36:	80 93 8a 07 	sts	0x078A, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f3a:	89 85       	ldd	r24, Y+9	; 0x09
    4f3c:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f3e:	00 97       	sbiw	r24, 0x00	; 0
    4f40:	d9 f4       	brne	.+54     	; 0x4f78 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4f42:	80 91 04 08 	lds	r24, 0x0804
    4f46:	90 91 05 08 	lds	r25, 0x0805
    4f4a:	98 87       	std	Y+8, r25	; 0x08
    4f4c:	8f 83       	std	Y+7, r24	; 0x07
    4f4e:	80 91 06 08 	lds	r24, 0x0806
    4f52:	90 91 07 08 	lds	r25, 0x0807
    4f56:	90 93 05 08 	sts	0x0805, r25
    4f5a:	80 93 04 08 	sts	0x0804, r24
    4f5e:	8f 81       	ldd	r24, Y+7	; 0x07
    4f60:	98 85       	ldd	r25, Y+8	; 0x08
    4f62:	90 93 07 08 	sts	0x0807, r25
    4f66:	80 93 06 08 	sts	0x0806, r24
    4f6a:	80 91 91 07 	lds	r24, 0x0791
    4f6e:	8f 5f       	subi	r24, 0xFF	; 255
    4f70:	80 93 91 07 	sts	0x0791, r24
    4f74:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4f78:	20 91 93 07 	lds	r18, 0x0793
    4f7c:	30 91 94 07 	lds	r19, 0x0794
    4f80:	89 85       	ldd	r24, Y+9	; 0x09
    4f82:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f84:	82 17       	cp	r24, r18
    4f86:	93 07       	cpc	r25, r19
    4f88:	08 f4       	brcc	.+2      	; 0x4f8c <xTaskIncrementTick+0x8c>
    4f8a:	1f c1       	rjmp	.+574    	; 0x51ca <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f8c:	e0 91 04 08 	lds	r30, 0x0804
    4f90:	f0 91 05 08 	lds	r31, 0x0805
    4f94:	80 81       	ld	r24, Z
    4f96:	88 23       	and	r24, r24
    4f98:	39 f4       	brne	.+14     	; 0x4fa8 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4f9a:	8f ef       	ldi	r24, 0xFF	; 255
    4f9c:	9f ef       	ldi	r25, 0xFF	; 255
    4f9e:	90 93 94 07 	sts	0x0794, r25
    4fa2:	80 93 93 07 	sts	0x0793, r24
    4fa6:	11 c1       	rjmp	.+546    	; 0x51ca <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4fa8:	e0 91 04 08 	lds	r30, 0x0804
    4fac:	f0 91 05 08 	lds	r31, 0x0805
    4fb0:	05 80       	ldd	r0, Z+5	; 0x05
    4fb2:	f6 81       	ldd	r31, Z+6	; 0x06
    4fb4:	e0 2d       	mov	r30, r0
    4fb6:	86 81       	ldd	r24, Z+6	; 0x06
    4fb8:	97 81       	ldd	r25, Z+7	; 0x07
    4fba:	9f 87       	std	Y+15, r25	; 0x0f
    4fbc:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4fbe:	ee 85       	ldd	r30, Y+14	; 0x0e
    4fc0:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fc2:	82 81       	ldd	r24, Z+2	; 0x02
    4fc4:	93 81       	ldd	r25, Z+3	; 0x03
    4fc6:	9d 87       	std	Y+13, r25	; 0x0d
    4fc8:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    4fca:	29 85       	ldd	r18, Y+9	; 0x09
    4fcc:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fce:	8c 85       	ldd	r24, Y+12	; 0x0c
    4fd0:	9d 85       	ldd	r25, Y+13	; 0x0d
    4fd2:	28 17       	cp	r18, r24
    4fd4:	39 07       	cpc	r19, r25
    4fd6:	38 f4       	brcc	.+14     	; 0x4fe6 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    4fd8:	8c 85       	ldd	r24, Y+12	; 0x0c
    4fda:	9d 85       	ldd	r25, Y+13	; 0x0d
    4fdc:	90 93 94 07 	sts	0x0794, r25
    4fe0:	80 93 93 07 	sts	0x0793, r24
    4fe4:	f2 c0       	rjmp	.+484    	; 0x51ca <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4fe6:	ee 85       	ldd	r30, Y+14	; 0x0e
    4fe8:	ff 85       	ldd	r31, Y+15	; 0x0f
    4fea:	82 85       	ldd	r24, Z+10	; 0x0a
    4fec:	93 85       	ldd	r25, Z+11	; 0x0b
    4fee:	9e 83       	std	Y+6, r25	; 0x06
    4ff0:	8d 83       	std	Y+5, r24	; 0x05
    4ff2:	ee 85       	ldd	r30, Y+14	; 0x0e
    4ff4:	ff 85       	ldd	r31, Y+15	; 0x0f
    4ff6:	a4 81       	ldd	r26, Z+4	; 0x04
    4ff8:	b5 81       	ldd	r27, Z+5	; 0x05
    4ffa:	ee 85       	ldd	r30, Y+14	; 0x0e
    4ffc:	ff 85       	ldd	r31, Y+15	; 0x0f
    4ffe:	86 81       	ldd	r24, Z+6	; 0x06
    5000:	97 81       	ldd	r25, Z+7	; 0x07
    5002:	15 96       	adiw	r26, 0x05	; 5
    5004:	9c 93       	st	X, r25
    5006:	8e 93       	st	-X, r24
    5008:	14 97       	sbiw	r26, 0x04	; 4
    500a:	ee 85       	ldd	r30, Y+14	; 0x0e
    500c:	ff 85       	ldd	r31, Y+15	; 0x0f
    500e:	a6 81       	ldd	r26, Z+6	; 0x06
    5010:	b7 81       	ldd	r27, Z+7	; 0x07
    5012:	ee 85       	ldd	r30, Y+14	; 0x0e
    5014:	ff 85       	ldd	r31, Y+15	; 0x0f
    5016:	84 81       	ldd	r24, Z+4	; 0x04
    5018:	95 81       	ldd	r25, Z+5	; 0x05
    501a:	13 96       	adiw	r26, 0x03	; 3
    501c:	9c 93       	st	X, r25
    501e:	8e 93       	st	-X, r24
    5020:	12 97       	sbiw	r26, 0x02	; 2
    5022:	ed 81       	ldd	r30, Y+5	; 0x05
    5024:	fe 81       	ldd	r31, Y+6	; 0x06
    5026:	21 81       	ldd	r18, Z+1	; 0x01
    5028:	32 81       	ldd	r19, Z+2	; 0x02
    502a:	8e 85       	ldd	r24, Y+14	; 0x0e
    502c:	9f 85       	ldd	r25, Y+15	; 0x0f
    502e:	02 96       	adiw	r24, 0x02	; 2
    5030:	28 17       	cp	r18, r24
    5032:	39 07       	cpc	r19, r25
    5034:	41 f4       	brne	.+16     	; 0x5046 <xTaskIncrementTick+0x146>
    5036:	ee 85       	ldd	r30, Y+14	; 0x0e
    5038:	ff 85       	ldd	r31, Y+15	; 0x0f
    503a:	86 81       	ldd	r24, Z+6	; 0x06
    503c:	97 81       	ldd	r25, Z+7	; 0x07
    503e:	ed 81       	ldd	r30, Y+5	; 0x05
    5040:	fe 81       	ldd	r31, Y+6	; 0x06
    5042:	92 83       	std	Z+2, r25	; 0x02
    5044:	81 83       	std	Z+1, r24	; 0x01
    5046:	ee 85       	ldd	r30, Y+14	; 0x0e
    5048:	ff 85       	ldd	r31, Y+15	; 0x0f
    504a:	13 86       	std	Z+11, r1	; 0x0b
    504c:	12 86       	std	Z+10, r1	; 0x0a
    504e:	ed 81       	ldd	r30, Y+5	; 0x05
    5050:	fe 81       	ldd	r31, Y+6	; 0x06
    5052:	80 81       	ld	r24, Z
    5054:	81 50       	subi	r24, 0x01	; 1
    5056:	ed 81       	ldd	r30, Y+5	; 0x05
    5058:	fe 81       	ldd	r31, Y+6	; 0x06
    505a:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    505c:	ee 85       	ldd	r30, Y+14	; 0x0e
    505e:	ff 85       	ldd	r31, Y+15	; 0x0f
    5060:	84 89       	ldd	r24, Z+20	; 0x14
    5062:	95 89       	ldd	r25, Z+21	; 0x15
    5064:	00 97       	sbiw	r24, 0x00	; 0
    5066:	d9 f1       	breq	.+118    	; 0x50de <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    5068:	ee 85       	ldd	r30, Y+14	; 0x0e
    506a:	ff 85       	ldd	r31, Y+15	; 0x0f
    506c:	84 89       	ldd	r24, Z+20	; 0x14
    506e:	95 89       	ldd	r25, Z+21	; 0x15
    5070:	9c 83       	std	Y+4, r25	; 0x04
    5072:	8b 83       	std	Y+3, r24	; 0x03
    5074:	ee 85       	ldd	r30, Y+14	; 0x0e
    5076:	ff 85       	ldd	r31, Y+15	; 0x0f
    5078:	a6 85       	ldd	r26, Z+14	; 0x0e
    507a:	b7 85       	ldd	r27, Z+15	; 0x0f
    507c:	ee 85       	ldd	r30, Y+14	; 0x0e
    507e:	ff 85       	ldd	r31, Y+15	; 0x0f
    5080:	80 89       	ldd	r24, Z+16	; 0x10
    5082:	91 89       	ldd	r25, Z+17	; 0x11
    5084:	15 96       	adiw	r26, 0x05	; 5
    5086:	9c 93       	st	X, r25
    5088:	8e 93       	st	-X, r24
    508a:	14 97       	sbiw	r26, 0x04	; 4
    508c:	ee 85       	ldd	r30, Y+14	; 0x0e
    508e:	ff 85       	ldd	r31, Y+15	; 0x0f
    5090:	a0 89       	ldd	r26, Z+16	; 0x10
    5092:	b1 89       	ldd	r27, Z+17	; 0x11
    5094:	ee 85       	ldd	r30, Y+14	; 0x0e
    5096:	ff 85       	ldd	r31, Y+15	; 0x0f
    5098:	86 85       	ldd	r24, Z+14	; 0x0e
    509a:	97 85       	ldd	r25, Z+15	; 0x0f
    509c:	13 96       	adiw	r26, 0x03	; 3
    509e:	9c 93       	st	X, r25
    50a0:	8e 93       	st	-X, r24
    50a2:	12 97       	sbiw	r26, 0x02	; 2
    50a4:	eb 81       	ldd	r30, Y+3	; 0x03
    50a6:	fc 81       	ldd	r31, Y+4	; 0x04
    50a8:	21 81       	ldd	r18, Z+1	; 0x01
    50aa:	32 81       	ldd	r19, Z+2	; 0x02
    50ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    50ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    50b0:	0c 96       	adiw	r24, 0x0c	; 12
    50b2:	28 17       	cp	r18, r24
    50b4:	39 07       	cpc	r19, r25
    50b6:	41 f4       	brne	.+16     	; 0x50c8 <xTaskIncrementTick+0x1c8>
    50b8:	ee 85       	ldd	r30, Y+14	; 0x0e
    50ba:	ff 85       	ldd	r31, Y+15	; 0x0f
    50bc:	80 89       	ldd	r24, Z+16	; 0x10
    50be:	91 89       	ldd	r25, Z+17	; 0x11
    50c0:	eb 81       	ldd	r30, Y+3	; 0x03
    50c2:	fc 81       	ldd	r31, Y+4	; 0x04
    50c4:	92 83       	std	Z+2, r25	; 0x02
    50c6:	81 83       	std	Z+1, r24	; 0x01
    50c8:	ee 85       	ldd	r30, Y+14	; 0x0e
    50ca:	ff 85       	ldd	r31, Y+15	; 0x0f
    50cc:	15 8a       	std	Z+21, r1	; 0x15
    50ce:	14 8a       	std	Z+20, r1	; 0x14
    50d0:	eb 81       	ldd	r30, Y+3	; 0x03
    50d2:	fc 81       	ldd	r31, Y+4	; 0x04
    50d4:	80 81       	ld	r24, Z
    50d6:	81 50       	subi	r24, 0x01	; 1
    50d8:	eb 81       	ldd	r30, Y+3	; 0x03
    50da:	fc 81       	ldd	r31, Y+4	; 0x04
    50dc:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    50de:	ee 85       	ldd	r30, Y+14	; 0x0e
    50e0:	ff 85       	ldd	r31, Y+15	; 0x0f
    50e2:	96 89       	ldd	r25, Z+22	; 0x16
    50e4:	80 91 8c 07 	lds	r24, 0x078C
    50e8:	89 17       	cp	r24, r25
    50ea:	28 f4       	brcc	.+10     	; 0x50f6 <xTaskIncrementTick+0x1f6>
    50ec:	ee 85       	ldd	r30, Y+14	; 0x0e
    50ee:	ff 85       	ldd	r31, Y+15	; 0x0f
    50f0:	86 89       	ldd	r24, Z+22	; 0x16
    50f2:	80 93 8c 07 	sts	0x078C, r24
    50f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    50f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    50fa:	86 89       	ldd	r24, Z+22	; 0x16
    50fc:	28 2f       	mov	r18, r24
    50fe:	30 e0       	ldi	r19, 0x00	; 0
    5100:	c9 01       	movw	r24, r18
    5102:	88 0f       	add	r24, r24
    5104:	99 1f       	adc	r25, r25
    5106:	88 0f       	add	r24, r24
    5108:	99 1f       	adc	r25, r25
    510a:	88 0f       	add	r24, r24
    510c:	99 1f       	adc	r25, r25
    510e:	82 0f       	add	r24, r18
    5110:	93 1f       	adc	r25, r19
    5112:	fc 01       	movw	r30, r24
    5114:	e8 56       	subi	r30, 0x68	; 104
    5116:	f8 4f       	sbci	r31, 0xF8	; 248
    5118:	81 81       	ldd	r24, Z+1	; 0x01
    511a:	92 81       	ldd	r25, Z+2	; 0x02
    511c:	9a 83       	std	Y+2, r25	; 0x02
    511e:	89 83       	std	Y+1, r24	; 0x01
    5120:	ee 85       	ldd	r30, Y+14	; 0x0e
    5122:	ff 85       	ldd	r31, Y+15	; 0x0f
    5124:	89 81       	ldd	r24, Y+1	; 0x01
    5126:	9a 81       	ldd	r25, Y+2	; 0x02
    5128:	95 83       	std	Z+5, r25	; 0x05
    512a:	84 83       	std	Z+4, r24	; 0x04
    512c:	e9 81       	ldd	r30, Y+1	; 0x01
    512e:	fa 81       	ldd	r31, Y+2	; 0x02
    5130:	84 81       	ldd	r24, Z+4	; 0x04
    5132:	95 81       	ldd	r25, Z+5	; 0x05
    5134:	ee 85       	ldd	r30, Y+14	; 0x0e
    5136:	ff 85       	ldd	r31, Y+15	; 0x0f
    5138:	97 83       	std	Z+7, r25	; 0x07
    513a:	86 83       	std	Z+6, r24	; 0x06
    513c:	e9 81       	ldd	r30, Y+1	; 0x01
    513e:	fa 81       	ldd	r31, Y+2	; 0x02
    5140:	04 80       	ldd	r0, Z+4	; 0x04
    5142:	f5 81       	ldd	r31, Z+5	; 0x05
    5144:	e0 2d       	mov	r30, r0
    5146:	8e 85       	ldd	r24, Y+14	; 0x0e
    5148:	9f 85       	ldd	r25, Y+15	; 0x0f
    514a:	02 96       	adiw	r24, 0x02	; 2
    514c:	93 83       	std	Z+3, r25	; 0x03
    514e:	82 83       	std	Z+2, r24	; 0x02
    5150:	8e 85       	ldd	r24, Y+14	; 0x0e
    5152:	9f 85       	ldd	r25, Y+15	; 0x0f
    5154:	02 96       	adiw	r24, 0x02	; 2
    5156:	e9 81       	ldd	r30, Y+1	; 0x01
    5158:	fa 81       	ldd	r31, Y+2	; 0x02
    515a:	95 83       	std	Z+5, r25	; 0x05
    515c:	84 83       	std	Z+4, r24	; 0x04
    515e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5160:	ff 85       	ldd	r31, Y+15	; 0x0f
    5162:	86 89       	ldd	r24, Z+22	; 0x16
    5164:	28 2f       	mov	r18, r24
    5166:	30 e0       	ldi	r19, 0x00	; 0
    5168:	c9 01       	movw	r24, r18
    516a:	88 0f       	add	r24, r24
    516c:	99 1f       	adc	r25, r25
    516e:	88 0f       	add	r24, r24
    5170:	99 1f       	adc	r25, r25
    5172:	88 0f       	add	r24, r24
    5174:	99 1f       	adc	r25, r25
    5176:	82 0f       	add	r24, r18
    5178:	93 1f       	adc	r25, r19
    517a:	88 56       	subi	r24, 0x68	; 104
    517c:	98 4f       	sbci	r25, 0xF8	; 248
    517e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5180:	ff 85       	ldd	r31, Y+15	; 0x0f
    5182:	93 87       	std	Z+11, r25	; 0x0b
    5184:	82 87       	std	Z+10, r24	; 0x0a
    5186:	ee 85       	ldd	r30, Y+14	; 0x0e
    5188:	ff 85       	ldd	r31, Y+15	; 0x0f
    518a:	86 89       	ldd	r24, Z+22	; 0x16
    518c:	28 2f       	mov	r18, r24
    518e:	30 e0       	ldi	r19, 0x00	; 0
    5190:	c9 01       	movw	r24, r18
    5192:	88 0f       	add	r24, r24
    5194:	99 1f       	adc	r25, r25
    5196:	88 0f       	add	r24, r24
    5198:	99 1f       	adc	r25, r25
    519a:	88 0f       	add	r24, r24
    519c:	99 1f       	adc	r25, r25
    519e:	82 0f       	add	r24, r18
    51a0:	93 1f       	adc	r25, r19
    51a2:	fc 01       	movw	r30, r24
    51a4:	e8 56       	subi	r30, 0x68	; 104
    51a6:	f8 4f       	sbci	r31, 0xF8	; 248
    51a8:	80 81       	ld	r24, Z
    51aa:	8f 5f       	subi	r24, 0xFF	; 255
    51ac:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    51ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    51b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    51b2:	96 89       	ldd	r25, Z+22	; 0x16
    51b4:	e0 91 86 07 	lds	r30, 0x0786
    51b8:	f0 91 87 07 	lds	r31, 0x0787
    51bc:	86 89       	ldd	r24, Z+22	; 0x16
    51be:	98 17       	cp	r25, r24
    51c0:	08 f4       	brcc	.+2      	; 0x51c4 <xTaskIncrementTick+0x2c4>
    51c2:	e4 ce       	rjmp	.-568    	; 0x4f8c <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    51c4:	81 e0       	ldi	r24, 0x01	; 1
    51c6:	8b 87       	std	Y+11, r24	; 0x0b
    51c8:	e1 ce       	rjmp	.-574    	; 0x4f8c <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    51ca:	e0 91 86 07 	lds	r30, 0x0786
    51ce:	f0 91 87 07 	lds	r31, 0x0787
    51d2:	86 89       	ldd	r24, Z+22	; 0x16
    51d4:	28 2f       	mov	r18, r24
    51d6:	30 e0       	ldi	r19, 0x00	; 0
    51d8:	c9 01       	movw	r24, r18
    51da:	88 0f       	add	r24, r24
    51dc:	99 1f       	adc	r25, r25
    51de:	88 0f       	add	r24, r24
    51e0:	99 1f       	adc	r25, r25
    51e2:	88 0f       	add	r24, r24
    51e4:	99 1f       	adc	r25, r25
    51e6:	82 0f       	add	r24, r18
    51e8:	93 1f       	adc	r25, r19
    51ea:	fc 01       	movw	r30, r24
    51ec:	e8 56       	subi	r30, 0x68	; 104
    51ee:	f8 4f       	sbci	r31, 0xF8	; 248
    51f0:	80 81       	ld	r24, Z
    51f2:	82 30       	cpi	r24, 0x02	; 2
    51f4:	10 f0       	brcs	.+4      	; 0x51fa <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    51f6:	81 e0       	ldi	r24, 0x01	; 1
    51f8:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    51fa:	80 91 90 07 	lds	r24, 0x0790
    51fe:	88 23       	and	r24, r24
    5200:	61 f0       	breq	.+24     	; 0x521a <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    5202:	81 e0       	ldi	r24, 0x01	; 1
    5204:	8b 87       	std	Y+11, r24	; 0x0b
    5206:	09 c0       	rjmp	.+18     	; 0x521a <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    5208:	80 91 8e 07 	lds	r24, 0x078E
    520c:	90 91 8f 07 	lds	r25, 0x078F
    5210:	01 96       	adiw	r24, 0x01	; 1
    5212:	90 93 8f 07 	sts	0x078F, r25
    5216:	80 93 8e 07 	sts	0x078E, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    521a:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    521c:	2f 96       	adiw	r28, 0x0f	; 15
    521e:	0f b6       	in	r0, 0x3f	; 63
    5220:	f8 94       	cli
    5222:	de bf       	out	0x3e, r29	; 62
    5224:	0f be       	out	0x3f, r0	; 63
    5226:	cd bf       	out	0x3d, r28	; 61
    5228:	cf 91       	pop	r28
    522a:	df 91       	pop	r29
    522c:	08 95       	ret

0000522e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    522e:	df 93       	push	r29
    5230:	cf 93       	push	r28
    5232:	00 d0       	rcall	.+0      	; 0x5234 <vTaskSwitchContext+0x6>
    5234:	0f 92       	push	r0
    5236:	cd b7       	in	r28, 0x3d	; 61
    5238:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    523a:	80 91 97 07 	lds	r24, 0x0797
    523e:	88 23       	and	r24, r24
    5240:	21 f0       	breq	.+8      	; 0x524a <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    5242:	81 e0       	ldi	r24, 0x01	; 1
    5244:	80 93 90 07 	sts	0x0790, r24
    5248:	59 c0       	rjmp	.+178    	; 0x52fc <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    524a:	10 92 90 07 	sts	0x0790, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    524e:	80 91 8c 07 	lds	r24, 0x078C
    5252:	8b 83       	std	Y+3, r24	; 0x03
    5254:	03 c0       	rjmp	.+6      	; 0x525c <vTaskSwitchContext+0x2e>
    5256:	8b 81       	ldd	r24, Y+3	; 0x03
    5258:	81 50       	subi	r24, 0x01	; 1
    525a:	8b 83       	std	Y+3, r24	; 0x03
    525c:	8b 81       	ldd	r24, Y+3	; 0x03
    525e:	28 2f       	mov	r18, r24
    5260:	30 e0       	ldi	r19, 0x00	; 0
    5262:	c9 01       	movw	r24, r18
    5264:	88 0f       	add	r24, r24
    5266:	99 1f       	adc	r25, r25
    5268:	88 0f       	add	r24, r24
    526a:	99 1f       	adc	r25, r25
    526c:	88 0f       	add	r24, r24
    526e:	99 1f       	adc	r25, r25
    5270:	82 0f       	add	r24, r18
    5272:	93 1f       	adc	r25, r19
    5274:	fc 01       	movw	r30, r24
    5276:	e8 56       	subi	r30, 0x68	; 104
    5278:	f8 4f       	sbci	r31, 0xF8	; 248
    527a:	80 81       	ld	r24, Z
    527c:	88 23       	and	r24, r24
    527e:	59 f3       	breq	.-42     	; 0x5256 <vTaskSwitchContext+0x28>
    5280:	8b 81       	ldd	r24, Y+3	; 0x03
    5282:	28 2f       	mov	r18, r24
    5284:	30 e0       	ldi	r19, 0x00	; 0
    5286:	c9 01       	movw	r24, r18
    5288:	88 0f       	add	r24, r24
    528a:	99 1f       	adc	r25, r25
    528c:	88 0f       	add	r24, r24
    528e:	99 1f       	adc	r25, r25
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	82 0f       	add	r24, r18
    5296:	93 1f       	adc	r25, r19
    5298:	88 56       	subi	r24, 0x68	; 104
    529a:	98 4f       	sbci	r25, 0xF8	; 248
    529c:	9a 83       	std	Y+2, r25	; 0x02
    529e:	89 83       	std	Y+1, r24	; 0x01
    52a0:	e9 81       	ldd	r30, Y+1	; 0x01
    52a2:	fa 81       	ldd	r31, Y+2	; 0x02
    52a4:	01 80       	ldd	r0, Z+1	; 0x01
    52a6:	f2 81       	ldd	r31, Z+2	; 0x02
    52a8:	e0 2d       	mov	r30, r0
    52aa:	82 81       	ldd	r24, Z+2	; 0x02
    52ac:	93 81       	ldd	r25, Z+3	; 0x03
    52ae:	e9 81       	ldd	r30, Y+1	; 0x01
    52b0:	fa 81       	ldd	r31, Y+2	; 0x02
    52b2:	92 83       	std	Z+2, r25	; 0x02
    52b4:	81 83       	std	Z+1, r24	; 0x01
    52b6:	e9 81       	ldd	r30, Y+1	; 0x01
    52b8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ba:	21 81       	ldd	r18, Z+1	; 0x01
    52bc:	32 81       	ldd	r19, Z+2	; 0x02
    52be:	89 81       	ldd	r24, Y+1	; 0x01
    52c0:	9a 81       	ldd	r25, Y+2	; 0x02
    52c2:	03 96       	adiw	r24, 0x03	; 3
    52c4:	28 17       	cp	r18, r24
    52c6:	39 07       	cpc	r19, r25
    52c8:	59 f4       	brne	.+22     	; 0x52e0 <vTaskSwitchContext+0xb2>
    52ca:	e9 81       	ldd	r30, Y+1	; 0x01
    52cc:	fa 81       	ldd	r31, Y+2	; 0x02
    52ce:	01 80       	ldd	r0, Z+1	; 0x01
    52d0:	f2 81       	ldd	r31, Z+2	; 0x02
    52d2:	e0 2d       	mov	r30, r0
    52d4:	82 81       	ldd	r24, Z+2	; 0x02
    52d6:	93 81       	ldd	r25, Z+3	; 0x03
    52d8:	e9 81       	ldd	r30, Y+1	; 0x01
    52da:	fa 81       	ldd	r31, Y+2	; 0x02
    52dc:	92 83       	std	Z+2, r25	; 0x02
    52de:	81 83       	std	Z+1, r24	; 0x01
    52e0:	e9 81       	ldd	r30, Y+1	; 0x01
    52e2:	fa 81       	ldd	r31, Y+2	; 0x02
    52e4:	01 80       	ldd	r0, Z+1	; 0x01
    52e6:	f2 81       	ldd	r31, Z+2	; 0x02
    52e8:	e0 2d       	mov	r30, r0
    52ea:	86 81       	ldd	r24, Z+6	; 0x06
    52ec:	97 81       	ldd	r25, Z+7	; 0x07
    52ee:	90 93 87 07 	sts	0x0787, r25
    52f2:	80 93 86 07 	sts	0x0786, r24
    52f6:	8b 81       	ldd	r24, Y+3	; 0x03
    52f8:	80 93 8c 07 	sts	0x078C, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    52fc:	0f 90       	pop	r0
    52fe:	0f 90       	pop	r0
    5300:	0f 90       	pop	r0
    5302:	cf 91       	pop	r28
    5304:	df 91       	pop	r29
    5306:	08 95       	ret

00005308 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    5308:	df 93       	push	r29
    530a:	cf 93       	push	r28
    530c:	00 d0       	rcall	.+0      	; 0x530e <vTaskPlaceOnEventList+0x6>
    530e:	00 d0       	rcall	.+0      	; 0x5310 <vTaskPlaceOnEventList+0x8>
    5310:	cd b7       	in	r28, 0x3d	; 61
    5312:	de b7       	in	r29, 0x3e	; 62
    5314:	9a 83       	std	Y+2, r25	; 0x02
    5316:	89 83       	std	Y+1, r24	; 0x01
    5318:	7c 83       	std	Y+4, r23	; 0x04
    531a:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    531c:	80 91 86 07 	lds	r24, 0x0786
    5320:	90 91 87 07 	lds	r25, 0x0787
    5324:	9c 01       	movw	r18, r24
    5326:	24 5f       	subi	r18, 0xF4	; 244
    5328:	3f 4f       	sbci	r19, 0xFF	; 255
    532a:	89 81       	ldd	r24, Y+1	; 0x01
    532c:	9a 81       	ldd	r25, Y+2	; 0x02
    532e:	b9 01       	movw	r22, r18
    5330:	0e 94 75 0f 	call	0x1eea	; 0x1eea <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5334:	8b 81       	ldd	r24, Y+3	; 0x03
    5336:	9c 81       	ldd	r25, Y+4	; 0x04
    5338:	61 e0       	ldi	r22, 0x01	; 1
    533a:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>
}
    533e:	0f 90       	pop	r0
    5340:	0f 90       	pop	r0
    5342:	0f 90       	pop	r0
    5344:	0f 90       	pop	r0
    5346:	cf 91       	pop	r28
    5348:	df 91       	pop	r29
    534a:	08 95       	ret

0000534c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    534c:	df 93       	push	r29
    534e:	cf 93       	push	r28
    5350:	cd b7       	in	r28, 0x3d	; 61
    5352:	de b7       	in	r29, 0x3e	; 62
    5354:	28 97       	sbiw	r28, 0x08	; 8
    5356:	0f b6       	in	r0, 0x3f	; 63
    5358:	f8 94       	cli
    535a:	de bf       	out	0x3e, r29	; 62
    535c:	0f be       	out	0x3f, r0	; 63
    535e:	cd bf       	out	0x3d, r28	; 61
    5360:	9c 83       	std	Y+4, r25	; 0x04
    5362:	8b 83       	std	Y+3, r24	; 0x03
    5364:	7e 83       	std	Y+6, r23	; 0x06
    5366:	6d 83       	std	Y+5, r22	; 0x05
    5368:	58 87       	std	Y+8, r21	; 0x08
    536a:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    536c:	e0 91 86 07 	lds	r30, 0x0786
    5370:	f0 91 87 07 	lds	r31, 0x0787
    5374:	8d 81       	ldd	r24, Y+5	; 0x05
    5376:	9e 81       	ldd	r25, Y+6	; 0x06
    5378:	90 68       	ori	r25, 0x80	; 128
    537a:	95 87       	std	Z+13, r25	; 0x0d
    537c:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    537e:	eb 81       	ldd	r30, Y+3	; 0x03
    5380:	fc 81       	ldd	r31, Y+4	; 0x04
    5382:	81 81       	ldd	r24, Z+1	; 0x01
    5384:	92 81       	ldd	r25, Z+2	; 0x02
    5386:	9a 83       	std	Y+2, r25	; 0x02
    5388:	89 83       	std	Y+1, r24	; 0x01
    538a:	e0 91 86 07 	lds	r30, 0x0786
    538e:	f0 91 87 07 	lds	r31, 0x0787
    5392:	89 81       	ldd	r24, Y+1	; 0x01
    5394:	9a 81       	ldd	r25, Y+2	; 0x02
    5396:	97 87       	std	Z+15, r25	; 0x0f
    5398:	86 87       	std	Z+14, r24	; 0x0e
    539a:	a0 91 86 07 	lds	r26, 0x0786
    539e:	b0 91 87 07 	lds	r27, 0x0787
    53a2:	e9 81       	ldd	r30, Y+1	; 0x01
    53a4:	fa 81       	ldd	r31, Y+2	; 0x02
    53a6:	84 81       	ldd	r24, Z+4	; 0x04
    53a8:	95 81       	ldd	r25, Z+5	; 0x05
    53aa:	51 96       	adiw	r26, 0x11	; 17
    53ac:	9c 93       	st	X, r25
    53ae:	8e 93       	st	-X, r24
    53b0:	50 97       	sbiw	r26, 0x10	; 16
    53b2:	e9 81       	ldd	r30, Y+1	; 0x01
    53b4:	fa 81       	ldd	r31, Y+2	; 0x02
    53b6:	04 80       	ldd	r0, Z+4	; 0x04
    53b8:	f5 81       	ldd	r31, Z+5	; 0x05
    53ba:	e0 2d       	mov	r30, r0
    53bc:	80 91 86 07 	lds	r24, 0x0786
    53c0:	90 91 87 07 	lds	r25, 0x0787
    53c4:	0c 96       	adiw	r24, 0x0c	; 12
    53c6:	93 83       	std	Z+3, r25	; 0x03
    53c8:	82 83       	std	Z+2, r24	; 0x02
    53ca:	80 91 86 07 	lds	r24, 0x0786
    53ce:	90 91 87 07 	lds	r25, 0x0787
    53d2:	0c 96       	adiw	r24, 0x0c	; 12
    53d4:	e9 81       	ldd	r30, Y+1	; 0x01
    53d6:	fa 81       	ldd	r31, Y+2	; 0x02
    53d8:	95 83       	std	Z+5, r25	; 0x05
    53da:	84 83       	std	Z+4, r24	; 0x04
    53dc:	e0 91 86 07 	lds	r30, 0x0786
    53e0:	f0 91 87 07 	lds	r31, 0x0787
    53e4:	8b 81       	ldd	r24, Y+3	; 0x03
    53e6:	9c 81       	ldd	r25, Y+4	; 0x04
    53e8:	95 8b       	std	Z+21, r25	; 0x15
    53ea:	84 8b       	std	Z+20, r24	; 0x14
    53ec:	eb 81       	ldd	r30, Y+3	; 0x03
    53ee:	fc 81       	ldd	r31, Y+4	; 0x04
    53f0:	80 81       	ld	r24, Z
    53f2:	8f 5f       	subi	r24, 0xFF	; 255
    53f4:	eb 81       	ldd	r30, Y+3	; 0x03
    53f6:	fc 81       	ldd	r31, Y+4	; 0x04
    53f8:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    53fa:	8f 81       	ldd	r24, Y+7	; 0x07
    53fc:	98 85       	ldd	r25, Y+8	; 0x08
    53fe:	61 e0       	ldi	r22, 0x01	; 1
    5400:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>
}
    5404:	28 96       	adiw	r28, 0x08	; 8
    5406:	0f b6       	in	r0, 0x3f	; 63
    5408:	f8 94       	cli
    540a:	de bf       	out	0x3e, r29	; 62
    540c:	0f be       	out	0x3f, r0	; 63
    540e:	cd bf       	out	0x3d, r28	; 61
    5410:	cf 91       	pop	r28
    5412:	df 91       	pop	r29
    5414:	08 95       	ret

00005416 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5416:	df 93       	push	r29
    5418:	cf 93       	push	r28
    541a:	cd b7       	in	r28, 0x3d	; 61
    541c:	de b7       	in	r29, 0x3e	; 62
    541e:	2d 97       	sbiw	r28, 0x0d	; 13
    5420:	0f b6       	in	r0, 0x3f	; 63
    5422:	f8 94       	cli
    5424:	de bf       	out	0x3e, r29	; 62
    5426:	0f be       	out	0x3f, r0	; 63
    5428:	cd bf       	out	0x3d, r28	; 61
    542a:	9d 87       	std	Y+13, r25	; 0x0d
    542c:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    542e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5430:	fd 85       	ldd	r31, Y+13	; 0x0d
    5432:	05 80       	ldd	r0, Z+5	; 0x05
    5434:	f6 81       	ldd	r31, Z+6	; 0x06
    5436:	e0 2d       	mov	r30, r0
    5438:	86 81       	ldd	r24, Z+6	; 0x06
    543a:	97 81       	ldd	r25, Z+7	; 0x07
    543c:	9b 87       	std	Y+11, r25	; 0x0b
    543e:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    5440:	ea 85       	ldd	r30, Y+10	; 0x0a
    5442:	fb 85       	ldd	r31, Y+11	; 0x0b
    5444:	84 89       	ldd	r24, Z+20	; 0x14
    5446:	95 89       	ldd	r25, Z+21	; 0x15
    5448:	98 87       	std	Y+8, r25	; 0x08
    544a:	8f 83       	std	Y+7, r24	; 0x07
    544c:	ea 85       	ldd	r30, Y+10	; 0x0a
    544e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5450:	a6 85       	ldd	r26, Z+14	; 0x0e
    5452:	b7 85       	ldd	r27, Z+15	; 0x0f
    5454:	ea 85       	ldd	r30, Y+10	; 0x0a
    5456:	fb 85       	ldd	r31, Y+11	; 0x0b
    5458:	80 89       	ldd	r24, Z+16	; 0x10
    545a:	91 89       	ldd	r25, Z+17	; 0x11
    545c:	15 96       	adiw	r26, 0x05	; 5
    545e:	9c 93       	st	X, r25
    5460:	8e 93       	st	-X, r24
    5462:	14 97       	sbiw	r26, 0x04	; 4
    5464:	ea 85       	ldd	r30, Y+10	; 0x0a
    5466:	fb 85       	ldd	r31, Y+11	; 0x0b
    5468:	a0 89       	ldd	r26, Z+16	; 0x10
    546a:	b1 89       	ldd	r27, Z+17	; 0x11
    546c:	ea 85       	ldd	r30, Y+10	; 0x0a
    546e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5470:	86 85       	ldd	r24, Z+14	; 0x0e
    5472:	97 85       	ldd	r25, Z+15	; 0x0f
    5474:	13 96       	adiw	r26, 0x03	; 3
    5476:	9c 93       	st	X, r25
    5478:	8e 93       	st	-X, r24
    547a:	12 97       	sbiw	r26, 0x02	; 2
    547c:	ef 81       	ldd	r30, Y+7	; 0x07
    547e:	f8 85       	ldd	r31, Y+8	; 0x08
    5480:	21 81       	ldd	r18, Z+1	; 0x01
    5482:	32 81       	ldd	r19, Z+2	; 0x02
    5484:	8a 85       	ldd	r24, Y+10	; 0x0a
    5486:	9b 85       	ldd	r25, Y+11	; 0x0b
    5488:	0c 96       	adiw	r24, 0x0c	; 12
    548a:	28 17       	cp	r18, r24
    548c:	39 07       	cpc	r19, r25
    548e:	41 f4       	brne	.+16     	; 0x54a0 <xTaskRemoveFromEventList+0x8a>
    5490:	ea 85       	ldd	r30, Y+10	; 0x0a
    5492:	fb 85       	ldd	r31, Y+11	; 0x0b
    5494:	80 89       	ldd	r24, Z+16	; 0x10
    5496:	91 89       	ldd	r25, Z+17	; 0x11
    5498:	ef 81       	ldd	r30, Y+7	; 0x07
    549a:	f8 85       	ldd	r31, Y+8	; 0x08
    549c:	92 83       	std	Z+2, r25	; 0x02
    549e:	81 83       	std	Z+1, r24	; 0x01
    54a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    54a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    54a4:	15 8a       	std	Z+21, r1	; 0x15
    54a6:	14 8a       	std	Z+20, r1	; 0x14
    54a8:	ef 81       	ldd	r30, Y+7	; 0x07
    54aa:	f8 85       	ldd	r31, Y+8	; 0x08
    54ac:	80 81       	ld	r24, Z
    54ae:	81 50       	subi	r24, 0x01	; 1
    54b0:	ef 81       	ldd	r30, Y+7	; 0x07
    54b2:	f8 85       	ldd	r31, Y+8	; 0x08
    54b4:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    54b6:	80 91 97 07 	lds	r24, 0x0797
    54ba:	88 23       	and	r24, r24
    54bc:	09 f0       	breq	.+2      	; 0x54c0 <xTaskRemoveFromEventList+0xaa>
    54be:	a4 c0       	rjmp	.+328    	; 0x5608 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    54c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    54c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    54c4:	82 85       	ldd	r24, Z+10	; 0x0a
    54c6:	93 85       	ldd	r25, Z+11	; 0x0b
    54c8:	9e 83       	std	Y+6, r25	; 0x06
    54ca:	8d 83       	std	Y+5, r24	; 0x05
    54cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    54ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    54d0:	a4 81       	ldd	r26, Z+4	; 0x04
    54d2:	b5 81       	ldd	r27, Z+5	; 0x05
    54d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    54d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    54d8:	86 81       	ldd	r24, Z+6	; 0x06
    54da:	97 81       	ldd	r25, Z+7	; 0x07
    54dc:	15 96       	adiw	r26, 0x05	; 5
    54de:	9c 93       	st	X, r25
    54e0:	8e 93       	st	-X, r24
    54e2:	14 97       	sbiw	r26, 0x04	; 4
    54e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    54e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    54e8:	a6 81       	ldd	r26, Z+6	; 0x06
    54ea:	b7 81       	ldd	r27, Z+7	; 0x07
    54ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    54ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    54f0:	84 81       	ldd	r24, Z+4	; 0x04
    54f2:	95 81       	ldd	r25, Z+5	; 0x05
    54f4:	13 96       	adiw	r26, 0x03	; 3
    54f6:	9c 93       	st	X, r25
    54f8:	8e 93       	st	-X, r24
    54fa:	12 97       	sbiw	r26, 0x02	; 2
    54fc:	ed 81       	ldd	r30, Y+5	; 0x05
    54fe:	fe 81       	ldd	r31, Y+6	; 0x06
    5500:	21 81       	ldd	r18, Z+1	; 0x01
    5502:	32 81       	ldd	r19, Z+2	; 0x02
    5504:	8a 85       	ldd	r24, Y+10	; 0x0a
    5506:	9b 85       	ldd	r25, Y+11	; 0x0b
    5508:	02 96       	adiw	r24, 0x02	; 2
    550a:	28 17       	cp	r18, r24
    550c:	39 07       	cpc	r19, r25
    550e:	41 f4       	brne	.+16     	; 0x5520 <xTaskRemoveFromEventList+0x10a>
    5510:	ea 85       	ldd	r30, Y+10	; 0x0a
    5512:	fb 85       	ldd	r31, Y+11	; 0x0b
    5514:	86 81       	ldd	r24, Z+6	; 0x06
    5516:	97 81       	ldd	r25, Z+7	; 0x07
    5518:	ed 81       	ldd	r30, Y+5	; 0x05
    551a:	fe 81       	ldd	r31, Y+6	; 0x06
    551c:	92 83       	std	Z+2, r25	; 0x02
    551e:	81 83       	std	Z+1, r24	; 0x01
    5520:	ea 85       	ldd	r30, Y+10	; 0x0a
    5522:	fb 85       	ldd	r31, Y+11	; 0x0b
    5524:	13 86       	std	Z+11, r1	; 0x0b
    5526:	12 86       	std	Z+10, r1	; 0x0a
    5528:	ed 81       	ldd	r30, Y+5	; 0x05
    552a:	fe 81       	ldd	r31, Y+6	; 0x06
    552c:	80 81       	ld	r24, Z
    552e:	81 50       	subi	r24, 0x01	; 1
    5530:	ed 81       	ldd	r30, Y+5	; 0x05
    5532:	fe 81       	ldd	r31, Y+6	; 0x06
    5534:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    5536:	ea 85       	ldd	r30, Y+10	; 0x0a
    5538:	fb 85       	ldd	r31, Y+11	; 0x0b
    553a:	96 89       	ldd	r25, Z+22	; 0x16
    553c:	80 91 8c 07 	lds	r24, 0x078C
    5540:	89 17       	cp	r24, r25
    5542:	28 f4       	brcc	.+10     	; 0x554e <xTaskRemoveFromEventList+0x138>
    5544:	ea 85       	ldd	r30, Y+10	; 0x0a
    5546:	fb 85       	ldd	r31, Y+11	; 0x0b
    5548:	86 89       	ldd	r24, Z+22	; 0x16
    554a:	80 93 8c 07 	sts	0x078C, r24
    554e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5550:	fb 85       	ldd	r31, Y+11	; 0x0b
    5552:	86 89       	ldd	r24, Z+22	; 0x16
    5554:	28 2f       	mov	r18, r24
    5556:	30 e0       	ldi	r19, 0x00	; 0
    5558:	c9 01       	movw	r24, r18
    555a:	88 0f       	add	r24, r24
    555c:	99 1f       	adc	r25, r25
    555e:	88 0f       	add	r24, r24
    5560:	99 1f       	adc	r25, r25
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	82 0f       	add	r24, r18
    5568:	93 1f       	adc	r25, r19
    556a:	fc 01       	movw	r30, r24
    556c:	e8 56       	subi	r30, 0x68	; 104
    556e:	f8 4f       	sbci	r31, 0xF8	; 248
    5570:	81 81       	ldd	r24, Z+1	; 0x01
    5572:	92 81       	ldd	r25, Z+2	; 0x02
    5574:	9c 83       	std	Y+4, r25	; 0x04
    5576:	8b 83       	std	Y+3, r24	; 0x03
    5578:	ea 85       	ldd	r30, Y+10	; 0x0a
    557a:	fb 85       	ldd	r31, Y+11	; 0x0b
    557c:	8b 81       	ldd	r24, Y+3	; 0x03
    557e:	9c 81       	ldd	r25, Y+4	; 0x04
    5580:	95 83       	std	Z+5, r25	; 0x05
    5582:	84 83       	std	Z+4, r24	; 0x04
    5584:	eb 81       	ldd	r30, Y+3	; 0x03
    5586:	fc 81       	ldd	r31, Y+4	; 0x04
    5588:	84 81       	ldd	r24, Z+4	; 0x04
    558a:	95 81       	ldd	r25, Z+5	; 0x05
    558c:	ea 85       	ldd	r30, Y+10	; 0x0a
    558e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5590:	97 83       	std	Z+7, r25	; 0x07
    5592:	86 83       	std	Z+6, r24	; 0x06
    5594:	eb 81       	ldd	r30, Y+3	; 0x03
    5596:	fc 81       	ldd	r31, Y+4	; 0x04
    5598:	04 80       	ldd	r0, Z+4	; 0x04
    559a:	f5 81       	ldd	r31, Z+5	; 0x05
    559c:	e0 2d       	mov	r30, r0
    559e:	8a 85       	ldd	r24, Y+10	; 0x0a
    55a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    55a2:	02 96       	adiw	r24, 0x02	; 2
    55a4:	93 83       	std	Z+3, r25	; 0x03
    55a6:	82 83       	std	Z+2, r24	; 0x02
    55a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    55aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    55ac:	02 96       	adiw	r24, 0x02	; 2
    55ae:	eb 81       	ldd	r30, Y+3	; 0x03
    55b0:	fc 81       	ldd	r31, Y+4	; 0x04
    55b2:	95 83       	std	Z+5, r25	; 0x05
    55b4:	84 83       	std	Z+4, r24	; 0x04
    55b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    55b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    55ba:	86 89       	ldd	r24, Z+22	; 0x16
    55bc:	28 2f       	mov	r18, r24
    55be:	30 e0       	ldi	r19, 0x00	; 0
    55c0:	c9 01       	movw	r24, r18
    55c2:	88 0f       	add	r24, r24
    55c4:	99 1f       	adc	r25, r25
    55c6:	88 0f       	add	r24, r24
    55c8:	99 1f       	adc	r25, r25
    55ca:	88 0f       	add	r24, r24
    55cc:	99 1f       	adc	r25, r25
    55ce:	82 0f       	add	r24, r18
    55d0:	93 1f       	adc	r25, r19
    55d2:	88 56       	subi	r24, 0x68	; 104
    55d4:	98 4f       	sbci	r25, 0xF8	; 248
    55d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    55d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    55da:	93 87       	std	Z+11, r25	; 0x0b
    55dc:	82 87       	std	Z+10, r24	; 0x0a
    55de:	ea 85       	ldd	r30, Y+10	; 0x0a
    55e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    55e2:	86 89       	ldd	r24, Z+22	; 0x16
    55e4:	28 2f       	mov	r18, r24
    55e6:	30 e0       	ldi	r19, 0x00	; 0
    55e8:	c9 01       	movw	r24, r18
    55ea:	88 0f       	add	r24, r24
    55ec:	99 1f       	adc	r25, r25
    55ee:	88 0f       	add	r24, r24
    55f0:	99 1f       	adc	r25, r25
    55f2:	88 0f       	add	r24, r24
    55f4:	99 1f       	adc	r25, r25
    55f6:	82 0f       	add	r24, r18
    55f8:	93 1f       	adc	r25, r19
    55fa:	fc 01       	movw	r30, r24
    55fc:	e8 56       	subi	r30, 0x68	; 104
    55fe:	f8 4f       	sbci	r31, 0xF8	; 248
    5600:	80 81       	ld	r24, Z
    5602:	8f 5f       	subi	r24, 0xFF	; 255
    5604:	80 83       	st	Z, r24
    5606:	30 c0       	rjmp	.+96     	; 0x5668 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5608:	80 91 09 08 	lds	r24, 0x0809
    560c:	90 91 0a 08 	lds	r25, 0x080A
    5610:	9a 83       	std	Y+2, r25	; 0x02
    5612:	89 83       	std	Y+1, r24	; 0x01
    5614:	ea 85       	ldd	r30, Y+10	; 0x0a
    5616:	fb 85       	ldd	r31, Y+11	; 0x0b
    5618:	89 81       	ldd	r24, Y+1	; 0x01
    561a:	9a 81       	ldd	r25, Y+2	; 0x02
    561c:	97 87       	std	Z+15, r25	; 0x0f
    561e:	86 87       	std	Z+14, r24	; 0x0e
    5620:	e9 81       	ldd	r30, Y+1	; 0x01
    5622:	fa 81       	ldd	r31, Y+2	; 0x02
    5624:	84 81       	ldd	r24, Z+4	; 0x04
    5626:	95 81       	ldd	r25, Z+5	; 0x05
    5628:	ea 85       	ldd	r30, Y+10	; 0x0a
    562a:	fb 85       	ldd	r31, Y+11	; 0x0b
    562c:	91 8b       	std	Z+17, r25	; 0x11
    562e:	80 8b       	std	Z+16, r24	; 0x10
    5630:	e9 81       	ldd	r30, Y+1	; 0x01
    5632:	fa 81       	ldd	r31, Y+2	; 0x02
    5634:	04 80       	ldd	r0, Z+4	; 0x04
    5636:	f5 81       	ldd	r31, Z+5	; 0x05
    5638:	e0 2d       	mov	r30, r0
    563a:	8a 85       	ldd	r24, Y+10	; 0x0a
    563c:	9b 85       	ldd	r25, Y+11	; 0x0b
    563e:	0c 96       	adiw	r24, 0x0c	; 12
    5640:	93 83       	std	Z+3, r25	; 0x03
    5642:	82 83       	std	Z+2, r24	; 0x02
    5644:	8a 85       	ldd	r24, Y+10	; 0x0a
    5646:	9b 85       	ldd	r25, Y+11	; 0x0b
    5648:	0c 96       	adiw	r24, 0x0c	; 12
    564a:	e9 81       	ldd	r30, Y+1	; 0x01
    564c:	fa 81       	ldd	r31, Y+2	; 0x02
    564e:	95 83       	std	Z+5, r25	; 0x05
    5650:	84 83       	std	Z+4, r24	; 0x04
    5652:	ea 85       	ldd	r30, Y+10	; 0x0a
    5654:	fb 85       	ldd	r31, Y+11	; 0x0b
    5656:	88 e0       	ldi	r24, 0x08	; 8
    5658:	98 e0       	ldi	r25, 0x08	; 8
    565a:	95 8b       	std	Z+21, r25	; 0x15
    565c:	84 8b       	std	Z+20, r24	; 0x14
    565e:	80 91 08 08 	lds	r24, 0x0808
    5662:	8f 5f       	subi	r24, 0xFF	; 255
    5664:	80 93 08 08 	sts	0x0808, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5668:	ea 85       	ldd	r30, Y+10	; 0x0a
    566a:	fb 85       	ldd	r31, Y+11	; 0x0b
    566c:	96 89       	ldd	r25, Z+22	; 0x16
    566e:	e0 91 86 07 	lds	r30, 0x0786
    5672:	f0 91 87 07 	lds	r31, 0x0787
    5676:	86 89       	ldd	r24, Z+22	; 0x16
    5678:	89 17       	cp	r24, r25
    567a:	30 f4       	brcc	.+12     	; 0x5688 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    567c:	81 e0       	ldi	r24, 0x01	; 1
    567e:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    5680:	81 e0       	ldi	r24, 0x01	; 1
    5682:	80 93 90 07 	sts	0x0790, r24
    5686:	01 c0       	rjmp	.+2      	; 0x568a <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    5688:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    568a:	89 85       	ldd	r24, Y+9	; 0x09
}
    568c:	2d 96       	adiw	r28, 0x0d	; 13
    568e:	0f b6       	in	r0, 0x3f	; 63
    5690:	f8 94       	cli
    5692:	de bf       	out	0x3e, r29	; 62
    5694:	0f be       	out	0x3f, r0	; 63
    5696:	cd bf       	out	0x3d, r28	; 61
    5698:	cf 91       	pop	r28
    569a:	df 91       	pop	r29
    569c:	08 95       	ret

0000569e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    569e:	df 93       	push	r29
    56a0:	cf 93       	push	r28
    56a2:	cd b7       	in	r28, 0x3d	; 61
    56a4:	de b7       	in	r29, 0x3e	; 62
    56a6:	2c 97       	sbiw	r28, 0x0c	; 12
    56a8:	0f b6       	in	r0, 0x3f	; 63
    56aa:	f8 94       	cli
    56ac:	de bf       	out	0x3e, r29	; 62
    56ae:	0f be       	out	0x3f, r0	; 63
    56b0:	cd bf       	out	0x3d, r28	; 61
    56b2:	9a 87       	std	Y+10, r25	; 0x0a
    56b4:	89 87       	std	Y+9, r24	; 0x09
    56b6:	7c 87       	std	Y+12, r23	; 0x0c
    56b8:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    56ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    56bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    56be:	90 68       	ori	r25, 0x80	; 128
    56c0:	e9 85       	ldd	r30, Y+9	; 0x09
    56c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    56c4:	91 83       	std	Z+1, r25	; 0x01
    56c6:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    56c8:	e9 85       	ldd	r30, Y+9	; 0x09
    56ca:	fa 85       	ldd	r31, Y+10	; 0x0a
    56cc:	86 81       	ldd	r24, Z+6	; 0x06
    56ce:	97 81       	ldd	r25, Z+7	; 0x07
    56d0:	98 87       	std	Y+8, r25	; 0x08
    56d2:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    56d4:	e9 85       	ldd	r30, Y+9	; 0x09
    56d6:	fa 85       	ldd	r31, Y+10	; 0x0a
    56d8:	80 85       	ldd	r24, Z+8	; 0x08
    56da:	91 85       	ldd	r25, Z+9	; 0x09
    56dc:	9e 83       	std	Y+6, r25	; 0x06
    56de:	8d 83       	std	Y+5, r24	; 0x05
    56e0:	e9 85       	ldd	r30, Y+9	; 0x09
    56e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    56e4:	a2 81       	ldd	r26, Z+2	; 0x02
    56e6:	b3 81       	ldd	r27, Z+3	; 0x03
    56e8:	e9 85       	ldd	r30, Y+9	; 0x09
    56ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    56ec:	84 81       	ldd	r24, Z+4	; 0x04
    56ee:	95 81       	ldd	r25, Z+5	; 0x05
    56f0:	15 96       	adiw	r26, 0x05	; 5
    56f2:	9c 93       	st	X, r25
    56f4:	8e 93       	st	-X, r24
    56f6:	14 97       	sbiw	r26, 0x04	; 4
    56f8:	e9 85       	ldd	r30, Y+9	; 0x09
    56fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    56fc:	a4 81       	ldd	r26, Z+4	; 0x04
    56fe:	b5 81       	ldd	r27, Z+5	; 0x05
    5700:	e9 85       	ldd	r30, Y+9	; 0x09
    5702:	fa 85       	ldd	r31, Y+10	; 0x0a
    5704:	82 81       	ldd	r24, Z+2	; 0x02
    5706:	93 81       	ldd	r25, Z+3	; 0x03
    5708:	13 96       	adiw	r26, 0x03	; 3
    570a:	9c 93       	st	X, r25
    570c:	8e 93       	st	-X, r24
    570e:	12 97       	sbiw	r26, 0x02	; 2
    5710:	ed 81       	ldd	r30, Y+5	; 0x05
    5712:	fe 81       	ldd	r31, Y+6	; 0x06
    5714:	21 81       	ldd	r18, Z+1	; 0x01
    5716:	32 81       	ldd	r19, Z+2	; 0x02
    5718:	89 85       	ldd	r24, Y+9	; 0x09
    571a:	9a 85       	ldd	r25, Y+10	; 0x0a
    571c:	28 17       	cp	r18, r24
    571e:	39 07       	cpc	r19, r25
    5720:	41 f4       	brne	.+16     	; 0x5732 <vTaskRemoveFromUnorderedEventList+0x94>
    5722:	e9 85       	ldd	r30, Y+9	; 0x09
    5724:	fa 85       	ldd	r31, Y+10	; 0x0a
    5726:	84 81       	ldd	r24, Z+4	; 0x04
    5728:	95 81       	ldd	r25, Z+5	; 0x05
    572a:	ed 81       	ldd	r30, Y+5	; 0x05
    572c:	fe 81       	ldd	r31, Y+6	; 0x06
    572e:	92 83       	std	Z+2, r25	; 0x02
    5730:	81 83       	std	Z+1, r24	; 0x01
    5732:	e9 85       	ldd	r30, Y+9	; 0x09
    5734:	fa 85       	ldd	r31, Y+10	; 0x0a
    5736:	11 86       	std	Z+9, r1	; 0x09
    5738:	10 86       	std	Z+8, r1	; 0x08
    573a:	ed 81       	ldd	r30, Y+5	; 0x05
    573c:	fe 81       	ldd	r31, Y+6	; 0x06
    573e:	80 81       	ld	r24, Z
    5740:	81 50       	subi	r24, 0x01	; 1
    5742:	ed 81       	ldd	r30, Y+5	; 0x05
    5744:	fe 81       	ldd	r31, Y+6	; 0x06
    5746:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    5748:	ef 81       	ldd	r30, Y+7	; 0x07
    574a:	f8 85       	ldd	r31, Y+8	; 0x08
    574c:	82 85       	ldd	r24, Z+10	; 0x0a
    574e:	93 85       	ldd	r25, Z+11	; 0x0b
    5750:	9c 83       	std	Y+4, r25	; 0x04
    5752:	8b 83       	std	Y+3, r24	; 0x03
    5754:	ef 81       	ldd	r30, Y+7	; 0x07
    5756:	f8 85       	ldd	r31, Y+8	; 0x08
    5758:	a4 81       	ldd	r26, Z+4	; 0x04
    575a:	b5 81       	ldd	r27, Z+5	; 0x05
    575c:	ef 81       	ldd	r30, Y+7	; 0x07
    575e:	f8 85       	ldd	r31, Y+8	; 0x08
    5760:	86 81       	ldd	r24, Z+6	; 0x06
    5762:	97 81       	ldd	r25, Z+7	; 0x07
    5764:	15 96       	adiw	r26, 0x05	; 5
    5766:	9c 93       	st	X, r25
    5768:	8e 93       	st	-X, r24
    576a:	14 97       	sbiw	r26, 0x04	; 4
    576c:	ef 81       	ldd	r30, Y+7	; 0x07
    576e:	f8 85       	ldd	r31, Y+8	; 0x08
    5770:	a6 81       	ldd	r26, Z+6	; 0x06
    5772:	b7 81       	ldd	r27, Z+7	; 0x07
    5774:	ef 81       	ldd	r30, Y+7	; 0x07
    5776:	f8 85       	ldd	r31, Y+8	; 0x08
    5778:	84 81       	ldd	r24, Z+4	; 0x04
    577a:	95 81       	ldd	r25, Z+5	; 0x05
    577c:	13 96       	adiw	r26, 0x03	; 3
    577e:	9c 93       	st	X, r25
    5780:	8e 93       	st	-X, r24
    5782:	12 97       	sbiw	r26, 0x02	; 2
    5784:	eb 81       	ldd	r30, Y+3	; 0x03
    5786:	fc 81       	ldd	r31, Y+4	; 0x04
    5788:	21 81       	ldd	r18, Z+1	; 0x01
    578a:	32 81       	ldd	r19, Z+2	; 0x02
    578c:	8f 81       	ldd	r24, Y+7	; 0x07
    578e:	98 85       	ldd	r25, Y+8	; 0x08
    5790:	02 96       	adiw	r24, 0x02	; 2
    5792:	28 17       	cp	r18, r24
    5794:	39 07       	cpc	r19, r25
    5796:	41 f4       	brne	.+16     	; 0x57a8 <vTaskRemoveFromUnorderedEventList+0x10a>
    5798:	ef 81       	ldd	r30, Y+7	; 0x07
    579a:	f8 85       	ldd	r31, Y+8	; 0x08
    579c:	86 81       	ldd	r24, Z+6	; 0x06
    579e:	97 81       	ldd	r25, Z+7	; 0x07
    57a0:	eb 81       	ldd	r30, Y+3	; 0x03
    57a2:	fc 81       	ldd	r31, Y+4	; 0x04
    57a4:	92 83       	std	Z+2, r25	; 0x02
    57a6:	81 83       	std	Z+1, r24	; 0x01
    57a8:	ef 81       	ldd	r30, Y+7	; 0x07
    57aa:	f8 85       	ldd	r31, Y+8	; 0x08
    57ac:	13 86       	std	Z+11, r1	; 0x0b
    57ae:	12 86       	std	Z+10, r1	; 0x0a
    57b0:	eb 81       	ldd	r30, Y+3	; 0x03
    57b2:	fc 81       	ldd	r31, Y+4	; 0x04
    57b4:	80 81       	ld	r24, Z
    57b6:	81 50       	subi	r24, 0x01	; 1
    57b8:	eb 81       	ldd	r30, Y+3	; 0x03
    57ba:	fc 81       	ldd	r31, Y+4	; 0x04
    57bc:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    57be:	ef 81       	ldd	r30, Y+7	; 0x07
    57c0:	f8 85       	ldd	r31, Y+8	; 0x08
    57c2:	96 89       	ldd	r25, Z+22	; 0x16
    57c4:	80 91 8c 07 	lds	r24, 0x078C
    57c8:	89 17       	cp	r24, r25
    57ca:	28 f4       	brcc	.+10     	; 0x57d6 <vTaskRemoveFromUnorderedEventList+0x138>
    57cc:	ef 81       	ldd	r30, Y+7	; 0x07
    57ce:	f8 85       	ldd	r31, Y+8	; 0x08
    57d0:	86 89       	ldd	r24, Z+22	; 0x16
    57d2:	80 93 8c 07 	sts	0x078C, r24
    57d6:	ef 81       	ldd	r30, Y+7	; 0x07
    57d8:	f8 85       	ldd	r31, Y+8	; 0x08
    57da:	86 89       	ldd	r24, Z+22	; 0x16
    57dc:	28 2f       	mov	r18, r24
    57de:	30 e0       	ldi	r19, 0x00	; 0
    57e0:	c9 01       	movw	r24, r18
    57e2:	88 0f       	add	r24, r24
    57e4:	99 1f       	adc	r25, r25
    57e6:	88 0f       	add	r24, r24
    57e8:	99 1f       	adc	r25, r25
    57ea:	88 0f       	add	r24, r24
    57ec:	99 1f       	adc	r25, r25
    57ee:	82 0f       	add	r24, r18
    57f0:	93 1f       	adc	r25, r19
    57f2:	fc 01       	movw	r30, r24
    57f4:	e8 56       	subi	r30, 0x68	; 104
    57f6:	f8 4f       	sbci	r31, 0xF8	; 248
    57f8:	81 81       	ldd	r24, Z+1	; 0x01
    57fa:	92 81       	ldd	r25, Z+2	; 0x02
    57fc:	9a 83       	std	Y+2, r25	; 0x02
    57fe:	89 83       	std	Y+1, r24	; 0x01
    5800:	ef 81       	ldd	r30, Y+7	; 0x07
    5802:	f8 85       	ldd	r31, Y+8	; 0x08
    5804:	89 81       	ldd	r24, Y+1	; 0x01
    5806:	9a 81       	ldd	r25, Y+2	; 0x02
    5808:	95 83       	std	Z+5, r25	; 0x05
    580a:	84 83       	std	Z+4, r24	; 0x04
    580c:	e9 81       	ldd	r30, Y+1	; 0x01
    580e:	fa 81       	ldd	r31, Y+2	; 0x02
    5810:	84 81       	ldd	r24, Z+4	; 0x04
    5812:	95 81       	ldd	r25, Z+5	; 0x05
    5814:	ef 81       	ldd	r30, Y+7	; 0x07
    5816:	f8 85       	ldd	r31, Y+8	; 0x08
    5818:	97 83       	std	Z+7, r25	; 0x07
    581a:	86 83       	std	Z+6, r24	; 0x06
    581c:	e9 81       	ldd	r30, Y+1	; 0x01
    581e:	fa 81       	ldd	r31, Y+2	; 0x02
    5820:	04 80       	ldd	r0, Z+4	; 0x04
    5822:	f5 81       	ldd	r31, Z+5	; 0x05
    5824:	e0 2d       	mov	r30, r0
    5826:	8f 81       	ldd	r24, Y+7	; 0x07
    5828:	98 85       	ldd	r25, Y+8	; 0x08
    582a:	02 96       	adiw	r24, 0x02	; 2
    582c:	93 83       	std	Z+3, r25	; 0x03
    582e:	82 83       	std	Z+2, r24	; 0x02
    5830:	8f 81       	ldd	r24, Y+7	; 0x07
    5832:	98 85       	ldd	r25, Y+8	; 0x08
    5834:	02 96       	adiw	r24, 0x02	; 2
    5836:	e9 81       	ldd	r30, Y+1	; 0x01
    5838:	fa 81       	ldd	r31, Y+2	; 0x02
    583a:	95 83       	std	Z+5, r25	; 0x05
    583c:	84 83       	std	Z+4, r24	; 0x04
    583e:	ef 81       	ldd	r30, Y+7	; 0x07
    5840:	f8 85       	ldd	r31, Y+8	; 0x08
    5842:	86 89       	ldd	r24, Z+22	; 0x16
    5844:	28 2f       	mov	r18, r24
    5846:	30 e0       	ldi	r19, 0x00	; 0
    5848:	c9 01       	movw	r24, r18
    584a:	88 0f       	add	r24, r24
    584c:	99 1f       	adc	r25, r25
    584e:	88 0f       	add	r24, r24
    5850:	99 1f       	adc	r25, r25
    5852:	88 0f       	add	r24, r24
    5854:	99 1f       	adc	r25, r25
    5856:	82 0f       	add	r24, r18
    5858:	93 1f       	adc	r25, r19
    585a:	88 56       	subi	r24, 0x68	; 104
    585c:	98 4f       	sbci	r25, 0xF8	; 248
    585e:	ef 81       	ldd	r30, Y+7	; 0x07
    5860:	f8 85       	ldd	r31, Y+8	; 0x08
    5862:	93 87       	std	Z+11, r25	; 0x0b
    5864:	82 87       	std	Z+10, r24	; 0x0a
    5866:	ef 81       	ldd	r30, Y+7	; 0x07
    5868:	f8 85       	ldd	r31, Y+8	; 0x08
    586a:	86 89       	ldd	r24, Z+22	; 0x16
    586c:	28 2f       	mov	r18, r24
    586e:	30 e0       	ldi	r19, 0x00	; 0
    5870:	c9 01       	movw	r24, r18
    5872:	88 0f       	add	r24, r24
    5874:	99 1f       	adc	r25, r25
    5876:	88 0f       	add	r24, r24
    5878:	99 1f       	adc	r25, r25
    587a:	88 0f       	add	r24, r24
    587c:	99 1f       	adc	r25, r25
    587e:	82 0f       	add	r24, r18
    5880:	93 1f       	adc	r25, r19
    5882:	fc 01       	movw	r30, r24
    5884:	e8 56       	subi	r30, 0x68	; 104
    5886:	f8 4f       	sbci	r31, 0xF8	; 248
    5888:	80 81       	ld	r24, Z
    588a:	8f 5f       	subi	r24, 0xFF	; 255
    588c:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    588e:	ef 81       	ldd	r30, Y+7	; 0x07
    5890:	f8 85       	ldd	r31, Y+8	; 0x08
    5892:	96 89       	ldd	r25, Z+22	; 0x16
    5894:	e0 91 86 07 	lds	r30, 0x0786
    5898:	f0 91 87 07 	lds	r31, 0x0787
    589c:	86 89       	ldd	r24, Z+22	; 0x16
    589e:	89 17       	cp	r24, r25
    58a0:	18 f4       	brcc	.+6      	; 0x58a8 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    58a2:	81 e0       	ldi	r24, 0x01	; 1
    58a4:	80 93 90 07 	sts	0x0790, r24
    }
}
    58a8:	2c 96       	adiw	r28, 0x0c	; 12
    58aa:	0f b6       	in	r0, 0x3f	; 63
    58ac:	f8 94       	cli
    58ae:	de bf       	out	0x3e, r29	; 62
    58b0:	0f be       	out	0x3f, r0	; 63
    58b2:	cd bf       	out	0x3d, r28	; 61
    58b4:	cf 91       	pop	r28
    58b6:	df 91       	pop	r29
    58b8:	08 95       	ret

000058ba <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    58ba:	df 93       	push	r29
    58bc:	cf 93       	push	r28
    58be:	00 d0       	rcall	.+0      	; 0x58c0 <vTaskSetTimeOutState+0x6>
    58c0:	cd b7       	in	r28, 0x3d	; 61
    58c2:	de b7       	in	r29, 0x3e	; 62
    58c4:	9a 83       	std	Y+2, r25	; 0x02
    58c6:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    58c8:	0f b6       	in	r0, 0x3f	; 63
    58ca:	f8 94       	cli
    58cc:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    58ce:	80 91 91 07 	lds	r24, 0x0791
    58d2:	e9 81       	ldd	r30, Y+1	; 0x01
    58d4:	fa 81       	ldd	r31, Y+2	; 0x02
    58d6:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    58d8:	80 91 8a 07 	lds	r24, 0x078A
    58dc:	90 91 8b 07 	lds	r25, 0x078B
    58e0:	e9 81       	ldd	r30, Y+1	; 0x01
    58e2:	fa 81       	ldd	r31, Y+2	; 0x02
    58e4:	92 83       	std	Z+2, r25	; 0x02
    58e6:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    58e8:	0f 90       	pop	r0
    58ea:	0f be       	out	0x3f, r0	; 63
}
    58ec:	0f 90       	pop	r0
    58ee:	0f 90       	pop	r0
    58f0:	cf 91       	pop	r28
    58f2:	df 91       	pop	r29
    58f4:	08 95       	ret

000058f6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    58f6:	df 93       	push	r29
    58f8:	cf 93       	push	r28
    58fa:	00 d0       	rcall	.+0      	; 0x58fc <vTaskInternalSetTimeOutState+0x6>
    58fc:	cd b7       	in	r28, 0x3d	; 61
    58fe:	de b7       	in	r29, 0x3e	; 62
    5900:	9a 83       	std	Y+2, r25	; 0x02
    5902:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    5904:	80 91 91 07 	lds	r24, 0x0791
    5908:	e9 81       	ldd	r30, Y+1	; 0x01
    590a:	fa 81       	ldd	r31, Y+2	; 0x02
    590c:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    590e:	80 91 8a 07 	lds	r24, 0x078A
    5912:	90 91 8b 07 	lds	r25, 0x078B
    5916:	e9 81       	ldd	r30, Y+1	; 0x01
    5918:	fa 81       	ldd	r31, Y+2	; 0x02
    591a:	92 83       	std	Z+2, r25	; 0x02
    591c:	81 83       	std	Z+1, r24	; 0x01
}
    591e:	0f 90       	pop	r0
    5920:	0f 90       	pop	r0
    5922:	cf 91       	pop	r28
    5924:	df 91       	pop	r29
    5926:	08 95       	ret

00005928 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    5928:	df 93       	push	r29
    592a:	cf 93       	push	r28
    592c:	cd b7       	in	r28, 0x3d	; 61
    592e:	de b7       	in	r29, 0x3e	; 62
    5930:	29 97       	sbiw	r28, 0x09	; 9
    5932:	0f b6       	in	r0, 0x3f	; 63
    5934:	f8 94       	cli
    5936:	de bf       	out	0x3e, r29	; 62
    5938:	0f be       	out	0x3f, r0	; 63
    593a:	cd bf       	out	0x3d, r28	; 61
    593c:	9f 83       	std	Y+7, r25	; 0x07
    593e:	8e 83       	std	Y+6, r24	; 0x06
    5940:	79 87       	std	Y+9, r23	; 0x09
    5942:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    5944:	0f b6       	in	r0, 0x3f	; 63
    5946:	f8 94       	cli
    5948:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    594a:	80 91 8a 07 	lds	r24, 0x078A
    594e:	90 91 8b 07 	lds	r25, 0x078B
    5952:	9c 83       	std	Y+4, r25	; 0x04
    5954:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5956:	ee 81       	ldd	r30, Y+6	; 0x06
    5958:	ff 81       	ldd	r31, Y+7	; 0x07
    595a:	21 81       	ldd	r18, Z+1	; 0x01
    595c:	32 81       	ldd	r19, Z+2	; 0x02
    595e:	8b 81       	ldd	r24, Y+3	; 0x03
    5960:	9c 81       	ldd	r25, Y+4	; 0x04
    5962:	82 1b       	sub	r24, r18
    5964:	93 0b       	sbc	r25, r19
    5966:	9a 83       	std	Y+2, r25	; 0x02
    5968:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    596a:	ee 81       	ldd	r30, Y+6	; 0x06
    596c:	ff 81       	ldd	r31, Y+7	; 0x07
    596e:	90 81       	ld	r25, Z
    5970:	80 91 91 07 	lds	r24, 0x0791
    5974:	98 17       	cp	r25, r24
    5976:	81 f0       	breq	.+32     	; 0x5998 <xTaskCheckForTimeOut+0x70>
    5978:	ee 81       	ldd	r30, Y+6	; 0x06
    597a:	ff 81       	ldd	r31, Y+7	; 0x07
    597c:	21 81       	ldd	r18, Z+1	; 0x01
    597e:	32 81       	ldd	r19, Z+2	; 0x02
    5980:	8b 81       	ldd	r24, Y+3	; 0x03
    5982:	9c 81       	ldd	r25, Y+4	; 0x04
    5984:	82 17       	cp	r24, r18
    5986:	93 07       	cpc	r25, r19
    5988:	38 f0       	brcs	.+14     	; 0x5998 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    598a:	81 e0       	ldi	r24, 0x01	; 1
    598c:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    598e:	e8 85       	ldd	r30, Y+8	; 0x08
    5990:	f9 85       	ldd	r31, Y+9	; 0x09
    5992:	11 82       	std	Z+1, r1	; 0x01
    5994:	10 82       	st	Z, r1
    5996:	23 c0       	rjmp	.+70     	; 0x59de <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5998:	e8 85       	ldd	r30, Y+8	; 0x08
    599a:	f9 85       	ldd	r31, Y+9	; 0x09
    599c:	20 81       	ld	r18, Z
    599e:	31 81       	ldd	r19, Z+1	; 0x01
    59a0:	89 81       	ldd	r24, Y+1	; 0x01
    59a2:	9a 81       	ldd	r25, Y+2	; 0x02
    59a4:	82 17       	cp	r24, r18
    59a6:	93 07       	cpc	r25, r19
    59a8:	a0 f4       	brcc	.+40     	; 0x59d2 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    59aa:	e8 85       	ldd	r30, Y+8	; 0x08
    59ac:	f9 85       	ldd	r31, Y+9	; 0x09
    59ae:	20 81       	ld	r18, Z
    59b0:	31 81       	ldd	r19, Z+1	; 0x01
    59b2:	89 81       	ldd	r24, Y+1	; 0x01
    59b4:	9a 81       	ldd	r25, Y+2	; 0x02
    59b6:	a9 01       	movw	r20, r18
    59b8:	48 1b       	sub	r20, r24
    59ba:	59 0b       	sbc	r21, r25
    59bc:	ca 01       	movw	r24, r20
    59be:	e8 85       	ldd	r30, Y+8	; 0x08
    59c0:	f9 85       	ldd	r31, Y+9	; 0x09
    59c2:	91 83       	std	Z+1, r25	; 0x01
    59c4:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    59c6:	8e 81       	ldd	r24, Y+6	; 0x06
    59c8:	9f 81       	ldd	r25, Y+7	; 0x07
    59ca:	0e 94 7b 2c 	call	0x58f6	; 0x58f6 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    59ce:	1d 82       	std	Y+5, r1	; 0x05
    59d0:	06 c0       	rjmp	.+12     	; 0x59de <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    59d2:	e8 85       	ldd	r30, Y+8	; 0x08
    59d4:	f9 85       	ldd	r31, Y+9	; 0x09
    59d6:	11 82       	std	Z+1, r1	; 0x01
    59d8:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    59da:	81 e0       	ldi	r24, 0x01	; 1
    59dc:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    59de:	0f 90       	pop	r0
    59e0:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    59e2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    59e4:	29 96       	adiw	r28, 0x09	; 9
    59e6:	0f b6       	in	r0, 0x3f	; 63
    59e8:	f8 94       	cli
    59ea:	de bf       	out	0x3e, r29	; 62
    59ec:	0f be       	out	0x3f, r0	; 63
    59ee:	cd bf       	out	0x3d, r28	; 61
    59f0:	cf 91       	pop	r28
    59f2:	df 91       	pop	r29
    59f4:	08 95       	ret

000059f6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    59f6:	df 93       	push	r29
    59f8:	cf 93       	push	r28
    59fa:	cd b7       	in	r28, 0x3d	; 61
    59fc:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    59fe:	81 e0       	ldi	r24, 0x01	; 1
    5a00:	80 93 90 07 	sts	0x0790, r24
}
    5a04:	cf 91       	pop	r28
    5a06:	df 91       	pop	r29
    5a08:	08 95       	ret

00005a0a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5a0a:	df 93       	push	r29
    5a0c:	cf 93       	push	r28
    5a0e:	00 d0       	rcall	.+0      	; 0x5a10 <prvIdleTask+0x6>
    5a10:	cd b7       	in	r28, 0x3d	; 61
    5a12:	de b7       	in	r29, 0x3e	; 62
    5a14:	9a 83       	std	Y+2, r25	; 0x02
    5a16:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    5a18:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5a1c:	80 91 98 07 	lds	r24, 0x0798
    5a20:	82 30       	cpi	r24, 0x02	; 2
    5a22:	d0 f3       	brcs	.-12     	; 0x5a18 <prvIdleTask+0xe>
                {
                    taskYIELD();
    5a24:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
    5a28:	f7 cf       	rjmp	.-18     	; 0x5a18 <prvIdleTask+0xe>

00005a2a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5a2a:	df 93       	push	r29
    5a2c:	cf 93       	push	r28
    5a2e:	0f 92       	push	r0
    5a30:	cd b7       	in	r28, 0x3d	; 61
    5a32:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5a34:	19 82       	std	Y+1, r1	; 0x01
    5a36:	13 c0       	rjmp	.+38     	; 0x5a5e <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5a38:	89 81       	ldd	r24, Y+1	; 0x01
    5a3a:	28 2f       	mov	r18, r24
    5a3c:	30 e0       	ldi	r19, 0x00	; 0
    5a3e:	c9 01       	movw	r24, r18
    5a40:	88 0f       	add	r24, r24
    5a42:	99 1f       	adc	r25, r25
    5a44:	88 0f       	add	r24, r24
    5a46:	99 1f       	adc	r25, r25
    5a48:	88 0f       	add	r24, r24
    5a4a:	99 1f       	adc	r25, r25
    5a4c:	82 0f       	add	r24, r18
    5a4e:	93 1f       	adc	r25, r19
    5a50:	88 56       	subi	r24, 0x68	; 104
    5a52:	98 4f       	sbci	r25, 0xF8	; 248
    5a54:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5a58:	89 81       	ldd	r24, Y+1	; 0x01
    5a5a:	8f 5f       	subi	r24, 0xFF	; 255
    5a5c:	89 83       	std	Y+1, r24	; 0x01
    5a5e:	89 81       	ldd	r24, Y+1	; 0x01
    5a60:	8a 30       	cpi	r24, 0x0A	; 10
    5a62:	50 f3       	brcs	.-44     	; 0x5a38 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    5a64:	82 ef       	ldi	r24, 0xF2	; 242
    5a66:	97 e0       	ldi	r25, 0x07	; 7
    5a68:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    5a6c:	8b ef       	ldi	r24, 0xFB	; 251
    5a6e:	97 e0       	ldi	r25, 0x07	; 7
    5a70:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
    vListInitialise( &xPendingReadyList );
    5a74:	88 e0       	ldi	r24, 0x08	; 8
    5a76:	98 e0       	ldi	r25, 0x08	; 8
    5a78:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    5a7c:	81 e1       	ldi	r24, 0x11	; 17
    5a7e:	98 e0       	ldi	r25, 0x08	; 8
    5a80:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    5a84:	82 ef       	ldi	r24, 0xF2	; 242
    5a86:	97 e0       	ldi	r25, 0x07	; 7
    5a88:	90 93 05 08 	sts	0x0805, r25
    5a8c:	80 93 04 08 	sts	0x0804, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5a90:	8b ef       	ldi	r24, 0xFB	; 251
    5a92:	97 e0       	ldi	r25, 0x07	; 7
    5a94:	90 93 07 08 	sts	0x0807, r25
    5a98:	80 93 06 08 	sts	0x0806, r24
}
    5a9c:	0f 90       	pop	r0
    5a9e:	cf 91       	pop	r28
    5aa0:	df 91       	pop	r29
    5aa2:	08 95       	ret

00005aa4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5aa4:	df 93       	push	r29
    5aa6:	cf 93       	push	r28
    5aa8:	00 d0       	rcall	.+0      	; 0x5aaa <prvCheckTasksWaitingTermination+0x6>
    5aaa:	cd b7       	in	r28, 0x3d	; 61
    5aac:	de b7       	in	r29, 0x3e	; 62
    5aae:	20 c0       	rjmp	.+64     	; 0x5af0 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    5ab0:	0f b6       	in	r0, 0x3f	; 63
    5ab2:	f8 94       	cli
    5ab4:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5ab6:	e0 91 16 08 	lds	r30, 0x0816
    5aba:	f0 91 17 08 	lds	r31, 0x0817
    5abe:	86 81       	ldd	r24, Z+6	; 0x06
    5ac0:	97 81       	ldd	r25, Z+7	; 0x07
    5ac2:	9a 83       	std	Y+2, r25	; 0x02
    5ac4:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ac6:	89 81       	ldd	r24, Y+1	; 0x01
    5ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    5aca:	02 96       	adiw	r24, 0x02	; 2
    5acc:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    5ad0:	80 91 89 07 	lds	r24, 0x0789
    5ad4:	81 50       	subi	r24, 0x01	; 1
    5ad6:	80 93 89 07 	sts	0x0789, r24
                    --uxDeletedTasksWaitingCleanUp;
    5ada:	80 91 88 07 	lds	r24, 0x0788
    5ade:	81 50       	subi	r24, 0x01	; 1
    5ae0:	80 93 88 07 	sts	0x0788, r24
                }
                taskEXIT_CRITICAL();
    5ae4:	0f 90       	pop	r0
    5ae6:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    5ae8:	89 81       	ldd	r24, Y+1	; 0x01
    5aea:	9a 81       	ldd	r25, Y+2	; 0x02
    5aec:	0e 94 81 2d 	call	0x5b02	; 0x5b02 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5af0:	80 91 88 07 	lds	r24, 0x0788
    5af4:	88 23       	and	r24, r24
    5af6:	e1 f6       	brne	.-72     	; 0x5ab0 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    5af8:	0f 90       	pop	r0
    5afa:	0f 90       	pop	r0
    5afc:	cf 91       	pop	r28
    5afe:	df 91       	pop	r29
    5b00:	08 95       	ret

00005b02 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    5b02:	df 93       	push	r29
    5b04:	cf 93       	push	r28
    5b06:	00 d0       	rcall	.+0      	; 0x5b08 <prvDeleteTCB+0x6>
    5b08:	cd b7       	in	r28, 0x3d	; 61
    5b0a:	de b7       	in	r29, 0x3e	; 62
    5b0c:	9a 83       	std	Y+2, r25	; 0x02
    5b0e:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    5b10:	e9 81       	ldd	r30, Y+1	; 0x01
    5b12:	fa 81       	ldd	r31, Y+2	; 0x02
    5b14:	87 89       	ldd	r24, Z+23	; 0x17
    5b16:	90 8d       	ldd	r25, Z+24	; 0x18
    5b18:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
                vPortFree( pxTCB );
    5b1c:	89 81       	ldd	r24, Y+1	; 0x01
    5b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    5b20:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
    5b28:	cf 91       	pop	r28
    5b2a:	df 91       	pop	r29
    5b2c:	08 95       	ret

00005b2e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5b2e:	df 93       	push	r29
    5b30:	cf 93       	push	r28
    5b32:	cd b7       	in	r28, 0x3d	; 61
    5b34:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5b36:	e0 91 04 08 	lds	r30, 0x0804
    5b3a:	f0 91 05 08 	lds	r31, 0x0805
    5b3e:	80 81       	ld	r24, Z
    5b40:	88 23       	and	r24, r24
    5b42:	39 f4       	brne	.+14     	; 0x5b52 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    5b44:	8f ef       	ldi	r24, 0xFF	; 255
    5b46:	9f ef       	ldi	r25, 0xFF	; 255
    5b48:	90 93 94 07 	sts	0x0794, r25
    5b4c:	80 93 93 07 	sts	0x0793, r24
    5b50:	0d c0       	rjmp	.+26     	; 0x5b6c <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    5b52:	e0 91 04 08 	lds	r30, 0x0804
    5b56:	f0 91 05 08 	lds	r31, 0x0805
    5b5a:	05 80       	ldd	r0, Z+5	; 0x05
    5b5c:	f6 81       	ldd	r31, Z+6	; 0x06
    5b5e:	e0 2d       	mov	r30, r0
    5b60:	80 81       	ld	r24, Z
    5b62:	91 81       	ldd	r25, Z+1	; 0x01
    5b64:	90 93 94 07 	sts	0x0794, r25
    5b68:	80 93 93 07 	sts	0x0793, r24
    }
}
    5b6c:	cf 91       	pop	r28
    5b6e:	df 91       	pop	r29
    5b70:	08 95       	ret

00005b72 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    5b72:	df 93       	push	r29
    5b74:	cf 93       	push	r28
    5b76:	00 d0       	rcall	.+0      	; 0x5b78 <xTaskGetCurrentTaskHandle+0x6>
    5b78:	cd b7       	in	r28, 0x3d	; 61
    5b7a:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    5b7c:	80 91 86 07 	lds	r24, 0x0786
    5b80:	90 91 87 07 	lds	r25, 0x0787
    5b84:	9a 83       	std	Y+2, r25	; 0x02
    5b86:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    5b88:	89 81       	ldd	r24, Y+1	; 0x01
    5b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5b8c:	0f 90       	pop	r0
    5b8e:	0f 90       	pop	r0
    5b90:	cf 91       	pop	r28
    5b92:	df 91       	pop	r29
    5b94:	08 95       	ret

00005b96 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5b96:	df 93       	push	r29
    5b98:	cf 93       	push	r28
    5b9a:	00 d0       	rcall	.+0      	; 0x5b9c <uxTaskResetEventItemValue+0x6>
    5b9c:	cd b7       	in	r28, 0x3d	; 61
    5b9e:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5ba0:	e0 91 86 07 	lds	r30, 0x0786
    5ba4:	f0 91 87 07 	lds	r31, 0x0787
    5ba8:	84 85       	ldd	r24, Z+12	; 0x0c
    5baa:	95 85       	ldd	r25, Z+13	; 0x0d
    5bac:	9a 83       	std	Y+2, r25	; 0x02
    5bae:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5bb0:	a0 91 86 07 	lds	r26, 0x0786
    5bb4:	b0 91 87 07 	lds	r27, 0x0787
    5bb8:	e0 91 86 07 	lds	r30, 0x0786
    5bbc:	f0 91 87 07 	lds	r31, 0x0787
    5bc0:	86 89       	ldd	r24, Z+22	; 0x16
    5bc2:	28 2f       	mov	r18, r24
    5bc4:	30 e0       	ldi	r19, 0x00	; 0
    5bc6:	8a e0       	ldi	r24, 0x0A	; 10
    5bc8:	90 e0       	ldi	r25, 0x00	; 0
    5bca:	82 1b       	sub	r24, r18
    5bcc:	93 0b       	sbc	r25, r19
    5bce:	1d 96       	adiw	r26, 0x0d	; 13
    5bd0:	9c 93       	st	X, r25
    5bd2:	8e 93       	st	-X, r24
    5bd4:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    5bd6:	89 81       	ldd	r24, Y+1	; 0x01
    5bd8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5bda:	0f 90       	pop	r0
    5bdc:	0f 90       	pop	r0
    5bde:	cf 91       	pop	r28
    5be0:	df 91       	pop	r29
    5be2:	08 95       	ret

00005be4 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    5be4:	df 93       	push	r29
    5be6:	cf 93       	push	r28
    5be8:	cd b7       	in	r28, 0x3d	; 61
    5bea:	de b7       	in	r29, 0x3e	; 62
    5bec:	28 97       	sbiw	r28, 0x08	; 8
    5bee:	0f b6       	in	r0, 0x3f	; 63
    5bf0:	f8 94       	cli
    5bf2:	de bf       	out	0x3e, r29	; 62
    5bf4:	0f be       	out	0x3f, r0	; 63
    5bf6:	cd bf       	out	0x3d, r28	; 61
    5bf8:	8d 83       	std	Y+5, r24	; 0x05
    5bfa:	6e 83       	std	Y+6, r22	; 0x06
    5bfc:	58 87       	std	Y+8, r21	; 0x08
    5bfe:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5c00:	0f b6       	in	r0, 0x3f	; 63
    5c02:	f8 94       	cli
    5c04:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    5c06:	20 91 86 07 	lds	r18, 0x0786
    5c0a:	30 91 87 07 	lds	r19, 0x0787
    5c0e:	8d 81       	ldd	r24, Y+5	; 0x05
    5c10:	88 2f       	mov	r24, r24
    5c12:	90 e0       	ldi	r25, 0x00	; 0
    5c14:	88 0f       	add	r24, r24
    5c16:	99 1f       	adc	r25, r25
    5c18:	88 0f       	add	r24, r24
    5c1a:	99 1f       	adc	r25, r25
    5c1c:	82 0f       	add	r24, r18
    5c1e:	93 1f       	adc	r25, r19
    5c20:	fc 01       	movw	r30, r24
    5c22:	f7 96       	adiw	r30, 0x37	; 55
    5c24:	80 81       	ld	r24, Z
    5c26:	91 81       	ldd	r25, Z+1	; 0x01
    5c28:	a2 81       	ldd	r26, Z+2	; 0x02
    5c2a:	b3 81       	ldd	r27, Z+3	; 0x03
    5c2c:	00 97       	sbiw	r24, 0x00	; 0
    5c2e:	a1 05       	cpc	r26, r1
    5c30:	b1 05       	cpc	r27, r1
    5c32:	c1 f4       	brne	.+48     	; 0x5c64 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5c34:	20 91 86 07 	lds	r18, 0x0786
    5c38:	30 91 87 07 	lds	r19, 0x0787
    5c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    5c3e:	88 2f       	mov	r24, r24
    5c40:	90 e0       	ldi	r25, 0x00	; 0
    5c42:	82 0f       	add	r24, r18
    5c44:	93 1f       	adc	r25, r19
    5c46:	fc 01       	movw	r30, r24
    5c48:	fb 96       	adiw	r30, 0x3b	; 59
    5c4a:	81 e0       	ldi	r24, 0x01	; 1
    5c4c:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5c4e:	8f 81       	ldd	r24, Y+7	; 0x07
    5c50:	98 85       	ldd	r25, Y+8	; 0x08
    5c52:	00 97       	sbiw	r24, 0x00	; 0
    5c54:	39 f0       	breq	.+14     	; 0x5c64 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c56:	8f 81       	ldd	r24, Y+7	; 0x07
    5c58:	98 85       	ldd	r25, Y+8	; 0x08
    5c5a:	61 e0       	ldi	r22, 0x01	; 1
    5c5c:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5c60:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5c64:	0f 90       	pop	r0
    5c66:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5c68:	0f b6       	in	r0, 0x3f	; 63
    5c6a:	f8 94       	cli
    5c6c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5c6e:	20 91 86 07 	lds	r18, 0x0786
    5c72:	30 91 87 07 	lds	r19, 0x0787
    5c76:	8d 81       	ldd	r24, Y+5	; 0x05
    5c78:	88 2f       	mov	r24, r24
    5c7a:	90 e0       	ldi	r25, 0x00	; 0
    5c7c:	88 0f       	add	r24, r24
    5c7e:	99 1f       	adc	r25, r25
    5c80:	88 0f       	add	r24, r24
    5c82:	99 1f       	adc	r25, r25
    5c84:	82 0f       	add	r24, r18
    5c86:	93 1f       	adc	r25, r19
    5c88:	fc 01       	movw	r30, r24
    5c8a:	f7 96       	adiw	r30, 0x37	; 55
    5c8c:	80 81       	ld	r24, Z
    5c8e:	91 81       	ldd	r25, Z+1	; 0x01
    5c90:	a2 81       	ldd	r26, Z+2	; 0x02
    5c92:	b3 81       	ldd	r27, Z+3	; 0x03
    5c94:	89 83       	std	Y+1, r24	; 0x01
    5c96:	9a 83       	std	Y+2, r25	; 0x02
    5c98:	ab 83       	std	Y+3, r26	; 0x03
    5c9a:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    5c9c:	89 81       	ldd	r24, Y+1	; 0x01
    5c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    5ca0:	ab 81       	ldd	r26, Y+3	; 0x03
    5ca2:	bc 81       	ldd	r27, Y+4	; 0x04
    5ca4:	00 97       	sbiw	r24, 0x00	; 0
    5ca6:	a1 05       	cpc	r26, r1
    5ca8:	b1 05       	cpc	r27, r1
    5caa:	a9 f1       	breq	.+106    	; 0x5d16 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    5cac:	8e 81       	ldd	r24, Y+6	; 0x06
    5cae:	88 23       	and	r24, r24
    5cb0:	a1 f0       	breq	.+40     	; 0x5cda <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    5cb2:	20 91 86 07 	lds	r18, 0x0786
    5cb6:	30 91 87 07 	lds	r19, 0x0787
    5cba:	8d 81       	ldd	r24, Y+5	; 0x05
    5cbc:	88 2f       	mov	r24, r24
    5cbe:	90 e0       	ldi	r25, 0x00	; 0
    5cc0:	88 0f       	add	r24, r24
    5cc2:	99 1f       	adc	r25, r25
    5cc4:	88 0f       	add	r24, r24
    5cc6:	99 1f       	adc	r25, r25
    5cc8:	82 0f       	add	r24, r18
    5cca:	93 1f       	adc	r25, r19
    5ccc:	fc 01       	movw	r30, r24
    5cce:	f7 96       	adiw	r30, 0x37	; 55
    5cd0:	10 82       	st	Z, r1
    5cd2:	11 82       	std	Z+1, r1	; 0x01
    5cd4:	12 82       	std	Z+2, r1	; 0x02
    5cd6:	13 82       	std	Z+3, r1	; 0x03
    5cd8:	1e c0       	rjmp	.+60     	; 0x5d16 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5cda:	e0 91 86 07 	lds	r30, 0x0786
    5cde:	f0 91 87 07 	lds	r31, 0x0787
    5ce2:	8d 81       	ldd	r24, Y+5	; 0x05
    5ce4:	68 2f       	mov	r22, r24
    5ce6:	70 e0       	ldi	r23, 0x00	; 0
    5ce8:	89 81       	ldd	r24, Y+1	; 0x01
    5cea:	9a 81       	ldd	r25, Y+2	; 0x02
    5cec:	ab 81       	ldd	r26, Y+3	; 0x03
    5cee:	bc 81       	ldd	r27, Y+4	; 0x04
    5cf0:	9c 01       	movw	r18, r24
    5cf2:	ad 01       	movw	r20, r26
    5cf4:	21 50       	subi	r18, 0x01	; 1
    5cf6:	30 40       	sbci	r19, 0x00	; 0
    5cf8:	40 40       	sbci	r20, 0x00	; 0
    5cfa:	50 40       	sbci	r21, 0x00	; 0
    5cfc:	cb 01       	movw	r24, r22
    5cfe:	88 0f       	add	r24, r24
    5d00:	99 1f       	adc	r25, r25
    5d02:	88 0f       	add	r24, r24
    5d04:	99 1f       	adc	r25, r25
    5d06:	8e 0f       	add	r24, r30
    5d08:	9f 1f       	adc	r25, r31
    5d0a:	fc 01       	movw	r30, r24
    5d0c:	f7 96       	adiw	r30, 0x37	; 55
    5d0e:	20 83       	st	Z, r18
    5d10:	31 83       	std	Z+1, r19	; 0x01
    5d12:	42 83       	std	Z+2, r20	; 0x02
    5d14:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5d16:	20 91 86 07 	lds	r18, 0x0786
    5d1a:	30 91 87 07 	lds	r19, 0x0787
    5d1e:	8d 81       	ldd	r24, Y+5	; 0x05
    5d20:	88 2f       	mov	r24, r24
    5d22:	90 e0       	ldi	r25, 0x00	; 0
    5d24:	82 0f       	add	r24, r18
    5d26:	93 1f       	adc	r25, r19
    5d28:	fc 01       	movw	r30, r24
    5d2a:	fb 96       	adiw	r30, 0x3b	; 59
    5d2c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5d2e:	0f 90       	pop	r0
    5d30:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5d32:	89 81       	ldd	r24, Y+1	; 0x01
    5d34:	9a 81       	ldd	r25, Y+2	; 0x02
    5d36:	ab 81       	ldd	r26, Y+3	; 0x03
    5d38:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5d3a:	bc 01       	movw	r22, r24
    5d3c:	cd 01       	movw	r24, r26
    5d3e:	28 96       	adiw	r28, 0x08	; 8
    5d40:	0f b6       	in	r0, 0x3f	; 63
    5d42:	f8 94       	cli
    5d44:	de bf       	out	0x3e, r29	; 62
    5d46:	0f be       	out	0x3f, r0	; 63
    5d48:	cd bf       	out	0x3d, r28	; 61
    5d4a:	cf 91       	pop	r28
    5d4c:	df 91       	pop	r29
    5d4e:	08 95       	ret

00005d50 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5d50:	cf 92       	push	r12
    5d52:	df 92       	push	r13
    5d54:	ef 92       	push	r14
    5d56:	ff 92       	push	r15
    5d58:	0f 93       	push	r16
    5d5a:	1f 93       	push	r17
    5d5c:	df 93       	push	r29
    5d5e:	cf 93       	push	r28
    5d60:	cd b7       	in	r28, 0x3d	; 61
    5d62:	de b7       	in	r29, 0x3e	; 62
    5d64:	2e 97       	sbiw	r28, 0x0e	; 14
    5d66:	0f b6       	in	r0, 0x3f	; 63
    5d68:	f8 94       	cli
    5d6a:	de bf       	out	0x3e, r29	; 62
    5d6c:	0f be       	out	0x3f, r0	; 63
    5d6e:	cd bf       	out	0x3d, r28	; 61
    5d70:	8a 83       	std	Y+2, r24	; 0x02
    5d72:	4b 83       	std	Y+3, r20	; 0x03
    5d74:	5c 83       	std	Y+4, r21	; 0x04
    5d76:	6d 83       	std	Y+5, r22	; 0x05
    5d78:	7e 83       	std	Y+6, r23	; 0x06
    5d7a:	0f 83       	std	Y+7, r16	; 0x07
    5d7c:	18 87       	std	Y+8, r17	; 0x08
    5d7e:	29 87       	std	Y+9, r18	; 0x09
    5d80:	3a 87       	std	Y+10, r19	; 0x0a
    5d82:	fc 86       	std	Y+12, r15	; 0x0c
    5d84:	eb 86       	std	Y+11, r14	; 0x0b
    5d86:	de 86       	std	Y+14, r13	; 0x0e
    5d88:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5d8a:	0f b6       	in	r0, 0x3f	; 63
    5d8c:	f8 94       	cli
    5d8e:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5d90:	20 91 86 07 	lds	r18, 0x0786
    5d94:	30 91 87 07 	lds	r19, 0x0787
    5d98:	8a 81       	ldd	r24, Y+2	; 0x02
    5d9a:	88 2f       	mov	r24, r24
    5d9c:	90 e0       	ldi	r25, 0x00	; 0
    5d9e:	82 0f       	add	r24, r18
    5da0:	93 1f       	adc	r25, r19
    5da2:	fc 01       	movw	r30, r24
    5da4:	fb 96       	adiw	r30, 0x3b	; 59
    5da6:	80 81       	ld	r24, Z
    5da8:	82 30       	cpi	r24, 0x02	; 2
    5daa:	09 f4       	brne	.+2      	; 0x5dae <xTaskGenericNotifyWait+0x5e>
    5dac:	47 c0       	rjmp	.+142    	; 0x5e3c <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5dae:	60 91 86 07 	lds	r22, 0x0786
    5db2:	70 91 87 07 	lds	r23, 0x0787
    5db6:	8a 81       	ldd	r24, Y+2	; 0x02
    5db8:	08 2f       	mov	r16, r24
    5dba:	10 e0       	ldi	r17, 0x00	; 0
    5dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    5dbe:	88 2f       	mov	r24, r24
    5dc0:	90 e0       	ldi	r25, 0x00	; 0
    5dc2:	88 0f       	add	r24, r24
    5dc4:	99 1f       	adc	r25, r25
    5dc6:	88 0f       	add	r24, r24
    5dc8:	99 1f       	adc	r25, r25
    5dca:	86 0f       	add	r24, r22
    5dcc:	97 1f       	adc	r25, r23
    5dce:	fc 01       	movw	r30, r24
    5dd0:	f7 96       	adiw	r30, 0x37	; 55
    5dd2:	20 81       	ld	r18, Z
    5dd4:	31 81       	ldd	r19, Z+1	; 0x01
    5dd6:	42 81       	ldd	r20, Z+2	; 0x02
    5dd8:	53 81       	ldd	r21, Z+3	; 0x03
    5dda:	8b 81       	ldd	r24, Y+3	; 0x03
    5ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    5dde:	ad 81       	ldd	r26, Y+5	; 0x05
    5de0:	be 81       	ldd	r27, Y+6	; 0x06
    5de2:	80 95       	com	r24
    5de4:	90 95       	com	r25
    5de6:	a0 95       	com	r26
    5de8:	b0 95       	com	r27
    5dea:	28 23       	and	r18, r24
    5dec:	39 23       	and	r19, r25
    5dee:	4a 23       	and	r20, r26
    5df0:	5b 23       	and	r21, r27
    5df2:	c8 01       	movw	r24, r16
    5df4:	88 0f       	add	r24, r24
    5df6:	99 1f       	adc	r25, r25
    5df8:	88 0f       	add	r24, r24
    5dfa:	99 1f       	adc	r25, r25
    5dfc:	86 0f       	add	r24, r22
    5dfe:	97 1f       	adc	r25, r23
    5e00:	fc 01       	movw	r30, r24
    5e02:	f7 96       	adiw	r30, 0x37	; 55
    5e04:	20 83       	st	Z, r18
    5e06:	31 83       	std	Z+1, r19	; 0x01
    5e08:	42 83       	std	Z+2, r20	; 0x02
    5e0a:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5e0c:	20 91 86 07 	lds	r18, 0x0786
    5e10:	30 91 87 07 	lds	r19, 0x0787
    5e14:	8a 81       	ldd	r24, Y+2	; 0x02
    5e16:	88 2f       	mov	r24, r24
    5e18:	90 e0       	ldi	r25, 0x00	; 0
    5e1a:	82 0f       	add	r24, r18
    5e1c:	93 1f       	adc	r25, r19
    5e1e:	fc 01       	movw	r30, r24
    5e20:	fb 96       	adiw	r30, 0x3b	; 59
    5e22:	81 e0       	ldi	r24, 0x01	; 1
    5e24:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5e26:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e28:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e2a:	00 97       	sbiw	r24, 0x00	; 0
    5e2c:	39 f0       	breq	.+14     	; 0x5e3c <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5e2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e30:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e32:	61 e0       	ldi	r22, 0x01	; 1
    5e34:	0e 94 77 35 	call	0x6aee	; 0x6aee <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5e38:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5e3c:	0f 90       	pop	r0
    5e3e:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5e40:	0f b6       	in	r0, 0x3f	; 63
    5e42:	f8 94       	cli
    5e44:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    5e46:	8b 85       	ldd	r24, Y+11	; 0x0b
    5e48:	9c 85       	ldd	r25, Y+12	; 0x0c
    5e4a:	00 97       	sbiw	r24, 0x00	; 0
    5e4c:	c9 f0       	breq	.+50     	; 0x5e80 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5e4e:	20 91 86 07 	lds	r18, 0x0786
    5e52:	30 91 87 07 	lds	r19, 0x0787
    5e56:	8a 81       	ldd	r24, Y+2	; 0x02
    5e58:	88 2f       	mov	r24, r24
    5e5a:	90 e0       	ldi	r25, 0x00	; 0
    5e5c:	88 0f       	add	r24, r24
    5e5e:	99 1f       	adc	r25, r25
    5e60:	88 0f       	add	r24, r24
    5e62:	99 1f       	adc	r25, r25
    5e64:	82 0f       	add	r24, r18
    5e66:	93 1f       	adc	r25, r19
    5e68:	fc 01       	movw	r30, r24
    5e6a:	f7 96       	adiw	r30, 0x37	; 55
    5e6c:	80 81       	ld	r24, Z
    5e6e:	91 81       	ldd	r25, Z+1	; 0x01
    5e70:	a2 81       	ldd	r26, Z+2	; 0x02
    5e72:	b3 81       	ldd	r27, Z+3	; 0x03
    5e74:	eb 85       	ldd	r30, Y+11	; 0x0b
    5e76:	fc 85       	ldd	r31, Y+12	; 0x0c
    5e78:	80 83       	st	Z, r24
    5e7a:	91 83       	std	Z+1, r25	; 0x01
    5e7c:	a2 83       	std	Z+2, r26	; 0x02
    5e7e:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5e80:	20 91 86 07 	lds	r18, 0x0786
    5e84:	30 91 87 07 	lds	r19, 0x0787
    5e88:	8a 81       	ldd	r24, Y+2	; 0x02
    5e8a:	88 2f       	mov	r24, r24
    5e8c:	90 e0       	ldi	r25, 0x00	; 0
    5e8e:	82 0f       	add	r24, r18
    5e90:	93 1f       	adc	r25, r19
    5e92:	fc 01       	movw	r30, r24
    5e94:	fb 96       	adiw	r30, 0x3b	; 59
    5e96:	80 81       	ld	r24, Z
    5e98:	82 30       	cpi	r24, 0x02	; 2
    5e9a:	11 f0       	breq	.+4      	; 0x5ea0 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5e9c:	19 82       	std	Y+1, r1	; 0x01
    5e9e:	31 c0       	rjmp	.+98     	; 0x5f02 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5ea0:	60 91 86 07 	lds	r22, 0x0786
    5ea4:	70 91 87 07 	lds	r23, 0x0787
    5ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eaa:	08 2f       	mov	r16, r24
    5eac:	10 e0       	ldi	r17, 0x00	; 0
    5eae:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb0:	88 2f       	mov	r24, r24
    5eb2:	90 e0       	ldi	r25, 0x00	; 0
    5eb4:	88 0f       	add	r24, r24
    5eb6:	99 1f       	adc	r25, r25
    5eb8:	88 0f       	add	r24, r24
    5eba:	99 1f       	adc	r25, r25
    5ebc:	86 0f       	add	r24, r22
    5ebe:	97 1f       	adc	r25, r23
    5ec0:	fc 01       	movw	r30, r24
    5ec2:	f7 96       	adiw	r30, 0x37	; 55
    5ec4:	20 81       	ld	r18, Z
    5ec6:	31 81       	ldd	r19, Z+1	; 0x01
    5ec8:	42 81       	ldd	r20, Z+2	; 0x02
    5eca:	53 81       	ldd	r21, Z+3	; 0x03
    5ecc:	8f 81       	ldd	r24, Y+7	; 0x07
    5ece:	98 85       	ldd	r25, Y+8	; 0x08
    5ed0:	a9 85       	ldd	r26, Y+9	; 0x09
    5ed2:	ba 85       	ldd	r27, Y+10	; 0x0a
    5ed4:	80 95       	com	r24
    5ed6:	90 95       	com	r25
    5ed8:	a0 95       	com	r26
    5eda:	b0 95       	com	r27
    5edc:	28 23       	and	r18, r24
    5ede:	39 23       	and	r19, r25
    5ee0:	4a 23       	and	r20, r26
    5ee2:	5b 23       	and	r21, r27
    5ee4:	c8 01       	movw	r24, r16
    5ee6:	88 0f       	add	r24, r24
    5ee8:	99 1f       	adc	r25, r25
    5eea:	88 0f       	add	r24, r24
    5eec:	99 1f       	adc	r25, r25
    5eee:	86 0f       	add	r24, r22
    5ef0:	97 1f       	adc	r25, r23
    5ef2:	fc 01       	movw	r30, r24
    5ef4:	f7 96       	adiw	r30, 0x37	; 55
    5ef6:	20 83       	st	Z, r18
    5ef8:	31 83       	std	Z+1, r19	; 0x01
    5efa:	42 83       	std	Z+2, r20	; 0x02
    5efc:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    5efe:	81 e0       	ldi	r24, 0x01	; 1
    5f00:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5f02:	20 91 86 07 	lds	r18, 0x0786
    5f06:	30 91 87 07 	lds	r19, 0x0787
    5f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f0c:	88 2f       	mov	r24, r24
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	82 0f       	add	r24, r18
    5f12:	93 1f       	adc	r25, r19
    5f14:	fc 01       	movw	r30, r24
    5f16:	fb 96       	adiw	r30, 0x3b	; 59
    5f18:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5f1a:	0f 90       	pop	r0
    5f1c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5f1e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5f20:	2e 96       	adiw	r28, 0x0e	; 14
    5f22:	0f b6       	in	r0, 0x3f	; 63
    5f24:	f8 94       	cli
    5f26:	de bf       	out	0x3e, r29	; 62
    5f28:	0f be       	out	0x3f, r0	; 63
    5f2a:	cd bf       	out	0x3d, r28	; 61
    5f2c:	cf 91       	pop	r28
    5f2e:	df 91       	pop	r29
    5f30:	1f 91       	pop	r17
    5f32:	0f 91       	pop	r16
    5f34:	ff 90       	pop	r15
    5f36:	ef 90       	pop	r14
    5f38:	df 90       	pop	r13
    5f3a:	cf 90       	pop	r12
    5f3c:	08 95       	ret

00005f3e <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5f3e:	ef 92       	push	r14
    5f40:	ff 92       	push	r15
    5f42:	0f 93       	push	r16
    5f44:	1f 93       	push	r17
    5f46:	df 93       	push	r29
    5f48:	cf 93       	push	r28
    5f4a:	cd b7       	in	r28, 0x3d	; 61
    5f4c:	de b7       	in	r29, 0x3e	; 62
    5f4e:	64 97       	sbiw	r28, 0x14	; 20
    5f50:	0f b6       	in	r0, 0x3f	; 63
    5f52:	f8 94       	cli
    5f54:	de bf       	out	0x3e, r29	; 62
    5f56:	0f be       	out	0x3f, r0	; 63
    5f58:	cd bf       	out	0x3d, r28	; 61
    5f5a:	9a 87       	std	Y+10, r25	; 0x0a
    5f5c:	89 87       	std	Y+9, r24	; 0x09
    5f5e:	6b 87       	std	Y+11, r22	; 0x0b
    5f60:	2c 87       	std	Y+12, r18	; 0x0c
    5f62:	3d 87       	std	Y+13, r19	; 0x0d
    5f64:	4e 87       	std	Y+14, r20	; 0x0e
    5f66:	5f 87       	std	Y+15, r21	; 0x0f
    5f68:	08 8b       	std	Y+16, r16	; 0x10
    5f6a:	fa 8a       	std	Y+18, r15	; 0x12
    5f6c:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5f6e:	81 e0       	ldi	r24, 0x01	; 1
    5f70:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    5f72:	89 85       	ldd	r24, Y+9	; 0x09
    5f74:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f76:	98 87       	std	Y+8, r25	; 0x08
    5f78:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    5f7a:	0f b6       	in	r0, 0x3f	; 63
    5f7c:	f8 94       	cli
    5f7e:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5f80:	89 89       	ldd	r24, Y+17	; 0x11
    5f82:	9a 89       	ldd	r25, Y+18	; 0x12
    5f84:	00 97       	sbiw	r24, 0x00	; 0
    5f86:	b9 f0       	breq	.+46     	; 0x5fb6 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5f88:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f8a:	88 2f       	mov	r24, r24
    5f8c:	90 e0       	ldi	r25, 0x00	; 0
    5f8e:	2f 81       	ldd	r18, Y+7	; 0x07
    5f90:	38 85       	ldd	r19, Y+8	; 0x08
    5f92:	88 0f       	add	r24, r24
    5f94:	99 1f       	adc	r25, r25
    5f96:	88 0f       	add	r24, r24
    5f98:	99 1f       	adc	r25, r25
    5f9a:	82 0f       	add	r24, r18
    5f9c:	93 1f       	adc	r25, r19
    5f9e:	fc 01       	movw	r30, r24
    5fa0:	f7 96       	adiw	r30, 0x37	; 55
    5fa2:	80 81       	ld	r24, Z
    5fa4:	91 81       	ldd	r25, Z+1	; 0x01
    5fa6:	a2 81       	ldd	r26, Z+2	; 0x02
    5fa8:	b3 81       	ldd	r27, Z+3	; 0x03
    5faa:	e9 89       	ldd	r30, Y+17	; 0x11
    5fac:	fa 89       	ldd	r31, Y+18	; 0x12
    5fae:	80 83       	st	Z, r24
    5fb0:	91 83       	std	Z+1, r25	; 0x01
    5fb2:	a2 83       	std	Z+2, r26	; 0x02
    5fb4:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5fb6:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fb8:	28 2f       	mov	r18, r24
    5fba:	30 e0       	ldi	r19, 0x00	; 0
    5fbc:	8f 81       	ldd	r24, Y+7	; 0x07
    5fbe:	98 85       	ldd	r25, Y+8	; 0x08
    5fc0:	82 0f       	add	r24, r18
    5fc2:	93 1f       	adc	r25, r19
    5fc4:	fc 01       	movw	r30, r24
    5fc6:	fb 96       	adiw	r30, 0x3b	; 59
    5fc8:	80 81       	ld	r24, Z
    5fca:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5fcc:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fce:	28 2f       	mov	r18, r24
    5fd0:	30 e0       	ldi	r19, 0x00	; 0
    5fd2:	8f 81       	ldd	r24, Y+7	; 0x07
    5fd4:	98 85       	ldd	r25, Y+8	; 0x08
    5fd6:	82 0f       	add	r24, r18
    5fd8:	93 1f       	adc	r25, r19
    5fda:	fc 01       	movw	r30, r24
    5fdc:	fb 96       	adiw	r30, 0x3b	; 59
    5fde:	82 e0       	ldi	r24, 0x02	; 2
    5fe0:	80 83       	st	Z, r24

            switch( eAction )
    5fe2:	88 89       	ldd	r24, Y+16	; 0x10
    5fe4:	28 2f       	mov	r18, r24
    5fe6:	30 e0       	ldi	r19, 0x00	; 0
    5fe8:	3c 8b       	std	Y+20, r19	; 0x14
    5fea:	2b 8b       	std	Y+19, r18	; 0x13
    5fec:	8b 89       	ldd	r24, Y+19	; 0x13
    5fee:	9c 89       	ldd	r25, Y+20	; 0x14
    5ff0:	82 30       	cpi	r24, 0x02	; 2
    5ff2:	91 05       	cpc	r25, r1
    5ff4:	09 f4       	brne	.+2      	; 0x5ff8 <xTaskGenericNotify+0xba>
    5ff6:	46 c0       	rjmp	.+140    	; 0x6084 <xTaskGenericNotify+0x146>
    5ff8:	2b 89       	ldd	r18, Y+19	; 0x13
    5ffa:	3c 89       	ldd	r19, Y+20	; 0x14
    5ffc:	23 30       	cpi	r18, 0x03	; 3
    5ffe:	31 05       	cpc	r19, r1
    6000:	34 f4       	brge	.+12     	; 0x600e <xTaskGenericNotify+0xd0>
    6002:	8b 89       	ldd	r24, Y+19	; 0x13
    6004:	9c 89       	ldd	r25, Y+20	; 0x14
    6006:	81 30       	cpi	r24, 0x01	; 1
    6008:	91 05       	cpc	r25, r1
    600a:	71 f0       	breq	.+28     	; 0x6028 <xTaskGenericNotify+0xea>
    600c:	93 c0       	rjmp	.+294    	; 0x6134 <xTaskGenericNotify+0x1f6>
    600e:	2b 89       	ldd	r18, Y+19	; 0x13
    6010:	3c 89       	ldd	r19, Y+20	; 0x14
    6012:	23 30       	cpi	r18, 0x03	; 3
    6014:	31 05       	cpc	r19, r1
    6016:	09 f4       	brne	.+2      	; 0x601a <xTaskGenericNotify+0xdc>
    6018:	5d c0       	rjmp	.+186    	; 0x60d4 <xTaskGenericNotify+0x196>
    601a:	8b 89       	ldd	r24, Y+19	; 0x13
    601c:	9c 89       	ldd	r25, Y+20	; 0x14
    601e:	84 30       	cpi	r24, 0x04	; 4
    6020:	91 05       	cpc	r25, r1
    6022:	09 f4       	brne	.+2      	; 0x6026 <xTaskGenericNotify+0xe8>
    6024:	6d c0       	rjmp	.+218    	; 0x6100 <xTaskGenericNotify+0x1c2>
    6026:	86 c0       	rjmp	.+268    	; 0x6134 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    6028:	8b 85       	ldd	r24, Y+11	; 0x0b
    602a:	08 2f       	mov	r16, r24
    602c:	10 e0       	ldi	r17, 0x00	; 0
    602e:	8b 85       	ldd	r24, Y+11	; 0x0b
    6030:	88 2f       	mov	r24, r24
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	2f 81       	ldd	r18, Y+7	; 0x07
    6036:	38 85       	ldd	r19, Y+8	; 0x08
    6038:	88 0f       	add	r24, r24
    603a:	99 1f       	adc	r25, r25
    603c:	88 0f       	add	r24, r24
    603e:	99 1f       	adc	r25, r25
    6040:	82 0f       	add	r24, r18
    6042:	93 1f       	adc	r25, r19
    6044:	fc 01       	movw	r30, r24
    6046:	f7 96       	adiw	r30, 0x37	; 55
    6048:	20 81       	ld	r18, Z
    604a:	31 81       	ldd	r19, Z+1	; 0x01
    604c:	42 81       	ldd	r20, Z+2	; 0x02
    604e:	53 81       	ldd	r21, Z+3	; 0x03
    6050:	8c 85       	ldd	r24, Y+12	; 0x0c
    6052:	9d 85       	ldd	r25, Y+13	; 0x0d
    6054:	ae 85       	ldd	r26, Y+14	; 0x0e
    6056:	bf 85       	ldd	r27, Y+15	; 0x0f
    6058:	ba 01       	movw	r22, r20
    605a:	a9 01       	movw	r20, r18
    605c:	48 2b       	or	r20, r24
    605e:	59 2b       	or	r21, r25
    6060:	6a 2b       	or	r22, r26
    6062:	7b 2b       	or	r23, r27
    6064:	2f 81       	ldd	r18, Y+7	; 0x07
    6066:	38 85       	ldd	r19, Y+8	; 0x08
    6068:	c8 01       	movw	r24, r16
    606a:	88 0f       	add	r24, r24
    606c:	99 1f       	adc	r25, r25
    606e:	88 0f       	add	r24, r24
    6070:	99 1f       	adc	r25, r25
    6072:	82 0f       	add	r24, r18
    6074:	93 1f       	adc	r25, r19
    6076:	fc 01       	movw	r30, r24
    6078:	f7 96       	adiw	r30, 0x37	; 55
    607a:	40 83       	st	Z, r20
    607c:	51 83       	std	Z+1, r21	; 0x01
    607e:	62 83       	std	Z+2, r22	; 0x02
    6080:	73 83       	std	Z+3, r23	; 0x03
    6082:	58 c0       	rjmp	.+176    	; 0x6134 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6084:	8b 85       	ldd	r24, Y+11	; 0x0b
    6086:	08 2f       	mov	r16, r24
    6088:	10 e0       	ldi	r17, 0x00	; 0
    608a:	2f 81       	ldd	r18, Y+7	; 0x07
    608c:	38 85       	ldd	r19, Y+8	; 0x08
    608e:	c8 01       	movw	r24, r16
    6090:	88 0f       	add	r24, r24
    6092:	99 1f       	adc	r25, r25
    6094:	88 0f       	add	r24, r24
    6096:	99 1f       	adc	r25, r25
    6098:	82 0f       	add	r24, r18
    609a:	93 1f       	adc	r25, r19
    609c:	fc 01       	movw	r30, r24
    609e:	f7 96       	adiw	r30, 0x37	; 55
    60a0:	80 81       	ld	r24, Z
    60a2:	91 81       	ldd	r25, Z+1	; 0x01
    60a4:	a2 81       	ldd	r26, Z+2	; 0x02
    60a6:	b3 81       	ldd	r27, Z+3	; 0x03
    60a8:	ac 01       	movw	r20, r24
    60aa:	bd 01       	movw	r22, r26
    60ac:	4f 5f       	subi	r20, 0xFF	; 255
    60ae:	5f 4f       	sbci	r21, 0xFF	; 255
    60b0:	6f 4f       	sbci	r22, 0xFF	; 255
    60b2:	7f 4f       	sbci	r23, 0xFF	; 255
    60b4:	2f 81       	ldd	r18, Y+7	; 0x07
    60b6:	38 85       	ldd	r19, Y+8	; 0x08
    60b8:	c8 01       	movw	r24, r16
    60ba:	88 0f       	add	r24, r24
    60bc:	99 1f       	adc	r25, r25
    60be:	88 0f       	add	r24, r24
    60c0:	99 1f       	adc	r25, r25
    60c2:	82 0f       	add	r24, r18
    60c4:	93 1f       	adc	r25, r19
    60c6:	fc 01       	movw	r30, r24
    60c8:	f7 96       	adiw	r30, 0x37	; 55
    60ca:	40 83       	st	Z, r20
    60cc:	51 83       	std	Z+1, r21	; 0x01
    60ce:	62 83       	std	Z+2, r22	; 0x02
    60d0:	73 83       	std	Z+3, r23	; 0x03
    60d2:	30 c0       	rjmp	.+96     	; 0x6134 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    60d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    60d6:	88 2f       	mov	r24, r24
    60d8:	90 e0       	ldi	r25, 0x00	; 0
    60da:	2f 81       	ldd	r18, Y+7	; 0x07
    60dc:	38 85       	ldd	r19, Y+8	; 0x08
    60de:	88 0f       	add	r24, r24
    60e0:	99 1f       	adc	r25, r25
    60e2:	88 0f       	add	r24, r24
    60e4:	99 1f       	adc	r25, r25
    60e6:	82 0f       	add	r24, r18
    60e8:	93 1f       	adc	r25, r19
    60ea:	fc 01       	movw	r30, r24
    60ec:	f7 96       	adiw	r30, 0x37	; 55
    60ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    60f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    60f2:	ae 85       	ldd	r26, Y+14	; 0x0e
    60f4:	bf 85       	ldd	r27, Y+15	; 0x0f
    60f6:	80 83       	st	Z, r24
    60f8:	91 83       	std	Z+1, r25	; 0x01
    60fa:	a2 83       	std	Z+2, r26	; 0x02
    60fc:	b3 83       	std	Z+3, r27	; 0x03
    60fe:	1a c0       	rjmp	.+52     	; 0x6134 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6100:	8d 81       	ldd	r24, Y+5	; 0x05
    6102:	82 30       	cpi	r24, 0x02	; 2
    6104:	b1 f0       	breq	.+44     	; 0x6132 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6106:	8b 85       	ldd	r24, Y+11	; 0x0b
    6108:	88 2f       	mov	r24, r24
    610a:	90 e0       	ldi	r25, 0x00	; 0
    610c:	2f 81       	ldd	r18, Y+7	; 0x07
    610e:	38 85       	ldd	r19, Y+8	; 0x08
    6110:	88 0f       	add	r24, r24
    6112:	99 1f       	adc	r25, r25
    6114:	88 0f       	add	r24, r24
    6116:	99 1f       	adc	r25, r25
    6118:	82 0f       	add	r24, r18
    611a:	93 1f       	adc	r25, r19
    611c:	fc 01       	movw	r30, r24
    611e:	f7 96       	adiw	r30, 0x37	; 55
    6120:	8c 85       	ldd	r24, Y+12	; 0x0c
    6122:	9d 85       	ldd	r25, Y+13	; 0x0d
    6124:	ae 85       	ldd	r26, Y+14	; 0x0e
    6126:	bf 85       	ldd	r27, Y+15	; 0x0f
    6128:	80 83       	st	Z, r24
    612a:	91 83       	std	Z+1, r25	; 0x01
    612c:	a2 83       	std	Z+2, r26	; 0x02
    612e:	b3 83       	std	Z+3, r27	; 0x03
    6130:	01 c0       	rjmp	.+2      	; 0x6134 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    6132:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6134:	8d 81       	ldd	r24, Y+5	; 0x05
    6136:	81 30       	cpi	r24, 0x01	; 1
    6138:	09 f0       	breq	.+2      	; 0x613c <xTaskGenericNotify+0x1fe>
    613a:	af c0       	rjmp	.+350    	; 0x629a <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    613c:	ef 81       	ldd	r30, Y+7	; 0x07
    613e:	f8 85       	ldd	r31, Y+8	; 0x08
    6140:	82 85       	ldd	r24, Z+10	; 0x0a
    6142:	93 85       	ldd	r25, Z+11	; 0x0b
    6144:	9c 83       	std	Y+4, r25	; 0x04
    6146:	8b 83       	std	Y+3, r24	; 0x03
    6148:	ef 81       	ldd	r30, Y+7	; 0x07
    614a:	f8 85       	ldd	r31, Y+8	; 0x08
    614c:	a4 81       	ldd	r26, Z+4	; 0x04
    614e:	b5 81       	ldd	r27, Z+5	; 0x05
    6150:	ef 81       	ldd	r30, Y+7	; 0x07
    6152:	f8 85       	ldd	r31, Y+8	; 0x08
    6154:	86 81       	ldd	r24, Z+6	; 0x06
    6156:	97 81       	ldd	r25, Z+7	; 0x07
    6158:	15 96       	adiw	r26, 0x05	; 5
    615a:	9c 93       	st	X, r25
    615c:	8e 93       	st	-X, r24
    615e:	14 97       	sbiw	r26, 0x04	; 4
    6160:	ef 81       	ldd	r30, Y+7	; 0x07
    6162:	f8 85       	ldd	r31, Y+8	; 0x08
    6164:	a6 81       	ldd	r26, Z+6	; 0x06
    6166:	b7 81       	ldd	r27, Z+7	; 0x07
    6168:	ef 81       	ldd	r30, Y+7	; 0x07
    616a:	f8 85       	ldd	r31, Y+8	; 0x08
    616c:	84 81       	ldd	r24, Z+4	; 0x04
    616e:	95 81       	ldd	r25, Z+5	; 0x05
    6170:	13 96       	adiw	r26, 0x03	; 3
    6172:	9c 93       	st	X, r25
    6174:	8e 93       	st	-X, r24
    6176:	12 97       	sbiw	r26, 0x02	; 2
    6178:	eb 81       	ldd	r30, Y+3	; 0x03
    617a:	fc 81       	ldd	r31, Y+4	; 0x04
    617c:	21 81       	ldd	r18, Z+1	; 0x01
    617e:	32 81       	ldd	r19, Z+2	; 0x02
    6180:	8f 81       	ldd	r24, Y+7	; 0x07
    6182:	98 85       	ldd	r25, Y+8	; 0x08
    6184:	02 96       	adiw	r24, 0x02	; 2
    6186:	28 17       	cp	r18, r24
    6188:	39 07       	cpc	r19, r25
    618a:	41 f4       	brne	.+16     	; 0x619c <xTaskGenericNotify+0x25e>
    618c:	ef 81       	ldd	r30, Y+7	; 0x07
    618e:	f8 85       	ldd	r31, Y+8	; 0x08
    6190:	86 81       	ldd	r24, Z+6	; 0x06
    6192:	97 81       	ldd	r25, Z+7	; 0x07
    6194:	eb 81       	ldd	r30, Y+3	; 0x03
    6196:	fc 81       	ldd	r31, Y+4	; 0x04
    6198:	92 83       	std	Z+2, r25	; 0x02
    619a:	81 83       	std	Z+1, r24	; 0x01
    619c:	ef 81       	ldd	r30, Y+7	; 0x07
    619e:	f8 85       	ldd	r31, Y+8	; 0x08
    61a0:	13 86       	std	Z+11, r1	; 0x0b
    61a2:	12 86       	std	Z+10, r1	; 0x0a
    61a4:	eb 81       	ldd	r30, Y+3	; 0x03
    61a6:	fc 81       	ldd	r31, Y+4	; 0x04
    61a8:	80 81       	ld	r24, Z
    61aa:	81 50       	subi	r24, 0x01	; 1
    61ac:	eb 81       	ldd	r30, Y+3	; 0x03
    61ae:	fc 81       	ldd	r31, Y+4	; 0x04
    61b0:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    61b2:	ef 81       	ldd	r30, Y+7	; 0x07
    61b4:	f8 85       	ldd	r31, Y+8	; 0x08
    61b6:	96 89       	ldd	r25, Z+22	; 0x16
    61b8:	80 91 8c 07 	lds	r24, 0x078C
    61bc:	89 17       	cp	r24, r25
    61be:	28 f4       	brcc	.+10     	; 0x61ca <xTaskGenericNotify+0x28c>
    61c0:	ef 81       	ldd	r30, Y+7	; 0x07
    61c2:	f8 85       	ldd	r31, Y+8	; 0x08
    61c4:	86 89       	ldd	r24, Z+22	; 0x16
    61c6:	80 93 8c 07 	sts	0x078C, r24
    61ca:	ef 81       	ldd	r30, Y+7	; 0x07
    61cc:	f8 85       	ldd	r31, Y+8	; 0x08
    61ce:	86 89       	ldd	r24, Z+22	; 0x16
    61d0:	28 2f       	mov	r18, r24
    61d2:	30 e0       	ldi	r19, 0x00	; 0
    61d4:	c9 01       	movw	r24, r18
    61d6:	88 0f       	add	r24, r24
    61d8:	99 1f       	adc	r25, r25
    61da:	88 0f       	add	r24, r24
    61dc:	99 1f       	adc	r25, r25
    61de:	88 0f       	add	r24, r24
    61e0:	99 1f       	adc	r25, r25
    61e2:	82 0f       	add	r24, r18
    61e4:	93 1f       	adc	r25, r19
    61e6:	fc 01       	movw	r30, r24
    61e8:	e8 56       	subi	r30, 0x68	; 104
    61ea:	f8 4f       	sbci	r31, 0xF8	; 248
    61ec:	81 81       	ldd	r24, Z+1	; 0x01
    61ee:	92 81       	ldd	r25, Z+2	; 0x02
    61f0:	9a 83       	std	Y+2, r25	; 0x02
    61f2:	89 83       	std	Y+1, r24	; 0x01
    61f4:	ef 81       	ldd	r30, Y+7	; 0x07
    61f6:	f8 85       	ldd	r31, Y+8	; 0x08
    61f8:	89 81       	ldd	r24, Y+1	; 0x01
    61fa:	9a 81       	ldd	r25, Y+2	; 0x02
    61fc:	95 83       	std	Z+5, r25	; 0x05
    61fe:	84 83       	std	Z+4, r24	; 0x04
    6200:	e9 81       	ldd	r30, Y+1	; 0x01
    6202:	fa 81       	ldd	r31, Y+2	; 0x02
    6204:	84 81       	ldd	r24, Z+4	; 0x04
    6206:	95 81       	ldd	r25, Z+5	; 0x05
    6208:	ef 81       	ldd	r30, Y+7	; 0x07
    620a:	f8 85       	ldd	r31, Y+8	; 0x08
    620c:	97 83       	std	Z+7, r25	; 0x07
    620e:	86 83       	std	Z+6, r24	; 0x06
    6210:	e9 81       	ldd	r30, Y+1	; 0x01
    6212:	fa 81       	ldd	r31, Y+2	; 0x02
    6214:	04 80       	ldd	r0, Z+4	; 0x04
    6216:	f5 81       	ldd	r31, Z+5	; 0x05
    6218:	e0 2d       	mov	r30, r0
    621a:	8f 81       	ldd	r24, Y+7	; 0x07
    621c:	98 85       	ldd	r25, Y+8	; 0x08
    621e:	02 96       	adiw	r24, 0x02	; 2
    6220:	93 83       	std	Z+3, r25	; 0x03
    6222:	82 83       	std	Z+2, r24	; 0x02
    6224:	8f 81       	ldd	r24, Y+7	; 0x07
    6226:	98 85       	ldd	r25, Y+8	; 0x08
    6228:	02 96       	adiw	r24, 0x02	; 2
    622a:	e9 81       	ldd	r30, Y+1	; 0x01
    622c:	fa 81       	ldd	r31, Y+2	; 0x02
    622e:	95 83       	std	Z+5, r25	; 0x05
    6230:	84 83       	std	Z+4, r24	; 0x04
    6232:	ef 81       	ldd	r30, Y+7	; 0x07
    6234:	f8 85       	ldd	r31, Y+8	; 0x08
    6236:	86 89       	ldd	r24, Z+22	; 0x16
    6238:	28 2f       	mov	r18, r24
    623a:	30 e0       	ldi	r19, 0x00	; 0
    623c:	c9 01       	movw	r24, r18
    623e:	88 0f       	add	r24, r24
    6240:	99 1f       	adc	r25, r25
    6242:	88 0f       	add	r24, r24
    6244:	99 1f       	adc	r25, r25
    6246:	88 0f       	add	r24, r24
    6248:	99 1f       	adc	r25, r25
    624a:	82 0f       	add	r24, r18
    624c:	93 1f       	adc	r25, r19
    624e:	88 56       	subi	r24, 0x68	; 104
    6250:	98 4f       	sbci	r25, 0xF8	; 248
    6252:	ef 81       	ldd	r30, Y+7	; 0x07
    6254:	f8 85       	ldd	r31, Y+8	; 0x08
    6256:	93 87       	std	Z+11, r25	; 0x0b
    6258:	82 87       	std	Z+10, r24	; 0x0a
    625a:	ef 81       	ldd	r30, Y+7	; 0x07
    625c:	f8 85       	ldd	r31, Y+8	; 0x08
    625e:	86 89       	ldd	r24, Z+22	; 0x16
    6260:	28 2f       	mov	r18, r24
    6262:	30 e0       	ldi	r19, 0x00	; 0
    6264:	c9 01       	movw	r24, r18
    6266:	88 0f       	add	r24, r24
    6268:	99 1f       	adc	r25, r25
    626a:	88 0f       	add	r24, r24
    626c:	99 1f       	adc	r25, r25
    626e:	88 0f       	add	r24, r24
    6270:	99 1f       	adc	r25, r25
    6272:	82 0f       	add	r24, r18
    6274:	93 1f       	adc	r25, r19
    6276:	fc 01       	movw	r30, r24
    6278:	e8 56       	subi	r30, 0x68	; 104
    627a:	f8 4f       	sbci	r31, 0xF8	; 248
    627c:	80 81       	ld	r24, Z
    627e:	8f 5f       	subi	r24, 0xFF	; 255
    6280:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6282:	ef 81       	ldd	r30, Y+7	; 0x07
    6284:	f8 85       	ldd	r31, Y+8	; 0x08
    6286:	96 89       	ldd	r25, Z+22	; 0x16
    6288:	e0 91 86 07 	lds	r30, 0x0786
    628c:	f0 91 87 07 	lds	r31, 0x0787
    6290:	86 89       	ldd	r24, Z+22	; 0x16
    6292:	89 17       	cp	r24, r25
    6294:	10 f4       	brcc	.+4      	; 0x629a <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    6296:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    629a:	0f 90       	pop	r0
    629c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    629e:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    62a0:	64 96       	adiw	r28, 0x14	; 20
    62a2:	0f b6       	in	r0, 0x3f	; 63
    62a4:	f8 94       	cli
    62a6:	de bf       	out	0x3e, r29	; 62
    62a8:	0f be       	out	0x3f, r0	; 63
    62aa:	cd bf       	out	0x3d, r28	; 61
    62ac:	cf 91       	pop	r28
    62ae:	df 91       	pop	r29
    62b0:	1f 91       	pop	r17
    62b2:	0f 91       	pop	r16
    62b4:	ff 90       	pop	r15
    62b6:	ef 90       	pop	r14
    62b8:	08 95       	ret

000062ba <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    62ba:	cf 92       	push	r12
    62bc:	df 92       	push	r13
    62be:	ef 92       	push	r14
    62c0:	ff 92       	push	r15
    62c2:	0f 93       	push	r16
    62c4:	1f 93       	push	r17
    62c6:	df 93       	push	r29
    62c8:	cf 93       	push	r28
    62ca:	cd b7       	in	r28, 0x3d	; 61
    62cc:	de b7       	in	r29, 0x3e	; 62
    62ce:	69 97       	sbiw	r28, 0x19	; 25
    62d0:	0f b6       	in	r0, 0x3f	; 63
    62d2:	f8 94       	cli
    62d4:	de bf       	out	0x3e, r29	; 62
    62d6:	0f be       	out	0x3f, r0	; 63
    62d8:	cd bf       	out	0x3d, r28	; 61
    62da:	9d 87       	std	Y+13, r25	; 0x0d
    62dc:	8c 87       	std	Y+12, r24	; 0x0c
    62de:	6e 87       	std	Y+14, r22	; 0x0e
    62e0:	2f 87       	std	Y+15, r18	; 0x0f
    62e2:	38 8b       	std	Y+16, r19	; 0x10
    62e4:	49 8b       	std	Y+17, r20	; 0x11
    62e6:	5a 8b       	std	Y+18, r21	; 0x12
    62e8:	0b 8b       	std	Y+19, r16	; 0x13
    62ea:	fd 8a       	std	Y+21, r15	; 0x15
    62ec:	ec 8a       	std	Y+20, r14	; 0x14
    62ee:	df 8a       	std	Y+23, r13	; 0x17
    62f0:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    62f2:	81 e0       	ldi	r24, 0x01	; 1
    62f4:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    62f6:	8c 85       	ldd	r24, Y+12	; 0x0c
    62f8:	9d 85       	ldd	r25, Y+13	; 0x0d
    62fa:	9b 87       	std	Y+11, r25	; 0x0b
    62fc:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    62fe:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    6300:	8c 89       	ldd	r24, Y+20	; 0x14
    6302:	9d 89       	ldd	r25, Y+21	; 0x15
    6304:	00 97       	sbiw	r24, 0x00	; 0
    6306:	b9 f0       	breq	.+46     	; 0x6336 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    6308:	8e 85       	ldd	r24, Y+14	; 0x0e
    630a:	88 2f       	mov	r24, r24
    630c:	90 e0       	ldi	r25, 0x00	; 0
    630e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6310:	3b 85       	ldd	r19, Y+11	; 0x0b
    6312:	88 0f       	add	r24, r24
    6314:	99 1f       	adc	r25, r25
    6316:	88 0f       	add	r24, r24
    6318:	99 1f       	adc	r25, r25
    631a:	82 0f       	add	r24, r18
    631c:	93 1f       	adc	r25, r19
    631e:	fc 01       	movw	r30, r24
    6320:	f7 96       	adiw	r30, 0x37	; 55
    6322:	80 81       	ld	r24, Z
    6324:	91 81       	ldd	r25, Z+1	; 0x01
    6326:	a2 81       	ldd	r26, Z+2	; 0x02
    6328:	b3 81       	ldd	r27, Z+3	; 0x03
    632a:	ec 89       	ldd	r30, Y+20	; 0x14
    632c:	fd 89       	ldd	r31, Y+21	; 0x15
    632e:	80 83       	st	Z, r24
    6330:	91 83       	std	Z+1, r25	; 0x01
    6332:	a2 83       	std	Z+2, r26	; 0x02
    6334:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    6336:	8e 85       	ldd	r24, Y+14	; 0x0e
    6338:	28 2f       	mov	r18, r24
    633a:	30 e0       	ldi	r19, 0x00	; 0
    633c:	8a 85       	ldd	r24, Y+10	; 0x0a
    633e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6340:	82 0f       	add	r24, r18
    6342:	93 1f       	adc	r25, r19
    6344:	fc 01       	movw	r30, r24
    6346:	fb 96       	adiw	r30, 0x3b	; 59
    6348:	80 81       	ld	r24, Z
    634a:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    634c:	8e 85       	ldd	r24, Y+14	; 0x0e
    634e:	28 2f       	mov	r18, r24
    6350:	30 e0       	ldi	r19, 0x00	; 0
    6352:	8a 85       	ldd	r24, Y+10	; 0x0a
    6354:	9b 85       	ldd	r25, Y+11	; 0x0b
    6356:	82 0f       	add	r24, r18
    6358:	93 1f       	adc	r25, r19
    635a:	fc 01       	movw	r30, r24
    635c:	fb 96       	adiw	r30, 0x3b	; 59
    635e:	82 e0       	ldi	r24, 0x02	; 2
    6360:	80 83       	st	Z, r24

            switch( eAction )
    6362:	8b 89       	ldd	r24, Y+19	; 0x13
    6364:	28 2f       	mov	r18, r24
    6366:	30 e0       	ldi	r19, 0x00	; 0
    6368:	39 8f       	std	Y+25, r19	; 0x19
    636a:	28 8f       	std	Y+24, r18	; 0x18
    636c:	88 8d       	ldd	r24, Y+24	; 0x18
    636e:	99 8d       	ldd	r25, Y+25	; 0x19
    6370:	82 30       	cpi	r24, 0x02	; 2
    6372:	91 05       	cpc	r25, r1
    6374:	09 f4       	brne	.+2      	; 0x6378 <xTaskGenericNotifyFromISR+0xbe>
    6376:	46 c0       	rjmp	.+140    	; 0x6404 <xTaskGenericNotifyFromISR+0x14a>
    6378:	28 8d       	ldd	r18, Y+24	; 0x18
    637a:	39 8d       	ldd	r19, Y+25	; 0x19
    637c:	23 30       	cpi	r18, 0x03	; 3
    637e:	31 05       	cpc	r19, r1
    6380:	34 f4       	brge	.+12     	; 0x638e <xTaskGenericNotifyFromISR+0xd4>
    6382:	88 8d       	ldd	r24, Y+24	; 0x18
    6384:	99 8d       	ldd	r25, Y+25	; 0x19
    6386:	81 30       	cpi	r24, 0x01	; 1
    6388:	91 05       	cpc	r25, r1
    638a:	71 f0       	breq	.+28     	; 0x63a8 <xTaskGenericNotifyFromISR+0xee>
    638c:	93 c0       	rjmp	.+294    	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
    638e:	28 8d       	ldd	r18, Y+24	; 0x18
    6390:	39 8d       	ldd	r19, Y+25	; 0x19
    6392:	23 30       	cpi	r18, 0x03	; 3
    6394:	31 05       	cpc	r19, r1
    6396:	09 f4       	brne	.+2      	; 0x639a <xTaskGenericNotifyFromISR+0xe0>
    6398:	5d c0       	rjmp	.+186    	; 0x6454 <xTaskGenericNotifyFromISR+0x19a>
    639a:	88 8d       	ldd	r24, Y+24	; 0x18
    639c:	99 8d       	ldd	r25, Y+25	; 0x19
    639e:	84 30       	cpi	r24, 0x04	; 4
    63a0:	91 05       	cpc	r25, r1
    63a2:	09 f4       	brne	.+2      	; 0x63a6 <xTaskGenericNotifyFromISR+0xec>
    63a4:	6d c0       	rjmp	.+218    	; 0x6480 <xTaskGenericNotifyFromISR+0x1c6>
    63a6:	86 c0       	rjmp	.+268    	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    63a8:	8e 85       	ldd	r24, Y+14	; 0x0e
    63aa:	08 2f       	mov	r16, r24
    63ac:	10 e0       	ldi	r17, 0x00	; 0
    63ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    63b0:	88 2f       	mov	r24, r24
    63b2:	90 e0       	ldi	r25, 0x00	; 0
    63b4:	2a 85       	ldd	r18, Y+10	; 0x0a
    63b6:	3b 85       	ldd	r19, Y+11	; 0x0b
    63b8:	88 0f       	add	r24, r24
    63ba:	99 1f       	adc	r25, r25
    63bc:	88 0f       	add	r24, r24
    63be:	99 1f       	adc	r25, r25
    63c0:	82 0f       	add	r24, r18
    63c2:	93 1f       	adc	r25, r19
    63c4:	fc 01       	movw	r30, r24
    63c6:	f7 96       	adiw	r30, 0x37	; 55
    63c8:	20 81       	ld	r18, Z
    63ca:	31 81       	ldd	r19, Z+1	; 0x01
    63cc:	42 81       	ldd	r20, Z+2	; 0x02
    63ce:	53 81       	ldd	r21, Z+3	; 0x03
    63d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    63d2:	98 89       	ldd	r25, Y+16	; 0x10
    63d4:	a9 89       	ldd	r26, Y+17	; 0x11
    63d6:	ba 89       	ldd	r27, Y+18	; 0x12
    63d8:	ba 01       	movw	r22, r20
    63da:	a9 01       	movw	r20, r18
    63dc:	48 2b       	or	r20, r24
    63de:	59 2b       	or	r21, r25
    63e0:	6a 2b       	or	r22, r26
    63e2:	7b 2b       	or	r23, r27
    63e4:	2a 85       	ldd	r18, Y+10	; 0x0a
    63e6:	3b 85       	ldd	r19, Y+11	; 0x0b
    63e8:	c8 01       	movw	r24, r16
    63ea:	88 0f       	add	r24, r24
    63ec:	99 1f       	adc	r25, r25
    63ee:	88 0f       	add	r24, r24
    63f0:	99 1f       	adc	r25, r25
    63f2:	82 0f       	add	r24, r18
    63f4:	93 1f       	adc	r25, r19
    63f6:	fc 01       	movw	r30, r24
    63f8:	f7 96       	adiw	r30, 0x37	; 55
    63fa:	40 83       	st	Z, r20
    63fc:	51 83       	std	Z+1, r21	; 0x01
    63fe:	62 83       	std	Z+2, r22	; 0x02
    6400:	73 83       	std	Z+3, r23	; 0x03
    6402:	58 c0       	rjmp	.+176    	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6404:	8e 85       	ldd	r24, Y+14	; 0x0e
    6406:	08 2f       	mov	r16, r24
    6408:	10 e0       	ldi	r17, 0x00	; 0
    640a:	2a 85       	ldd	r18, Y+10	; 0x0a
    640c:	3b 85       	ldd	r19, Y+11	; 0x0b
    640e:	c8 01       	movw	r24, r16
    6410:	88 0f       	add	r24, r24
    6412:	99 1f       	adc	r25, r25
    6414:	88 0f       	add	r24, r24
    6416:	99 1f       	adc	r25, r25
    6418:	82 0f       	add	r24, r18
    641a:	93 1f       	adc	r25, r19
    641c:	fc 01       	movw	r30, r24
    641e:	f7 96       	adiw	r30, 0x37	; 55
    6420:	80 81       	ld	r24, Z
    6422:	91 81       	ldd	r25, Z+1	; 0x01
    6424:	a2 81       	ldd	r26, Z+2	; 0x02
    6426:	b3 81       	ldd	r27, Z+3	; 0x03
    6428:	ac 01       	movw	r20, r24
    642a:	bd 01       	movw	r22, r26
    642c:	4f 5f       	subi	r20, 0xFF	; 255
    642e:	5f 4f       	sbci	r21, 0xFF	; 255
    6430:	6f 4f       	sbci	r22, 0xFF	; 255
    6432:	7f 4f       	sbci	r23, 0xFF	; 255
    6434:	2a 85       	ldd	r18, Y+10	; 0x0a
    6436:	3b 85       	ldd	r19, Y+11	; 0x0b
    6438:	c8 01       	movw	r24, r16
    643a:	88 0f       	add	r24, r24
    643c:	99 1f       	adc	r25, r25
    643e:	88 0f       	add	r24, r24
    6440:	99 1f       	adc	r25, r25
    6442:	82 0f       	add	r24, r18
    6444:	93 1f       	adc	r25, r19
    6446:	fc 01       	movw	r30, r24
    6448:	f7 96       	adiw	r30, 0x37	; 55
    644a:	40 83       	st	Z, r20
    644c:	51 83       	std	Z+1, r21	; 0x01
    644e:	62 83       	std	Z+2, r22	; 0x02
    6450:	73 83       	std	Z+3, r23	; 0x03
    6452:	30 c0       	rjmp	.+96     	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6454:	8e 85       	ldd	r24, Y+14	; 0x0e
    6456:	88 2f       	mov	r24, r24
    6458:	90 e0       	ldi	r25, 0x00	; 0
    645a:	2a 85       	ldd	r18, Y+10	; 0x0a
    645c:	3b 85       	ldd	r19, Y+11	; 0x0b
    645e:	88 0f       	add	r24, r24
    6460:	99 1f       	adc	r25, r25
    6462:	88 0f       	add	r24, r24
    6464:	99 1f       	adc	r25, r25
    6466:	82 0f       	add	r24, r18
    6468:	93 1f       	adc	r25, r19
    646a:	fc 01       	movw	r30, r24
    646c:	f7 96       	adiw	r30, 0x37	; 55
    646e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6470:	98 89       	ldd	r25, Y+16	; 0x10
    6472:	a9 89       	ldd	r26, Y+17	; 0x11
    6474:	ba 89       	ldd	r27, Y+18	; 0x12
    6476:	80 83       	st	Z, r24
    6478:	91 83       	std	Z+1, r25	; 0x01
    647a:	a2 83       	std	Z+2, r26	; 0x02
    647c:	b3 83       	std	Z+3, r27	; 0x03
    647e:	1a c0       	rjmp	.+52     	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6480:	89 85       	ldd	r24, Y+9	; 0x09
    6482:	82 30       	cpi	r24, 0x02	; 2
    6484:	b1 f0       	breq	.+44     	; 0x64b2 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6486:	8e 85       	ldd	r24, Y+14	; 0x0e
    6488:	88 2f       	mov	r24, r24
    648a:	90 e0       	ldi	r25, 0x00	; 0
    648c:	2a 85       	ldd	r18, Y+10	; 0x0a
    648e:	3b 85       	ldd	r19, Y+11	; 0x0b
    6490:	88 0f       	add	r24, r24
    6492:	99 1f       	adc	r25, r25
    6494:	88 0f       	add	r24, r24
    6496:	99 1f       	adc	r25, r25
    6498:	82 0f       	add	r24, r18
    649a:	93 1f       	adc	r25, r19
    649c:	fc 01       	movw	r30, r24
    649e:	f7 96       	adiw	r30, 0x37	; 55
    64a0:	8f 85       	ldd	r24, Y+15	; 0x0f
    64a2:	98 89       	ldd	r25, Y+16	; 0x10
    64a4:	a9 89       	ldd	r26, Y+17	; 0x11
    64a6:	ba 89       	ldd	r27, Y+18	; 0x12
    64a8:	80 83       	st	Z, r24
    64aa:	91 83       	std	Z+1, r25	; 0x01
    64ac:	a2 83       	std	Z+2, r26	; 0x02
    64ae:	b3 83       	std	Z+3, r27	; 0x03
    64b0:	01 c0       	rjmp	.+2      	; 0x64b4 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    64b2:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    64b4:	89 85       	ldd	r24, Y+9	; 0x09
    64b6:	81 30       	cpi	r24, 0x01	; 1
    64b8:	09 f0       	breq	.+2      	; 0x64bc <xTaskGenericNotifyFromISR+0x202>
    64ba:	ee c0       	rjmp	.+476    	; 0x6698 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    64bc:	80 91 97 07 	lds	r24, 0x0797
    64c0:	88 23       	and	r24, r24
    64c2:	09 f0       	breq	.+2      	; 0x64c6 <xTaskGenericNotifyFromISR+0x20c>
    64c4:	a4 c0       	rjmp	.+328    	; 0x660e <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    64c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    64c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    64ca:	82 85       	ldd	r24, Z+10	; 0x0a
    64cc:	93 85       	ldd	r25, Z+11	; 0x0b
    64ce:	9e 83       	std	Y+6, r25	; 0x06
    64d0:	8d 83       	std	Y+5, r24	; 0x05
    64d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    64d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    64d6:	a4 81       	ldd	r26, Z+4	; 0x04
    64d8:	b5 81       	ldd	r27, Z+5	; 0x05
    64da:	ea 85       	ldd	r30, Y+10	; 0x0a
    64dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    64de:	86 81       	ldd	r24, Z+6	; 0x06
    64e0:	97 81       	ldd	r25, Z+7	; 0x07
    64e2:	15 96       	adiw	r26, 0x05	; 5
    64e4:	9c 93       	st	X, r25
    64e6:	8e 93       	st	-X, r24
    64e8:	14 97       	sbiw	r26, 0x04	; 4
    64ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    64ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    64ee:	a6 81       	ldd	r26, Z+6	; 0x06
    64f0:	b7 81       	ldd	r27, Z+7	; 0x07
    64f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    64f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    64f6:	84 81       	ldd	r24, Z+4	; 0x04
    64f8:	95 81       	ldd	r25, Z+5	; 0x05
    64fa:	13 96       	adiw	r26, 0x03	; 3
    64fc:	9c 93       	st	X, r25
    64fe:	8e 93       	st	-X, r24
    6500:	12 97       	sbiw	r26, 0x02	; 2
    6502:	ed 81       	ldd	r30, Y+5	; 0x05
    6504:	fe 81       	ldd	r31, Y+6	; 0x06
    6506:	21 81       	ldd	r18, Z+1	; 0x01
    6508:	32 81       	ldd	r19, Z+2	; 0x02
    650a:	8a 85       	ldd	r24, Y+10	; 0x0a
    650c:	9b 85       	ldd	r25, Y+11	; 0x0b
    650e:	02 96       	adiw	r24, 0x02	; 2
    6510:	28 17       	cp	r18, r24
    6512:	39 07       	cpc	r19, r25
    6514:	41 f4       	brne	.+16     	; 0x6526 <xTaskGenericNotifyFromISR+0x26c>
    6516:	ea 85       	ldd	r30, Y+10	; 0x0a
    6518:	fb 85       	ldd	r31, Y+11	; 0x0b
    651a:	86 81       	ldd	r24, Z+6	; 0x06
    651c:	97 81       	ldd	r25, Z+7	; 0x07
    651e:	ed 81       	ldd	r30, Y+5	; 0x05
    6520:	fe 81       	ldd	r31, Y+6	; 0x06
    6522:	92 83       	std	Z+2, r25	; 0x02
    6524:	81 83       	std	Z+1, r24	; 0x01
    6526:	ea 85       	ldd	r30, Y+10	; 0x0a
    6528:	fb 85       	ldd	r31, Y+11	; 0x0b
    652a:	13 86       	std	Z+11, r1	; 0x0b
    652c:	12 86       	std	Z+10, r1	; 0x0a
    652e:	ed 81       	ldd	r30, Y+5	; 0x05
    6530:	fe 81       	ldd	r31, Y+6	; 0x06
    6532:	80 81       	ld	r24, Z
    6534:	81 50       	subi	r24, 0x01	; 1
    6536:	ed 81       	ldd	r30, Y+5	; 0x05
    6538:	fe 81       	ldd	r31, Y+6	; 0x06
    653a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    653c:	ea 85       	ldd	r30, Y+10	; 0x0a
    653e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6540:	96 89       	ldd	r25, Z+22	; 0x16
    6542:	80 91 8c 07 	lds	r24, 0x078C
    6546:	89 17       	cp	r24, r25
    6548:	28 f4       	brcc	.+10     	; 0x6554 <xTaskGenericNotifyFromISR+0x29a>
    654a:	ea 85       	ldd	r30, Y+10	; 0x0a
    654c:	fb 85       	ldd	r31, Y+11	; 0x0b
    654e:	86 89       	ldd	r24, Z+22	; 0x16
    6550:	80 93 8c 07 	sts	0x078C, r24
    6554:	ea 85       	ldd	r30, Y+10	; 0x0a
    6556:	fb 85       	ldd	r31, Y+11	; 0x0b
    6558:	86 89       	ldd	r24, Z+22	; 0x16
    655a:	28 2f       	mov	r18, r24
    655c:	30 e0       	ldi	r19, 0x00	; 0
    655e:	c9 01       	movw	r24, r18
    6560:	88 0f       	add	r24, r24
    6562:	99 1f       	adc	r25, r25
    6564:	88 0f       	add	r24, r24
    6566:	99 1f       	adc	r25, r25
    6568:	88 0f       	add	r24, r24
    656a:	99 1f       	adc	r25, r25
    656c:	82 0f       	add	r24, r18
    656e:	93 1f       	adc	r25, r19
    6570:	fc 01       	movw	r30, r24
    6572:	e8 56       	subi	r30, 0x68	; 104
    6574:	f8 4f       	sbci	r31, 0xF8	; 248
    6576:	81 81       	ldd	r24, Z+1	; 0x01
    6578:	92 81       	ldd	r25, Z+2	; 0x02
    657a:	9c 83       	std	Y+4, r25	; 0x04
    657c:	8b 83       	std	Y+3, r24	; 0x03
    657e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6580:	fb 85       	ldd	r31, Y+11	; 0x0b
    6582:	8b 81       	ldd	r24, Y+3	; 0x03
    6584:	9c 81       	ldd	r25, Y+4	; 0x04
    6586:	95 83       	std	Z+5, r25	; 0x05
    6588:	84 83       	std	Z+4, r24	; 0x04
    658a:	eb 81       	ldd	r30, Y+3	; 0x03
    658c:	fc 81       	ldd	r31, Y+4	; 0x04
    658e:	84 81       	ldd	r24, Z+4	; 0x04
    6590:	95 81       	ldd	r25, Z+5	; 0x05
    6592:	ea 85       	ldd	r30, Y+10	; 0x0a
    6594:	fb 85       	ldd	r31, Y+11	; 0x0b
    6596:	97 83       	std	Z+7, r25	; 0x07
    6598:	86 83       	std	Z+6, r24	; 0x06
    659a:	eb 81       	ldd	r30, Y+3	; 0x03
    659c:	fc 81       	ldd	r31, Y+4	; 0x04
    659e:	04 80       	ldd	r0, Z+4	; 0x04
    65a0:	f5 81       	ldd	r31, Z+5	; 0x05
    65a2:	e0 2d       	mov	r30, r0
    65a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    65a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    65a8:	02 96       	adiw	r24, 0x02	; 2
    65aa:	93 83       	std	Z+3, r25	; 0x03
    65ac:	82 83       	std	Z+2, r24	; 0x02
    65ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    65b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    65b2:	02 96       	adiw	r24, 0x02	; 2
    65b4:	eb 81       	ldd	r30, Y+3	; 0x03
    65b6:	fc 81       	ldd	r31, Y+4	; 0x04
    65b8:	95 83       	std	Z+5, r25	; 0x05
    65ba:	84 83       	std	Z+4, r24	; 0x04
    65bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    65be:	fb 85       	ldd	r31, Y+11	; 0x0b
    65c0:	86 89       	ldd	r24, Z+22	; 0x16
    65c2:	28 2f       	mov	r18, r24
    65c4:	30 e0       	ldi	r19, 0x00	; 0
    65c6:	c9 01       	movw	r24, r18
    65c8:	88 0f       	add	r24, r24
    65ca:	99 1f       	adc	r25, r25
    65cc:	88 0f       	add	r24, r24
    65ce:	99 1f       	adc	r25, r25
    65d0:	88 0f       	add	r24, r24
    65d2:	99 1f       	adc	r25, r25
    65d4:	82 0f       	add	r24, r18
    65d6:	93 1f       	adc	r25, r19
    65d8:	88 56       	subi	r24, 0x68	; 104
    65da:	98 4f       	sbci	r25, 0xF8	; 248
    65dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    65de:	fb 85       	ldd	r31, Y+11	; 0x0b
    65e0:	93 87       	std	Z+11, r25	; 0x0b
    65e2:	82 87       	std	Z+10, r24	; 0x0a
    65e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    65e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    65e8:	86 89       	ldd	r24, Z+22	; 0x16
    65ea:	28 2f       	mov	r18, r24
    65ec:	30 e0       	ldi	r19, 0x00	; 0
    65ee:	c9 01       	movw	r24, r18
    65f0:	88 0f       	add	r24, r24
    65f2:	99 1f       	adc	r25, r25
    65f4:	88 0f       	add	r24, r24
    65f6:	99 1f       	adc	r25, r25
    65f8:	88 0f       	add	r24, r24
    65fa:	99 1f       	adc	r25, r25
    65fc:	82 0f       	add	r24, r18
    65fe:	93 1f       	adc	r25, r19
    6600:	fc 01       	movw	r30, r24
    6602:	e8 56       	subi	r30, 0x68	; 104
    6604:	f8 4f       	sbci	r31, 0xF8	; 248
    6606:	80 81       	ld	r24, Z
    6608:	8f 5f       	subi	r24, 0xFF	; 255
    660a:	80 83       	st	Z, r24
    660c:	30 c0       	rjmp	.+96     	; 0x666e <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    660e:	80 91 09 08 	lds	r24, 0x0809
    6612:	90 91 0a 08 	lds	r25, 0x080A
    6616:	9a 83       	std	Y+2, r25	; 0x02
    6618:	89 83       	std	Y+1, r24	; 0x01
    661a:	ea 85       	ldd	r30, Y+10	; 0x0a
    661c:	fb 85       	ldd	r31, Y+11	; 0x0b
    661e:	89 81       	ldd	r24, Y+1	; 0x01
    6620:	9a 81       	ldd	r25, Y+2	; 0x02
    6622:	97 87       	std	Z+15, r25	; 0x0f
    6624:	86 87       	std	Z+14, r24	; 0x0e
    6626:	e9 81       	ldd	r30, Y+1	; 0x01
    6628:	fa 81       	ldd	r31, Y+2	; 0x02
    662a:	84 81       	ldd	r24, Z+4	; 0x04
    662c:	95 81       	ldd	r25, Z+5	; 0x05
    662e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6630:	fb 85       	ldd	r31, Y+11	; 0x0b
    6632:	91 8b       	std	Z+17, r25	; 0x11
    6634:	80 8b       	std	Z+16, r24	; 0x10
    6636:	e9 81       	ldd	r30, Y+1	; 0x01
    6638:	fa 81       	ldd	r31, Y+2	; 0x02
    663a:	04 80       	ldd	r0, Z+4	; 0x04
    663c:	f5 81       	ldd	r31, Z+5	; 0x05
    663e:	e0 2d       	mov	r30, r0
    6640:	8a 85       	ldd	r24, Y+10	; 0x0a
    6642:	9b 85       	ldd	r25, Y+11	; 0x0b
    6644:	0c 96       	adiw	r24, 0x0c	; 12
    6646:	93 83       	std	Z+3, r25	; 0x03
    6648:	82 83       	std	Z+2, r24	; 0x02
    664a:	8a 85       	ldd	r24, Y+10	; 0x0a
    664c:	9b 85       	ldd	r25, Y+11	; 0x0b
    664e:	0c 96       	adiw	r24, 0x0c	; 12
    6650:	e9 81       	ldd	r30, Y+1	; 0x01
    6652:	fa 81       	ldd	r31, Y+2	; 0x02
    6654:	95 83       	std	Z+5, r25	; 0x05
    6656:	84 83       	std	Z+4, r24	; 0x04
    6658:	ea 85       	ldd	r30, Y+10	; 0x0a
    665a:	fb 85       	ldd	r31, Y+11	; 0x0b
    665c:	88 e0       	ldi	r24, 0x08	; 8
    665e:	98 e0       	ldi	r25, 0x08	; 8
    6660:	95 8b       	std	Z+21, r25	; 0x15
    6662:	84 8b       	std	Z+20, r24	; 0x14
    6664:	80 91 08 08 	lds	r24, 0x0808
    6668:	8f 5f       	subi	r24, 0xFF	; 255
    666a:	80 93 08 08 	sts	0x0808, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    666e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6670:	fb 85       	ldd	r31, Y+11	; 0x0b
    6672:	96 89       	ldd	r25, Z+22	; 0x16
    6674:	e0 91 86 07 	lds	r30, 0x0786
    6678:	f0 91 87 07 	lds	r31, 0x0787
    667c:	86 89       	ldd	r24, Z+22	; 0x16
    667e:	89 17       	cp	r24, r25
    6680:	58 f4       	brcc	.+22     	; 0x6698 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    6682:	8e 89       	ldd	r24, Y+22	; 0x16
    6684:	9f 89       	ldd	r25, Y+23	; 0x17
    6686:	00 97       	sbiw	r24, 0x00	; 0
    6688:	21 f0       	breq	.+8      	; 0x6692 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    668a:	ee 89       	ldd	r30, Y+22	; 0x16
    668c:	ff 89       	ldd	r31, Y+23	; 0x17
    668e:	81 e0       	ldi	r24, 0x01	; 1
    6690:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    6692:	81 e0       	ldi	r24, 0x01	; 1
    6694:	80 93 90 07 	sts	0x0790, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    6698:	88 85       	ldd	r24, Y+8	; 0x08
    }
    669a:	69 96       	adiw	r28, 0x19	; 25
    669c:	0f b6       	in	r0, 0x3f	; 63
    669e:	f8 94       	cli
    66a0:	de bf       	out	0x3e, r29	; 62
    66a2:	0f be       	out	0x3f, r0	; 63
    66a4:	cd bf       	out	0x3d, r28	; 61
    66a6:	cf 91       	pop	r28
    66a8:	df 91       	pop	r29
    66aa:	1f 91       	pop	r17
    66ac:	0f 91       	pop	r16
    66ae:	ff 90       	pop	r15
    66b0:	ef 90       	pop	r14
    66b2:	df 90       	pop	r13
    66b4:	cf 90       	pop	r12
    66b6:	08 95       	ret

000066b8 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    66b8:	0f 93       	push	r16
    66ba:	1f 93       	push	r17
    66bc:	df 93       	push	r29
    66be:	cf 93       	push	r28
    66c0:	cd b7       	in	r28, 0x3d	; 61
    66c2:	de b7       	in	r29, 0x3e	; 62
    66c4:	2f 97       	sbiw	r28, 0x0f	; 15
    66c6:	0f b6       	in	r0, 0x3f	; 63
    66c8:	f8 94       	cli
    66ca:	de bf       	out	0x3e, r29	; 62
    66cc:	0f be       	out	0x3f, r0	; 63
    66ce:	cd bf       	out	0x3d, r28	; 61
    66d0:	9c 87       	std	Y+12, r25	; 0x0c
    66d2:	8b 87       	std	Y+11, r24	; 0x0b
    66d4:	6d 87       	std	Y+13, r22	; 0x0d
    66d6:	5f 87       	std	Y+15, r21	; 0x0f
    66d8:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    66da:	8b 85       	ldd	r24, Y+11	; 0x0b
    66dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    66de:	9a 87       	std	Y+10, r25	; 0x0a
    66e0:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    66e2:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    66e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    66e6:	28 2f       	mov	r18, r24
    66e8:	30 e0       	ldi	r19, 0x00	; 0
    66ea:	89 85       	ldd	r24, Y+9	; 0x09
    66ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    66ee:	82 0f       	add	r24, r18
    66f0:	93 1f       	adc	r25, r19
    66f2:	fc 01       	movw	r30, r24
    66f4:	fb 96       	adiw	r30, 0x3b	; 59
    66f6:	80 81       	ld	r24, Z
    66f8:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    66fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    66fc:	28 2f       	mov	r18, r24
    66fe:	30 e0       	ldi	r19, 0x00	; 0
    6700:	89 85       	ldd	r24, Y+9	; 0x09
    6702:	9a 85       	ldd	r25, Y+10	; 0x0a
    6704:	82 0f       	add	r24, r18
    6706:	93 1f       	adc	r25, r19
    6708:	fc 01       	movw	r30, r24
    670a:	fb 96       	adiw	r30, 0x3b	; 59
    670c:	82 e0       	ldi	r24, 0x02	; 2
    670e:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6710:	8d 85       	ldd	r24, Y+13	; 0x0d
    6712:	08 2f       	mov	r16, r24
    6714:	10 e0       	ldi	r17, 0x00	; 0
    6716:	29 85       	ldd	r18, Y+9	; 0x09
    6718:	3a 85       	ldd	r19, Y+10	; 0x0a
    671a:	c8 01       	movw	r24, r16
    671c:	88 0f       	add	r24, r24
    671e:	99 1f       	adc	r25, r25
    6720:	88 0f       	add	r24, r24
    6722:	99 1f       	adc	r25, r25
    6724:	82 0f       	add	r24, r18
    6726:	93 1f       	adc	r25, r19
    6728:	fc 01       	movw	r30, r24
    672a:	f7 96       	adiw	r30, 0x37	; 55
    672c:	80 81       	ld	r24, Z
    672e:	91 81       	ldd	r25, Z+1	; 0x01
    6730:	a2 81       	ldd	r26, Z+2	; 0x02
    6732:	b3 81       	ldd	r27, Z+3	; 0x03
    6734:	ac 01       	movw	r20, r24
    6736:	bd 01       	movw	r22, r26
    6738:	4f 5f       	subi	r20, 0xFF	; 255
    673a:	5f 4f       	sbci	r21, 0xFF	; 255
    673c:	6f 4f       	sbci	r22, 0xFF	; 255
    673e:	7f 4f       	sbci	r23, 0xFF	; 255
    6740:	29 85       	ldd	r18, Y+9	; 0x09
    6742:	3a 85       	ldd	r19, Y+10	; 0x0a
    6744:	c8 01       	movw	r24, r16
    6746:	88 0f       	add	r24, r24
    6748:	99 1f       	adc	r25, r25
    674a:	88 0f       	add	r24, r24
    674c:	99 1f       	adc	r25, r25
    674e:	82 0f       	add	r24, r18
    6750:	93 1f       	adc	r25, r19
    6752:	fc 01       	movw	r30, r24
    6754:	f7 96       	adiw	r30, 0x37	; 55
    6756:	40 83       	st	Z, r20
    6758:	51 83       	std	Z+1, r21	; 0x01
    675a:	62 83       	std	Z+2, r22	; 0x02
    675c:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    675e:	88 85       	ldd	r24, Y+8	; 0x08
    6760:	81 30       	cpi	r24, 0x01	; 1
    6762:	09 f0       	breq	.+2      	; 0x6766 <vTaskGenericNotifyGiveFromISR+0xae>
    6764:	ee c0       	rjmp	.+476    	; 0x6942 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6766:	80 91 97 07 	lds	r24, 0x0797
    676a:	88 23       	and	r24, r24
    676c:	09 f0       	breq	.+2      	; 0x6770 <vTaskGenericNotifyGiveFromISR+0xb8>
    676e:	a4 c0       	rjmp	.+328    	; 0x68b8 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6770:	e9 85       	ldd	r30, Y+9	; 0x09
    6772:	fa 85       	ldd	r31, Y+10	; 0x0a
    6774:	82 85       	ldd	r24, Z+10	; 0x0a
    6776:	93 85       	ldd	r25, Z+11	; 0x0b
    6778:	9e 83       	std	Y+6, r25	; 0x06
    677a:	8d 83       	std	Y+5, r24	; 0x05
    677c:	e9 85       	ldd	r30, Y+9	; 0x09
    677e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6780:	a4 81       	ldd	r26, Z+4	; 0x04
    6782:	b5 81       	ldd	r27, Z+5	; 0x05
    6784:	e9 85       	ldd	r30, Y+9	; 0x09
    6786:	fa 85       	ldd	r31, Y+10	; 0x0a
    6788:	86 81       	ldd	r24, Z+6	; 0x06
    678a:	97 81       	ldd	r25, Z+7	; 0x07
    678c:	15 96       	adiw	r26, 0x05	; 5
    678e:	9c 93       	st	X, r25
    6790:	8e 93       	st	-X, r24
    6792:	14 97       	sbiw	r26, 0x04	; 4
    6794:	e9 85       	ldd	r30, Y+9	; 0x09
    6796:	fa 85       	ldd	r31, Y+10	; 0x0a
    6798:	a6 81       	ldd	r26, Z+6	; 0x06
    679a:	b7 81       	ldd	r27, Z+7	; 0x07
    679c:	e9 85       	ldd	r30, Y+9	; 0x09
    679e:	fa 85       	ldd	r31, Y+10	; 0x0a
    67a0:	84 81       	ldd	r24, Z+4	; 0x04
    67a2:	95 81       	ldd	r25, Z+5	; 0x05
    67a4:	13 96       	adiw	r26, 0x03	; 3
    67a6:	9c 93       	st	X, r25
    67a8:	8e 93       	st	-X, r24
    67aa:	12 97       	sbiw	r26, 0x02	; 2
    67ac:	ed 81       	ldd	r30, Y+5	; 0x05
    67ae:	fe 81       	ldd	r31, Y+6	; 0x06
    67b0:	21 81       	ldd	r18, Z+1	; 0x01
    67b2:	32 81       	ldd	r19, Z+2	; 0x02
    67b4:	89 85       	ldd	r24, Y+9	; 0x09
    67b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    67b8:	02 96       	adiw	r24, 0x02	; 2
    67ba:	28 17       	cp	r18, r24
    67bc:	39 07       	cpc	r19, r25
    67be:	41 f4       	brne	.+16     	; 0x67d0 <vTaskGenericNotifyGiveFromISR+0x118>
    67c0:	e9 85       	ldd	r30, Y+9	; 0x09
    67c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    67c4:	86 81       	ldd	r24, Z+6	; 0x06
    67c6:	97 81       	ldd	r25, Z+7	; 0x07
    67c8:	ed 81       	ldd	r30, Y+5	; 0x05
    67ca:	fe 81       	ldd	r31, Y+6	; 0x06
    67cc:	92 83       	std	Z+2, r25	; 0x02
    67ce:	81 83       	std	Z+1, r24	; 0x01
    67d0:	e9 85       	ldd	r30, Y+9	; 0x09
    67d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    67d4:	13 86       	std	Z+11, r1	; 0x0b
    67d6:	12 86       	std	Z+10, r1	; 0x0a
    67d8:	ed 81       	ldd	r30, Y+5	; 0x05
    67da:	fe 81       	ldd	r31, Y+6	; 0x06
    67dc:	80 81       	ld	r24, Z
    67de:	81 50       	subi	r24, 0x01	; 1
    67e0:	ed 81       	ldd	r30, Y+5	; 0x05
    67e2:	fe 81       	ldd	r31, Y+6	; 0x06
    67e4:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    67e6:	e9 85       	ldd	r30, Y+9	; 0x09
    67e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    67ea:	96 89       	ldd	r25, Z+22	; 0x16
    67ec:	80 91 8c 07 	lds	r24, 0x078C
    67f0:	89 17       	cp	r24, r25
    67f2:	28 f4       	brcc	.+10     	; 0x67fe <vTaskGenericNotifyGiveFromISR+0x146>
    67f4:	e9 85       	ldd	r30, Y+9	; 0x09
    67f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    67f8:	86 89       	ldd	r24, Z+22	; 0x16
    67fa:	80 93 8c 07 	sts	0x078C, r24
    67fe:	e9 85       	ldd	r30, Y+9	; 0x09
    6800:	fa 85       	ldd	r31, Y+10	; 0x0a
    6802:	86 89       	ldd	r24, Z+22	; 0x16
    6804:	28 2f       	mov	r18, r24
    6806:	30 e0       	ldi	r19, 0x00	; 0
    6808:	c9 01       	movw	r24, r18
    680a:	88 0f       	add	r24, r24
    680c:	99 1f       	adc	r25, r25
    680e:	88 0f       	add	r24, r24
    6810:	99 1f       	adc	r25, r25
    6812:	88 0f       	add	r24, r24
    6814:	99 1f       	adc	r25, r25
    6816:	82 0f       	add	r24, r18
    6818:	93 1f       	adc	r25, r19
    681a:	fc 01       	movw	r30, r24
    681c:	e8 56       	subi	r30, 0x68	; 104
    681e:	f8 4f       	sbci	r31, 0xF8	; 248
    6820:	81 81       	ldd	r24, Z+1	; 0x01
    6822:	92 81       	ldd	r25, Z+2	; 0x02
    6824:	9c 83       	std	Y+4, r25	; 0x04
    6826:	8b 83       	std	Y+3, r24	; 0x03
    6828:	e9 85       	ldd	r30, Y+9	; 0x09
    682a:	fa 85       	ldd	r31, Y+10	; 0x0a
    682c:	8b 81       	ldd	r24, Y+3	; 0x03
    682e:	9c 81       	ldd	r25, Y+4	; 0x04
    6830:	95 83       	std	Z+5, r25	; 0x05
    6832:	84 83       	std	Z+4, r24	; 0x04
    6834:	eb 81       	ldd	r30, Y+3	; 0x03
    6836:	fc 81       	ldd	r31, Y+4	; 0x04
    6838:	84 81       	ldd	r24, Z+4	; 0x04
    683a:	95 81       	ldd	r25, Z+5	; 0x05
    683c:	e9 85       	ldd	r30, Y+9	; 0x09
    683e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6840:	97 83       	std	Z+7, r25	; 0x07
    6842:	86 83       	std	Z+6, r24	; 0x06
    6844:	eb 81       	ldd	r30, Y+3	; 0x03
    6846:	fc 81       	ldd	r31, Y+4	; 0x04
    6848:	04 80       	ldd	r0, Z+4	; 0x04
    684a:	f5 81       	ldd	r31, Z+5	; 0x05
    684c:	e0 2d       	mov	r30, r0
    684e:	89 85       	ldd	r24, Y+9	; 0x09
    6850:	9a 85       	ldd	r25, Y+10	; 0x0a
    6852:	02 96       	adiw	r24, 0x02	; 2
    6854:	93 83       	std	Z+3, r25	; 0x03
    6856:	82 83       	std	Z+2, r24	; 0x02
    6858:	89 85       	ldd	r24, Y+9	; 0x09
    685a:	9a 85       	ldd	r25, Y+10	; 0x0a
    685c:	02 96       	adiw	r24, 0x02	; 2
    685e:	eb 81       	ldd	r30, Y+3	; 0x03
    6860:	fc 81       	ldd	r31, Y+4	; 0x04
    6862:	95 83       	std	Z+5, r25	; 0x05
    6864:	84 83       	std	Z+4, r24	; 0x04
    6866:	e9 85       	ldd	r30, Y+9	; 0x09
    6868:	fa 85       	ldd	r31, Y+10	; 0x0a
    686a:	86 89       	ldd	r24, Z+22	; 0x16
    686c:	28 2f       	mov	r18, r24
    686e:	30 e0       	ldi	r19, 0x00	; 0
    6870:	c9 01       	movw	r24, r18
    6872:	88 0f       	add	r24, r24
    6874:	99 1f       	adc	r25, r25
    6876:	88 0f       	add	r24, r24
    6878:	99 1f       	adc	r25, r25
    687a:	88 0f       	add	r24, r24
    687c:	99 1f       	adc	r25, r25
    687e:	82 0f       	add	r24, r18
    6880:	93 1f       	adc	r25, r19
    6882:	88 56       	subi	r24, 0x68	; 104
    6884:	98 4f       	sbci	r25, 0xF8	; 248
    6886:	e9 85       	ldd	r30, Y+9	; 0x09
    6888:	fa 85       	ldd	r31, Y+10	; 0x0a
    688a:	93 87       	std	Z+11, r25	; 0x0b
    688c:	82 87       	std	Z+10, r24	; 0x0a
    688e:	e9 85       	ldd	r30, Y+9	; 0x09
    6890:	fa 85       	ldd	r31, Y+10	; 0x0a
    6892:	86 89       	ldd	r24, Z+22	; 0x16
    6894:	28 2f       	mov	r18, r24
    6896:	30 e0       	ldi	r19, 0x00	; 0
    6898:	c9 01       	movw	r24, r18
    689a:	88 0f       	add	r24, r24
    689c:	99 1f       	adc	r25, r25
    689e:	88 0f       	add	r24, r24
    68a0:	99 1f       	adc	r25, r25
    68a2:	88 0f       	add	r24, r24
    68a4:	99 1f       	adc	r25, r25
    68a6:	82 0f       	add	r24, r18
    68a8:	93 1f       	adc	r25, r19
    68aa:	fc 01       	movw	r30, r24
    68ac:	e8 56       	subi	r30, 0x68	; 104
    68ae:	f8 4f       	sbci	r31, 0xF8	; 248
    68b0:	80 81       	ld	r24, Z
    68b2:	8f 5f       	subi	r24, 0xFF	; 255
    68b4:	80 83       	st	Z, r24
    68b6:	30 c0       	rjmp	.+96     	; 0x6918 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    68b8:	80 91 09 08 	lds	r24, 0x0809
    68bc:	90 91 0a 08 	lds	r25, 0x080A
    68c0:	9a 83       	std	Y+2, r25	; 0x02
    68c2:	89 83       	std	Y+1, r24	; 0x01
    68c4:	e9 85       	ldd	r30, Y+9	; 0x09
    68c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    68c8:	89 81       	ldd	r24, Y+1	; 0x01
    68ca:	9a 81       	ldd	r25, Y+2	; 0x02
    68cc:	97 87       	std	Z+15, r25	; 0x0f
    68ce:	86 87       	std	Z+14, r24	; 0x0e
    68d0:	e9 81       	ldd	r30, Y+1	; 0x01
    68d2:	fa 81       	ldd	r31, Y+2	; 0x02
    68d4:	84 81       	ldd	r24, Z+4	; 0x04
    68d6:	95 81       	ldd	r25, Z+5	; 0x05
    68d8:	e9 85       	ldd	r30, Y+9	; 0x09
    68da:	fa 85       	ldd	r31, Y+10	; 0x0a
    68dc:	91 8b       	std	Z+17, r25	; 0x11
    68de:	80 8b       	std	Z+16, r24	; 0x10
    68e0:	e9 81       	ldd	r30, Y+1	; 0x01
    68e2:	fa 81       	ldd	r31, Y+2	; 0x02
    68e4:	04 80       	ldd	r0, Z+4	; 0x04
    68e6:	f5 81       	ldd	r31, Z+5	; 0x05
    68e8:	e0 2d       	mov	r30, r0
    68ea:	89 85       	ldd	r24, Y+9	; 0x09
    68ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    68ee:	0c 96       	adiw	r24, 0x0c	; 12
    68f0:	93 83       	std	Z+3, r25	; 0x03
    68f2:	82 83       	std	Z+2, r24	; 0x02
    68f4:	89 85       	ldd	r24, Y+9	; 0x09
    68f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    68f8:	0c 96       	adiw	r24, 0x0c	; 12
    68fa:	e9 81       	ldd	r30, Y+1	; 0x01
    68fc:	fa 81       	ldd	r31, Y+2	; 0x02
    68fe:	95 83       	std	Z+5, r25	; 0x05
    6900:	84 83       	std	Z+4, r24	; 0x04
    6902:	e9 85       	ldd	r30, Y+9	; 0x09
    6904:	fa 85       	ldd	r31, Y+10	; 0x0a
    6906:	88 e0       	ldi	r24, 0x08	; 8
    6908:	98 e0       	ldi	r25, 0x08	; 8
    690a:	95 8b       	std	Z+21, r25	; 0x15
    690c:	84 8b       	std	Z+20, r24	; 0x14
    690e:	80 91 08 08 	lds	r24, 0x0808
    6912:	8f 5f       	subi	r24, 0xFF	; 255
    6914:	80 93 08 08 	sts	0x0808, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6918:	e9 85       	ldd	r30, Y+9	; 0x09
    691a:	fa 85       	ldd	r31, Y+10	; 0x0a
    691c:	96 89       	ldd	r25, Z+22	; 0x16
    691e:	e0 91 86 07 	lds	r30, 0x0786
    6922:	f0 91 87 07 	lds	r31, 0x0787
    6926:	86 89       	ldd	r24, Z+22	; 0x16
    6928:	89 17       	cp	r24, r25
    692a:	58 f4       	brcc	.+22     	; 0x6942 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    692c:	8e 85       	ldd	r24, Y+14	; 0x0e
    692e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6930:	00 97       	sbiw	r24, 0x00	; 0
    6932:	21 f0       	breq	.+8      	; 0x693c <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    6934:	ee 85       	ldd	r30, Y+14	; 0x0e
    6936:	ff 85       	ldd	r31, Y+15	; 0x0f
    6938:	81 e0       	ldi	r24, 0x01	; 1
    693a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    693c:	81 e0       	ldi	r24, 0x01	; 1
    693e:	80 93 90 07 	sts	0x0790, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    6942:	2f 96       	adiw	r28, 0x0f	; 15
    6944:	0f b6       	in	r0, 0x3f	; 63
    6946:	f8 94       	cli
    6948:	de bf       	out	0x3e, r29	; 62
    694a:	0f be       	out	0x3f, r0	; 63
    694c:	cd bf       	out	0x3d, r28	; 61
    694e:	cf 91       	pop	r28
    6950:	df 91       	pop	r29
    6952:	1f 91       	pop	r17
    6954:	0f 91       	pop	r16
    6956:	08 95       	ret

00006958 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    6958:	df 93       	push	r29
    695a:	cf 93       	push	r28
    695c:	cd b7       	in	r28, 0x3d	; 61
    695e:	de b7       	in	r29, 0x3e	; 62
    6960:	28 97       	sbiw	r28, 0x08	; 8
    6962:	0f b6       	in	r0, 0x3f	; 63
    6964:	f8 94       	cli
    6966:	de bf       	out	0x3e, r29	; 62
    6968:	0f be       	out	0x3f, r0	; 63
    696a:	cd bf       	out	0x3d, r28	; 61
    696c:	9d 83       	std	Y+5, r25	; 0x05
    696e:	8c 83       	std	Y+4, r24	; 0x04
    6970:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6972:	8c 81       	ldd	r24, Y+4	; 0x04
    6974:	9d 81       	ldd	r25, Y+5	; 0x05
    6976:	00 97       	sbiw	r24, 0x00	; 0
    6978:	39 f4       	brne	.+14     	; 0x6988 <xTaskGenericNotifyStateClear+0x30>
    697a:	80 91 86 07 	lds	r24, 0x0786
    697e:	90 91 87 07 	lds	r25, 0x0787
    6982:	98 87       	std	Y+8, r25	; 0x08
    6984:	8f 83       	std	Y+7, r24	; 0x07
    6986:	04 c0       	rjmp	.+8      	; 0x6990 <xTaskGenericNotifyStateClear+0x38>
    6988:	8c 81       	ldd	r24, Y+4	; 0x04
    698a:	9d 81       	ldd	r25, Y+5	; 0x05
    698c:	98 87       	std	Y+8, r25	; 0x08
    698e:	8f 83       	std	Y+7, r24	; 0x07
    6990:	8f 81       	ldd	r24, Y+7	; 0x07
    6992:	98 85       	ldd	r25, Y+8	; 0x08
    6994:	9b 83       	std	Y+3, r25	; 0x03
    6996:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    6998:	0f b6       	in	r0, 0x3f	; 63
    699a:	f8 94       	cli
    699c:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    699e:	8e 81       	ldd	r24, Y+6	; 0x06
    69a0:	28 2f       	mov	r18, r24
    69a2:	30 e0       	ldi	r19, 0x00	; 0
    69a4:	8a 81       	ldd	r24, Y+2	; 0x02
    69a6:	9b 81       	ldd	r25, Y+3	; 0x03
    69a8:	82 0f       	add	r24, r18
    69aa:	93 1f       	adc	r25, r19
    69ac:	fc 01       	movw	r30, r24
    69ae:	fb 96       	adiw	r30, 0x3b	; 59
    69b0:	80 81       	ld	r24, Z
    69b2:	82 30       	cpi	r24, 0x02	; 2
    69b4:	69 f4       	brne	.+26     	; 0x69d0 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    69b6:	8e 81       	ldd	r24, Y+6	; 0x06
    69b8:	28 2f       	mov	r18, r24
    69ba:	30 e0       	ldi	r19, 0x00	; 0
    69bc:	8a 81       	ldd	r24, Y+2	; 0x02
    69be:	9b 81       	ldd	r25, Y+3	; 0x03
    69c0:	82 0f       	add	r24, r18
    69c2:	93 1f       	adc	r25, r19
    69c4:	fc 01       	movw	r30, r24
    69c6:	fb 96       	adiw	r30, 0x3b	; 59
    69c8:	10 82       	st	Z, r1
                xReturn = pdPASS;
    69ca:	81 e0       	ldi	r24, 0x01	; 1
    69cc:	89 83       	std	Y+1, r24	; 0x01
    69ce:	01 c0       	rjmp	.+2      	; 0x69d2 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    69d0:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    69d2:	0f 90       	pop	r0
    69d4:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    69d6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    69d8:	28 96       	adiw	r28, 0x08	; 8
    69da:	0f b6       	in	r0, 0x3f	; 63
    69dc:	f8 94       	cli
    69de:	de bf       	out	0x3e, r29	; 62
    69e0:	0f be       	out	0x3f, r0	; 63
    69e2:	cd bf       	out	0x3d, r28	; 61
    69e4:	cf 91       	pop	r28
    69e6:	df 91       	pop	r29
    69e8:	08 95       	ret

000069ea <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    69ea:	0f 93       	push	r16
    69ec:	1f 93       	push	r17
    69ee:	df 93       	push	r29
    69f0:	cf 93       	push	r28
    69f2:	cd b7       	in	r28, 0x3d	; 61
    69f4:	de b7       	in	r29, 0x3e	; 62
    69f6:	2f 97       	sbiw	r28, 0x0f	; 15
    69f8:	0f b6       	in	r0, 0x3f	; 63
    69fa:	f8 94       	cli
    69fc:	de bf       	out	0x3e, r29	; 62
    69fe:	0f be       	out	0x3f, r0	; 63
    6a00:	cd bf       	out	0x3d, r28	; 61
    6a02:	98 87       	std	Y+8, r25	; 0x08
    6a04:	8f 83       	std	Y+7, r24	; 0x07
    6a06:	69 87       	std	Y+9, r22	; 0x09
    6a08:	2a 87       	std	Y+10, r18	; 0x0a
    6a0a:	3b 87       	std	Y+11, r19	; 0x0b
    6a0c:	4c 87       	std	Y+12, r20	; 0x0c
    6a0e:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6a10:	8f 81       	ldd	r24, Y+7	; 0x07
    6a12:	98 85       	ldd	r25, Y+8	; 0x08
    6a14:	00 97       	sbiw	r24, 0x00	; 0
    6a16:	39 f4       	brne	.+14     	; 0x6a26 <ulTaskGenericNotifyValueClear+0x3c>
    6a18:	80 91 86 07 	lds	r24, 0x0786
    6a1c:	90 91 87 07 	lds	r25, 0x0787
    6a20:	9f 87       	std	Y+15, r25	; 0x0f
    6a22:	8e 87       	std	Y+14, r24	; 0x0e
    6a24:	04 c0       	rjmp	.+8      	; 0x6a2e <ulTaskGenericNotifyValueClear+0x44>
    6a26:	8f 81       	ldd	r24, Y+7	; 0x07
    6a28:	98 85       	ldd	r25, Y+8	; 0x08
    6a2a:	9f 87       	std	Y+15, r25	; 0x0f
    6a2c:	8e 87       	std	Y+14, r24	; 0x0e
    6a2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a30:	9f 85       	ldd	r25, Y+15	; 0x0f
    6a32:	9e 83       	std	Y+6, r25	; 0x06
    6a34:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    6a36:	0f b6       	in	r0, 0x3f	; 63
    6a38:	f8 94       	cli
    6a3a:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    6a3c:	89 85       	ldd	r24, Y+9	; 0x09
    6a3e:	88 2f       	mov	r24, r24
    6a40:	90 e0       	ldi	r25, 0x00	; 0
    6a42:	2d 81       	ldd	r18, Y+5	; 0x05
    6a44:	3e 81       	ldd	r19, Y+6	; 0x06
    6a46:	88 0f       	add	r24, r24
    6a48:	99 1f       	adc	r25, r25
    6a4a:	88 0f       	add	r24, r24
    6a4c:	99 1f       	adc	r25, r25
    6a4e:	82 0f       	add	r24, r18
    6a50:	93 1f       	adc	r25, r19
    6a52:	fc 01       	movw	r30, r24
    6a54:	f7 96       	adiw	r30, 0x37	; 55
    6a56:	80 81       	ld	r24, Z
    6a58:	91 81       	ldd	r25, Z+1	; 0x01
    6a5a:	a2 81       	ldd	r26, Z+2	; 0x02
    6a5c:	b3 81       	ldd	r27, Z+3	; 0x03
    6a5e:	89 83       	std	Y+1, r24	; 0x01
    6a60:	9a 83       	std	Y+2, r25	; 0x02
    6a62:	ab 83       	std	Y+3, r26	; 0x03
    6a64:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    6a66:	89 85       	ldd	r24, Y+9	; 0x09
    6a68:	08 2f       	mov	r16, r24
    6a6a:	10 e0       	ldi	r17, 0x00	; 0
    6a6c:	89 85       	ldd	r24, Y+9	; 0x09
    6a6e:	88 2f       	mov	r24, r24
    6a70:	90 e0       	ldi	r25, 0x00	; 0
    6a72:	2d 81       	ldd	r18, Y+5	; 0x05
    6a74:	3e 81       	ldd	r19, Y+6	; 0x06
    6a76:	88 0f       	add	r24, r24
    6a78:	99 1f       	adc	r25, r25
    6a7a:	88 0f       	add	r24, r24
    6a7c:	99 1f       	adc	r25, r25
    6a7e:	82 0f       	add	r24, r18
    6a80:	93 1f       	adc	r25, r19
    6a82:	fc 01       	movw	r30, r24
    6a84:	f7 96       	adiw	r30, 0x37	; 55
    6a86:	20 81       	ld	r18, Z
    6a88:	31 81       	ldd	r19, Z+1	; 0x01
    6a8a:	42 81       	ldd	r20, Z+2	; 0x02
    6a8c:	53 81       	ldd	r21, Z+3	; 0x03
    6a8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6a90:	9b 85       	ldd	r25, Y+11	; 0x0b
    6a92:	ac 85       	ldd	r26, Y+12	; 0x0c
    6a94:	bd 85       	ldd	r27, Y+13	; 0x0d
    6a96:	80 95       	com	r24
    6a98:	90 95       	com	r25
    6a9a:	a0 95       	com	r26
    6a9c:	b0 95       	com	r27
    6a9e:	ba 01       	movw	r22, r20
    6aa0:	a9 01       	movw	r20, r18
    6aa2:	48 23       	and	r20, r24
    6aa4:	59 23       	and	r21, r25
    6aa6:	6a 23       	and	r22, r26
    6aa8:	7b 23       	and	r23, r27
    6aaa:	2d 81       	ldd	r18, Y+5	; 0x05
    6aac:	3e 81       	ldd	r19, Y+6	; 0x06
    6aae:	c8 01       	movw	r24, r16
    6ab0:	88 0f       	add	r24, r24
    6ab2:	99 1f       	adc	r25, r25
    6ab4:	88 0f       	add	r24, r24
    6ab6:	99 1f       	adc	r25, r25
    6ab8:	82 0f       	add	r24, r18
    6aba:	93 1f       	adc	r25, r19
    6abc:	fc 01       	movw	r30, r24
    6abe:	f7 96       	adiw	r30, 0x37	; 55
    6ac0:	40 83       	st	Z, r20
    6ac2:	51 83       	std	Z+1, r21	; 0x01
    6ac4:	62 83       	std	Z+2, r22	; 0x02
    6ac6:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    6ac8:	0f 90       	pop	r0
    6aca:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    6acc:	89 81       	ldd	r24, Y+1	; 0x01
    6ace:	9a 81       	ldd	r25, Y+2	; 0x02
    6ad0:	ab 81       	ldd	r26, Y+3	; 0x03
    6ad2:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    6ad4:	bc 01       	movw	r22, r24
    6ad6:	cd 01       	movw	r24, r26
    6ad8:	2f 96       	adiw	r28, 0x0f	; 15
    6ada:	0f b6       	in	r0, 0x3f	; 63
    6adc:	f8 94       	cli
    6ade:	de bf       	out	0x3e, r29	; 62
    6ae0:	0f be       	out	0x3f, r0	; 63
    6ae2:	cd bf       	out	0x3d, r28	; 61
    6ae4:	cf 91       	pop	r28
    6ae6:	df 91       	pop	r29
    6ae8:	1f 91       	pop	r17
    6aea:	0f 91       	pop	r16
    6aec:	08 95       	ret

00006aee <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    6aee:	df 93       	push	r29
    6af0:	cf 93       	push	r28
    6af2:	cd b7       	in	r28, 0x3d	; 61
    6af4:	de b7       	in	r29, 0x3e	; 62
    6af6:	27 97       	sbiw	r28, 0x07	; 7
    6af8:	0f b6       	in	r0, 0x3f	; 63
    6afa:	f8 94       	cli
    6afc:	de bf       	out	0x3e, r29	; 62
    6afe:	0f be       	out	0x3f, r0	; 63
    6b00:	cd bf       	out	0x3d, r28	; 61
    6b02:	9e 83       	std	Y+6, r25	; 0x06
    6b04:	8d 83       	std	Y+5, r24	; 0x05
    6b06:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    6b08:	80 91 8a 07 	lds	r24, 0x078A
    6b0c:	90 91 8b 07 	lds	r25, 0x078B
    6b10:	9a 83       	std	Y+2, r25	; 0x02
    6b12:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6b14:	80 91 86 07 	lds	r24, 0x0786
    6b18:	90 91 87 07 	lds	r25, 0x0787
    6b1c:	02 96       	adiw	r24, 0x02	; 2
    6b1e:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    6b22:	29 81       	ldd	r18, Y+1	; 0x01
    6b24:	3a 81       	ldd	r19, Y+2	; 0x02
    6b26:	8d 81       	ldd	r24, Y+5	; 0x05
    6b28:	9e 81       	ldd	r25, Y+6	; 0x06
    6b2a:	82 0f       	add	r24, r18
    6b2c:	93 1f       	adc	r25, r19
    6b2e:	9c 83       	std	Y+4, r25	; 0x04
    6b30:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6b32:	e0 91 86 07 	lds	r30, 0x0786
    6b36:	f0 91 87 07 	lds	r31, 0x0787
    6b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    6b3e:	93 83       	std	Z+3, r25	; 0x03
    6b40:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    6b42:	2b 81       	ldd	r18, Y+3	; 0x03
    6b44:	3c 81       	ldd	r19, Y+4	; 0x04
    6b46:	89 81       	ldd	r24, Y+1	; 0x01
    6b48:	9a 81       	ldd	r25, Y+2	; 0x02
    6b4a:	28 17       	cp	r18, r24
    6b4c:	39 07       	cpc	r19, r25
    6b4e:	70 f4       	brcc	.+28     	; 0x6b6c <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6b50:	80 91 06 08 	lds	r24, 0x0806
    6b54:	90 91 07 08 	lds	r25, 0x0807
    6b58:	20 91 86 07 	lds	r18, 0x0786
    6b5c:	30 91 87 07 	lds	r19, 0x0787
    6b60:	2e 5f       	subi	r18, 0xFE	; 254
    6b62:	3f 4f       	sbci	r19, 0xFF	; 255
    6b64:	b9 01       	movw	r22, r18
    6b66:	0e 94 75 0f 	call	0x1eea	; 0x1eea <vListInsert>
    6b6a:	1e c0       	rjmp	.+60     	; 0x6ba8 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6b6c:	40 91 04 08 	lds	r20, 0x0804
    6b70:	50 91 05 08 	lds	r21, 0x0805
    6b74:	80 91 86 07 	lds	r24, 0x0786
    6b78:	90 91 87 07 	lds	r25, 0x0787
    6b7c:	9c 01       	movw	r18, r24
    6b7e:	2e 5f       	subi	r18, 0xFE	; 254
    6b80:	3f 4f       	sbci	r19, 0xFF	; 255
    6b82:	ca 01       	movw	r24, r20
    6b84:	b9 01       	movw	r22, r18
    6b86:	0e 94 75 0f 	call	0x1eea	; 0x1eea <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    6b8a:	20 91 93 07 	lds	r18, 0x0793
    6b8e:	30 91 94 07 	lds	r19, 0x0794
    6b92:	8b 81       	ldd	r24, Y+3	; 0x03
    6b94:	9c 81       	ldd	r25, Y+4	; 0x04
    6b96:	82 17       	cp	r24, r18
    6b98:	93 07       	cpc	r25, r19
    6b9a:	30 f4       	brcc	.+12     	; 0x6ba8 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    6b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    6b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    6ba0:	90 93 94 07 	sts	0x0794, r25
    6ba4:	80 93 93 07 	sts	0x0793, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    6ba8:	27 96       	adiw	r28, 0x07	; 7
    6baa:	0f b6       	in	r0, 0x3f	; 63
    6bac:	f8 94       	cli
    6bae:	de bf       	out	0x3e, r29	; 62
    6bb0:	0f be       	out	0x3f, r0	; 63
    6bb2:	cd bf       	out	0x3d, r28	; 61
    6bb4:	cf 91       	pop	r28
    6bb6:	df 91       	pop	r29
    6bb8:	08 95       	ret

00006bba <lcd_init>:
#include "LCD.h"
#include "avr/io.h"


void lcd_init(void)
{
    6bba:	df 93       	push	r29
    6bbc:	cf 93       	push	r28
    6bbe:	cd b7       	in	r28, 0x3d	; 61
    6bc0:	de b7       	in	r29, 0x3e	; 62
    6bc2:	e4 97       	sbiw	r28, 0x34	; 52
    6bc4:	0f b6       	in	r0, 0x3f	; 63
    6bc6:	f8 94       	cli
    6bc8:	de bf       	out	0x3e, r29	; 62
    6bca:	0f be       	out	0x3f, r0	; 63
    6bcc:	cd bf       	out	0x3d, r28	; 61
    6bce:	80 e0       	ldi	r24, 0x00	; 0
    6bd0:	90 e0       	ldi	r25, 0x00	; 0
    6bd2:	a0 ea       	ldi	r26, 0xA0	; 160
    6bd4:	b1 e4       	ldi	r27, 0x41	; 65
    6bd6:	89 ab       	std	Y+49, r24	; 0x31
    6bd8:	9a ab       	std	Y+50, r25	; 0x32
    6bda:	ab ab       	std	Y+51, r26	; 0x33
    6bdc:	bc ab       	std	Y+52, r27	; 0x34
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6bde:	69 a9       	ldd	r22, Y+49	; 0x31
    6be0:	7a a9       	ldd	r23, Y+50	; 0x32
    6be2:	8b a9       	ldd	r24, Y+51	; 0x33
    6be4:	9c a9       	ldd	r25, Y+52	; 0x34
    6be6:	20 e0       	ldi	r18, 0x00	; 0
    6be8:	30 e0       	ldi	r19, 0x00	; 0
    6bea:	4a ef       	ldi	r20, 0xFA	; 250
    6bec:	54 e4       	ldi	r21, 0x44	; 68
    6bee:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6bf2:	dc 01       	movw	r26, r24
    6bf4:	cb 01       	movw	r24, r22
    6bf6:	8d a7       	std	Y+45, r24	; 0x2d
    6bf8:	9e a7       	std	Y+46, r25	; 0x2e
    6bfa:	af a7       	std	Y+47, r26	; 0x2f
    6bfc:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
    6bfe:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c00:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c02:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c04:	98 a9       	ldd	r25, Y+48	; 0x30
    6c06:	20 e0       	ldi	r18, 0x00	; 0
    6c08:	30 e0       	ldi	r19, 0x00	; 0
    6c0a:	40 e8       	ldi	r20, 0x80	; 128
    6c0c:	5f e3       	ldi	r21, 0x3F	; 63
    6c0e:	0e 94 20 05 	call	0xa40	; 0xa40 <__ltsf2>
    6c12:	88 23       	and	r24, r24
    6c14:	2c f4       	brge	.+10     	; 0x6c20 <lcd_init+0x66>
		__ticks = 1;
    6c16:	81 e0       	ldi	r24, 0x01	; 1
    6c18:	90 e0       	ldi	r25, 0x00	; 0
    6c1a:	9c a7       	std	Y+44, r25	; 0x2c
    6c1c:	8b a7       	std	Y+43, r24	; 0x2b
    6c1e:	3f c0       	rjmp	.+126    	; 0x6c9e <lcd_init+0xe4>
	else if (__tmp > 65535)
    6c20:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c22:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c24:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c26:	98 a9       	ldd	r25, Y+48	; 0x30
    6c28:	20 e0       	ldi	r18, 0x00	; 0
    6c2a:	3f ef       	ldi	r19, 0xFF	; 255
    6c2c:	4f e7       	ldi	r20, 0x7F	; 127
    6c2e:	57 e4       	ldi	r21, 0x47	; 71
    6c30:	0e 94 c0 04 	call	0x980	; 0x980 <__gtsf2>
    6c34:	18 16       	cp	r1, r24
    6c36:	4c f5       	brge	.+82     	; 0x6c8a <lcd_init+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6c38:	69 a9       	ldd	r22, Y+49	; 0x31
    6c3a:	7a a9       	ldd	r23, Y+50	; 0x32
    6c3c:	8b a9       	ldd	r24, Y+51	; 0x33
    6c3e:	9c a9       	ldd	r25, Y+52	; 0x34
    6c40:	20 e0       	ldi	r18, 0x00	; 0
    6c42:	30 e0       	ldi	r19, 0x00	; 0
    6c44:	40 e2       	ldi	r20, 0x20	; 32
    6c46:	51 e4       	ldi	r21, 0x41	; 65
    6c48:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6c4c:	dc 01       	movw	r26, r24
    6c4e:	cb 01       	movw	r24, r22
    6c50:	bc 01       	movw	r22, r24
    6c52:	cd 01       	movw	r24, r26
    6c54:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6c58:	dc 01       	movw	r26, r24
    6c5a:	cb 01       	movw	r24, r22
    6c5c:	9c a7       	std	Y+44, r25	; 0x2c
    6c5e:	8b a7       	std	Y+43, r24	; 0x2b
    6c60:	0f c0       	rjmp	.+30     	; 0x6c80 <lcd_init+0xc6>
    6c62:	88 ec       	ldi	r24, 0xC8	; 200
    6c64:	90 e0       	ldi	r25, 0x00	; 0
    6c66:	9a a7       	std	Y+42, r25	; 0x2a
    6c68:	89 a7       	std	Y+41, r24	; 0x29
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6c6a:	89 a5       	ldd	r24, Y+41	; 0x29
    6c6c:	9a a5       	ldd	r25, Y+42	; 0x2a
    6c6e:	01 97       	sbiw	r24, 0x01	; 1
    6c70:	f1 f7       	brne	.-4      	; 0x6c6e <lcd_init+0xb4>
    6c72:	9a a7       	std	Y+42, r25	; 0x2a
    6c74:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c76:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c78:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c7a:	01 97       	sbiw	r24, 0x01	; 1
    6c7c:	9c a7       	std	Y+44, r25	; 0x2c
    6c7e:	8b a7       	std	Y+43, r24	; 0x2b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c80:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c82:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c84:	00 97       	sbiw	r24, 0x00	; 0
    6c86:	69 f7       	brne	.-38     	; 0x6c62 <lcd_init+0xa8>
    6c88:	14 c0       	rjmp	.+40     	; 0x6cb2 <lcd_init+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6c8a:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c8c:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c8e:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c90:	98 a9       	ldd	r25, Y+48	; 0x30
    6c92:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6c96:	dc 01       	movw	r26, r24
    6c98:	cb 01       	movw	r24, r22
    6c9a:	9c a7       	std	Y+44, r25	; 0x2c
    6c9c:	8b a7       	std	Y+43, r24	; 0x2b
    6c9e:	8b a5       	ldd	r24, Y+43	; 0x2b
    6ca0:	9c a5       	ldd	r25, Y+44	; 0x2c
    6ca2:	98 a7       	std	Y+40, r25	; 0x28
    6ca4:	8f a3       	std	Y+39, r24	; 0x27
    6ca6:	8f a1       	ldd	r24, Y+39	; 0x27
    6ca8:	98 a5       	ldd	r25, Y+40	; 0x28
    6caa:	01 97       	sbiw	r24, 0x01	; 1
    6cac:	f1 f7       	brne	.-4      	; 0x6caa <lcd_init+0xf0>
    6cae:	98 a7       	std	Y+40, r25	; 0x28
    6cb0:	8f a3       	std	Y+39, r24	; 0x27
	_delay_ms(20);
	//LCD data set as output
	lcd_data_dir |= (0xFF << Data_shift);
    6cb2:	a4 e3       	ldi	r26, 0x34	; 52
    6cb4:	b0 e0       	ldi	r27, 0x00	; 0
    6cb6:	e4 e3       	ldi	r30, 0x34	; 52
    6cb8:	f0 e0       	ldi	r31, 0x00	; 0
    6cba:	80 81       	ld	r24, Z
    6cbc:	80 6f       	ori	r24, 0xF0	; 240
    6cbe:	8c 93       	st	X, r24
	//set RS,RW,E as output
	Set_bit(lcd_ctrl_dir, EN);
    6cc0:	a1 e3       	ldi	r26, 0x31	; 49
    6cc2:	b0 e0       	ldi	r27, 0x00	; 0
    6cc4:	e1 e3       	ldi	r30, 0x31	; 49
    6cc6:	f0 e0       	ldi	r31, 0x00	; 0
    6cc8:	80 81       	ld	r24, Z
    6cca:	84 60       	ori	r24, 0x04	; 4
    6ccc:	8c 93       	st	X, r24
	Set_bit(lcd_ctrl_dir, RS);
    6cce:	a1 e3       	ldi	r26, 0x31	; 49
    6cd0:	b0 e0       	ldi	r27, 0x00	; 0
    6cd2:	e1 e3       	ldi	r30, 0x31	; 49
    6cd4:	f0 e0       	ldi	r31, 0x00	; 0
    6cd6:	80 81       	ld	r24, Z
    6cd8:	81 60       	ori	r24, 0x01	; 1
    6cda:	8c 93       	st	X, r24
	Set_bit(lcd_ctrl_dir, RW);
    6cdc:	a1 e3       	ldi	r26, 0x31	; 49
    6cde:	b0 e0       	ldi	r27, 0x00	; 0
    6ce0:	e1 e3       	ldi	r30, 0x31	; 49
    6ce2:	f0 e0       	ldi	r31, 0x00	; 0
    6ce4:	80 81       	ld	r24, Z
    6ce6:	82 60       	ori	r24, 0x02	; 2
    6ce8:	8c 93       	st	X, r24
	lcd_ctrl_port &= ~((1 << EN) | (1 << RS) | (1 << RW));
    6cea:	a2 e3       	ldi	r26, 0x32	; 50
    6cec:	b0 e0       	ldi	r27, 0x00	; 0
    6cee:	e2 e3       	ldi	r30, 0x32	; 50
    6cf0:	f0 e0       	ldi	r31, 0x00	; 0
    6cf2:	80 81       	ld	r24, Z
    6cf4:	88 7f       	andi	r24, 0xF8	; 248
    6cf6:	8c 93       	st	X, r24
	lcd_write_command(0x30);
    6cf8:	80 e3       	ldi	r24, 0x30	; 48
    6cfa:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
    6cfe:	80 e0       	ldi	r24, 0x00	; 0
    6d00:	90 e0       	ldi	r25, 0x00	; 0
    6d02:	a0 e2       	ldi	r26, 0x20	; 32
    6d04:	b1 e4       	ldi	r27, 0x41	; 65
    6d06:	8b a3       	std	Y+35, r24	; 0x23
    6d08:	9c a3       	std	Y+36, r25	; 0x24
    6d0a:	ad a3       	std	Y+37, r26	; 0x25
    6d0c:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6d0e:	6b a1       	ldd	r22, Y+35	; 0x23
    6d10:	7c a1       	ldd	r23, Y+36	; 0x24
    6d12:	8d a1       	ldd	r24, Y+37	; 0x25
    6d14:	9e a1       	ldd	r25, Y+38	; 0x26
    6d16:	20 e0       	ldi	r18, 0x00	; 0
    6d18:	30 e0       	ldi	r19, 0x00	; 0
    6d1a:	4a ef       	ldi	r20, 0xFA	; 250
    6d1c:	54 e4       	ldi	r21, 0x44	; 68
    6d1e:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6d22:	dc 01       	movw	r26, r24
    6d24:	cb 01       	movw	r24, r22
    6d26:	8f 8f       	std	Y+31, r24	; 0x1f
    6d28:	98 a3       	std	Y+32, r25	; 0x20
    6d2a:	a9 a3       	std	Y+33, r26	; 0x21
    6d2c:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    6d2e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    6d30:	78 a1       	ldd	r23, Y+32	; 0x20
    6d32:	89 a1       	ldd	r24, Y+33	; 0x21
    6d34:	9a a1       	ldd	r25, Y+34	; 0x22
    6d36:	20 e0       	ldi	r18, 0x00	; 0
    6d38:	30 e0       	ldi	r19, 0x00	; 0
    6d3a:	40 e8       	ldi	r20, 0x80	; 128
    6d3c:	5f e3       	ldi	r21, 0x3F	; 63
    6d3e:	0e 94 20 05 	call	0xa40	; 0xa40 <__ltsf2>
    6d42:	88 23       	and	r24, r24
    6d44:	2c f4       	brge	.+10     	; 0x6d50 <lcd_init+0x196>
		__ticks = 1;
    6d46:	81 e0       	ldi	r24, 0x01	; 1
    6d48:	90 e0       	ldi	r25, 0x00	; 0
    6d4a:	9e 8f       	std	Y+30, r25	; 0x1e
    6d4c:	8d 8f       	std	Y+29, r24	; 0x1d
    6d4e:	3f c0       	rjmp	.+126    	; 0x6dce <lcd_init+0x214>
	else if (__tmp > 65535)
    6d50:	6f 8d       	ldd	r22, Y+31	; 0x1f
    6d52:	78 a1       	ldd	r23, Y+32	; 0x20
    6d54:	89 a1       	ldd	r24, Y+33	; 0x21
    6d56:	9a a1       	ldd	r25, Y+34	; 0x22
    6d58:	20 e0       	ldi	r18, 0x00	; 0
    6d5a:	3f ef       	ldi	r19, 0xFF	; 255
    6d5c:	4f e7       	ldi	r20, 0x7F	; 127
    6d5e:	57 e4       	ldi	r21, 0x47	; 71
    6d60:	0e 94 c0 04 	call	0x980	; 0x980 <__gtsf2>
    6d64:	18 16       	cp	r1, r24
    6d66:	4c f5       	brge	.+82     	; 0x6dba <lcd_init+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6d68:	6b a1       	ldd	r22, Y+35	; 0x23
    6d6a:	7c a1       	ldd	r23, Y+36	; 0x24
    6d6c:	8d a1       	ldd	r24, Y+37	; 0x25
    6d6e:	9e a1       	ldd	r25, Y+38	; 0x26
    6d70:	20 e0       	ldi	r18, 0x00	; 0
    6d72:	30 e0       	ldi	r19, 0x00	; 0
    6d74:	40 e2       	ldi	r20, 0x20	; 32
    6d76:	51 e4       	ldi	r21, 0x41	; 65
    6d78:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6d7c:	dc 01       	movw	r26, r24
    6d7e:	cb 01       	movw	r24, r22
    6d80:	bc 01       	movw	r22, r24
    6d82:	cd 01       	movw	r24, r26
    6d84:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6d88:	dc 01       	movw	r26, r24
    6d8a:	cb 01       	movw	r24, r22
    6d8c:	9e 8f       	std	Y+30, r25	; 0x1e
    6d8e:	8d 8f       	std	Y+29, r24	; 0x1d
    6d90:	0f c0       	rjmp	.+30     	; 0x6db0 <lcd_init+0x1f6>
    6d92:	88 ec       	ldi	r24, 0xC8	; 200
    6d94:	90 e0       	ldi	r25, 0x00	; 0
    6d96:	9c 8f       	std	Y+28, r25	; 0x1c
    6d98:	8b 8f       	std	Y+27, r24	; 0x1b
    6d9a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6d9c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6d9e:	01 97       	sbiw	r24, 0x01	; 1
    6da0:	f1 f7       	brne	.-4      	; 0x6d9e <lcd_init+0x1e4>
    6da2:	9c 8f       	std	Y+28, r25	; 0x1c
    6da4:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6da6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6da8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6daa:	01 97       	sbiw	r24, 0x01	; 1
    6dac:	9e 8f       	std	Y+30, r25	; 0x1e
    6dae:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6db0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6db2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6db4:	00 97       	sbiw	r24, 0x00	; 0
    6db6:	69 f7       	brne	.-38     	; 0x6d92 <lcd_init+0x1d8>
    6db8:	14 c0       	rjmp	.+40     	; 0x6de2 <lcd_init+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6dba:	6f 8d       	ldd	r22, Y+31	; 0x1f
    6dbc:	78 a1       	ldd	r23, Y+32	; 0x20
    6dbe:	89 a1       	ldd	r24, Y+33	; 0x21
    6dc0:	9a a1       	ldd	r25, Y+34	; 0x22
    6dc2:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6dc6:	dc 01       	movw	r26, r24
    6dc8:	cb 01       	movw	r24, r22
    6dca:	9e 8f       	std	Y+30, r25	; 0x1e
    6dcc:	8d 8f       	std	Y+29, r24	; 0x1d
    6dce:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6dd0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6dd2:	9a 8f       	std	Y+26, r25	; 0x1a
    6dd4:	89 8f       	std	Y+25, r24	; 0x19
    6dd6:	89 8d       	ldd	r24, Y+25	; 0x19
    6dd8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    6dda:	01 97       	sbiw	r24, 0x01	; 1
    6ddc:	f1 f7       	brne	.-4      	; 0x6dda <lcd_init+0x220>
    6dde:	9a 8f       	std	Y+26, r25	; 0x1a
    6de0:	89 8f       	std	Y+25, r24	; 0x19
	_delay_ms(10);
	lcd_write_command(0x30);
    6de2:	80 e3       	ldi	r24, 0x30	; 48
    6de4:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
    6de8:	80 e0       	ldi	r24, 0x00	; 0
    6dea:	90 e0       	ldi	r25, 0x00	; 0
    6dec:	a8 e4       	ldi	r26, 0x48	; 72
    6dee:	b3 e4       	ldi	r27, 0x43	; 67
    6df0:	8d 8b       	std	Y+21, r24	; 0x15
    6df2:	9e 8b       	std	Y+22, r25	; 0x16
    6df4:	af 8b       	std	Y+23, r26	; 0x17
    6df6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6df8:	6d 89       	ldd	r22, Y+21	; 0x15
    6dfa:	7e 89       	ldd	r23, Y+22	; 0x16
    6dfc:	8f 89       	ldd	r24, Y+23	; 0x17
    6dfe:	98 8d       	ldd	r25, Y+24	; 0x18
    6e00:	2b ea       	ldi	r18, 0xAB	; 171
    6e02:	3a ea       	ldi	r19, 0xAA	; 170
    6e04:	4a e2       	ldi	r20, 0x2A	; 42
    6e06:	50 e4       	ldi	r21, 0x40	; 64
    6e08:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6e0c:	dc 01       	movw	r26, r24
    6e0e:	cb 01       	movw	r24, r22
    6e10:	89 8b       	std	Y+17, r24	; 0x11
    6e12:	9a 8b       	std	Y+18, r25	; 0x12
    6e14:	ab 8b       	std	Y+19, r26	; 0x13
    6e16:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    6e18:	69 89       	ldd	r22, Y+17	; 0x11
    6e1a:	7a 89       	ldd	r23, Y+18	; 0x12
    6e1c:	8b 89       	ldd	r24, Y+19	; 0x13
    6e1e:	9c 89       	ldd	r25, Y+20	; 0x14
    6e20:	20 e0       	ldi	r18, 0x00	; 0
    6e22:	30 e0       	ldi	r19, 0x00	; 0
    6e24:	40 e8       	ldi	r20, 0x80	; 128
    6e26:	5f e3       	ldi	r21, 0x3F	; 63
    6e28:	0e 94 20 05 	call	0xa40	; 0xa40 <__ltsf2>
    6e2c:	88 23       	and	r24, r24
    6e2e:	1c f4       	brge	.+6      	; 0x6e36 <lcd_init+0x27c>
		__ticks = 1;
    6e30:	81 e0       	ldi	r24, 0x01	; 1
    6e32:	88 8b       	std	Y+16, r24	; 0x10
    6e34:	91 c0       	rjmp	.+290    	; 0x6f58 <lcd_init+0x39e>
	else if (__tmp > 255)
    6e36:	69 89       	ldd	r22, Y+17	; 0x11
    6e38:	7a 89       	ldd	r23, Y+18	; 0x12
    6e3a:	8b 89       	ldd	r24, Y+19	; 0x13
    6e3c:	9c 89       	ldd	r25, Y+20	; 0x14
    6e3e:	20 e0       	ldi	r18, 0x00	; 0
    6e40:	30 e0       	ldi	r19, 0x00	; 0
    6e42:	4f e7       	ldi	r20, 0x7F	; 127
    6e44:	53 e4       	ldi	r21, 0x43	; 67
    6e46:	0e 94 c0 04 	call	0x980	; 0x980 <__gtsf2>
    6e4a:	18 16       	cp	r1, r24
    6e4c:	0c f0       	brlt	.+2      	; 0x6e50 <lcd_init+0x296>
    6e4e:	7b c0       	rjmp	.+246    	; 0x6f46 <lcd_init+0x38c>
	{
		_delay_ms(__us / 1000.0);
    6e50:	6d 89       	ldd	r22, Y+21	; 0x15
    6e52:	7e 89       	ldd	r23, Y+22	; 0x16
    6e54:	8f 89       	ldd	r24, Y+23	; 0x17
    6e56:	98 8d       	ldd	r25, Y+24	; 0x18
    6e58:	20 e0       	ldi	r18, 0x00	; 0
    6e5a:	30 e0       	ldi	r19, 0x00	; 0
    6e5c:	4a e7       	ldi	r20, 0x7A	; 122
    6e5e:	54 e4       	ldi	r21, 0x44	; 68
    6e60:	0e 94 14 04 	call	0x828	; 0x828 <__divsf3>
    6e64:	dc 01       	movw	r26, r24
    6e66:	cb 01       	movw	r24, r22
    6e68:	8c 87       	std	Y+12, r24	; 0x0c
    6e6a:	9d 87       	std	Y+13, r25	; 0x0d
    6e6c:	ae 87       	std	Y+14, r26	; 0x0e
    6e6e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6e70:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e72:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e74:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e76:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e78:	20 e0       	ldi	r18, 0x00	; 0
    6e7a:	30 e0       	ldi	r19, 0x00	; 0
    6e7c:	4a ef       	ldi	r20, 0xFA	; 250
    6e7e:	54 e4       	ldi	r21, 0x44	; 68
    6e80:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6e84:	dc 01       	movw	r26, r24
    6e86:	cb 01       	movw	r24, r22
    6e88:	88 87       	std	Y+8, r24	; 0x08
    6e8a:	99 87       	std	Y+9, r25	; 0x09
    6e8c:	aa 87       	std	Y+10, r26	; 0x0a
    6e8e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    6e90:	68 85       	ldd	r22, Y+8	; 0x08
    6e92:	79 85       	ldd	r23, Y+9	; 0x09
    6e94:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e96:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e98:	20 e0       	ldi	r18, 0x00	; 0
    6e9a:	30 e0       	ldi	r19, 0x00	; 0
    6e9c:	40 e8       	ldi	r20, 0x80	; 128
    6e9e:	5f e3       	ldi	r21, 0x3F	; 63
    6ea0:	0e 94 20 05 	call	0xa40	; 0xa40 <__ltsf2>
    6ea4:	88 23       	and	r24, r24
    6ea6:	2c f4       	brge	.+10     	; 0x6eb2 <lcd_init+0x2f8>
		__ticks = 1;
    6ea8:	81 e0       	ldi	r24, 0x01	; 1
    6eaa:	90 e0       	ldi	r25, 0x00	; 0
    6eac:	9f 83       	std	Y+7, r25	; 0x07
    6eae:	8e 83       	std	Y+6, r24	; 0x06
    6eb0:	3f c0       	rjmp	.+126    	; 0x6f30 <lcd_init+0x376>
	else if (__tmp > 65535)
    6eb2:	68 85       	ldd	r22, Y+8	; 0x08
    6eb4:	79 85       	ldd	r23, Y+9	; 0x09
    6eb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    6eb8:	9b 85       	ldd	r25, Y+11	; 0x0b
    6eba:	20 e0       	ldi	r18, 0x00	; 0
    6ebc:	3f ef       	ldi	r19, 0xFF	; 255
    6ebe:	4f e7       	ldi	r20, 0x7F	; 127
    6ec0:	57 e4       	ldi	r21, 0x47	; 71
    6ec2:	0e 94 c0 04 	call	0x980	; 0x980 <__gtsf2>
    6ec6:	18 16       	cp	r1, r24
    6ec8:	4c f5       	brge	.+82     	; 0x6f1c <lcd_init+0x362>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6eca:	6c 85       	ldd	r22, Y+12	; 0x0c
    6ecc:	7d 85       	ldd	r23, Y+13	; 0x0d
    6ece:	8e 85       	ldd	r24, Y+14	; 0x0e
    6ed0:	9f 85       	ldd	r25, Y+15	; 0x0f
    6ed2:	20 e0       	ldi	r18, 0x00	; 0
    6ed4:	30 e0       	ldi	r19, 0x00	; 0
    6ed6:	40 e2       	ldi	r20, 0x20	; 32
    6ed8:	51 e4       	ldi	r21, 0x41	; 65
    6eda:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6ede:	dc 01       	movw	r26, r24
    6ee0:	cb 01       	movw	r24, r22
    6ee2:	bc 01       	movw	r22, r24
    6ee4:	cd 01       	movw	r24, r26
    6ee6:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6eea:	dc 01       	movw	r26, r24
    6eec:	cb 01       	movw	r24, r22
    6eee:	9f 83       	std	Y+7, r25	; 0x07
    6ef0:	8e 83       	std	Y+6, r24	; 0x06
    6ef2:	0f c0       	rjmp	.+30     	; 0x6f12 <lcd_init+0x358>
    6ef4:	88 ec       	ldi	r24, 0xC8	; 200
    6ef6:	90 e0       	ldi	r25, 0x00	; 0
    6ef8:	9d 83       	std	Y+5, r25	; 0x05
    6efa:	8c 83       	std	Y+4, r24	; 0x04
    6efc:	8c 81       	ldd	r24, Y+4	; 0x04
    6efe:	9d 81       	ldd	r25, Y+5	; 0x05
    6f00:	01 97       	sbiw	r24, 0x01	; 1
    6f02:	f1 f7       	brne	.-4      	; 0x6f00 <lcd_init+0x346>
    6f04:	9d 83       	std	Y+5, r25	; 0x05
    6f06:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6f08:	8e 81       	ldd	r24, Y+6	; 0x06
    6f0a:	9f 81       	ldd	r25, Y+7	; 0x07
    6f0c:	01 97       	sbiw	r24, 0x01	; 1
    6f0e:	9f 83       	std	Y+7, r25	; 0x07
    6f10:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6f12:	8e 81       	ldd	r24, Y+6	; 0x06
    6f14:	9f 81       	ldd	r25, Y+7	; 0x07
    6f16:	00 97       	sbiw	r24, 0x00	; 0
    6f18:	69 f7       	brne	.-38     	; 0x6ef4 <lcd_init+0x33a>
    6f1a:	24 c0       	rjmp	.+72     	; 0x6f64 <lcd_init+0x3aa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6f1c:	68 85       	ldd	r22, Y+8	; 0x08
    6f1e:	79 85       	ldd	r23, Y+9	; 0x09
    6f20:	8a 85       	ldd	r24, Y+10	; 0x0a
    6f22:	9b 85       	ldd	r25, Y+11	; 0x0b
    6f24:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6f28:	dc 01       	movw	r26, r24
    6f2a:	cb 01       	movw	r24, r22
    6f2c:	9f 83       	std	Y+7, r25	; 0x07
    6f2e:	8e 83       	std	Y+6, r24	; 0x06
    6f30:	8e 81       	ldd	r24, Y+6	; 0x06
    6f32:	9f 81       	ldd	r25, Y+7	; 0x07
    6f34:	9b 83       	std	Y+3, r25	; 0x03
    6f36:	8a 83       	std	Y+2, r24	; 0x02
    6f38:	8a 81       	ldd	r24, Y+2	; 0x02
    6f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    6f3c:	01 97       	sbiw	r24, 0x01	; 1
    6f3e:	f1 f7       	brne	.-4      	; 0x6f3c <lcd_init+0x382>
    6f40:	9b 83       	std	Y+3, r25	; 0x03
    6f42:	8a 83       	std	Y+2, r24	; 0x02
    6f44:	0f c0       	rjmp	.+30     	; 0x6f64 <lcd_init+0x3aa>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6f46:	69 89       	ldd	r22, Y+17	; 0x11
    6f48:	7a 89       	ldd	r23, Y+18	; 0x12
    6f4a:	8b 89       	ldd	r24, Y+19	; 0x13
    6f4c:	9c 89       	ldd	r25, Y+20	; 0x14
    6f4e:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    6f52:	dc 01       	movw	r26, r24
    6f54:	cb 01       	movw	r24, r22
    6f56:	88 8b       	std	Y+16, r24	; 0x10
    6f58:	88 89       	ldd	r24, Y+16	; 0x10
    6f5a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6f5c:	89 81       	ldd	r24, Y+1	; 0x01
    6f5e:	8a 95       	dec	r24
    6f60:	f1 f7       	brne	.-4      	; 0x6f5e <lcd_init+0x3a4>
    6f62:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(200);
	lcd_write_command(0x30);
    6f64:	80 e3       	ldi	r24, 0x30	; 48
    6f66:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>

	#ifdef EIGHT_BIT_MODE
	//select 8-bit mode
	lcd_write_command(function_set_8bit);
    6f6a:	88 e3       	ldi	r24, 0x38	; 56
    6f6c:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
	lcd_write_command(0x02);
	lcd_write_command(function_set_4bit);
	lcd_write_command(0x08);
	#endif
	//display off
	lcd_write_command(display_off_cursor_off);
    6f70:	88 e0       	ldi	r24, 0x08	; 8
    6f72:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
	//clear display
	lcd_clear();
    6f76:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
	//entry mode set
	lcd_write_command(Entry_mode);
    6f7a:	86 e0       	ldi	r24, 0x06	; 6
    6f7c:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
	//display on cursor blinking
	lcd_write_command(Display_on_Cursor_blinking);
    6f80:	8f e0       	ldi	r24, 0x0F	; 15
    6f82:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
}
    6f86:	e4 96       	adiw	r28, 0x34	; 52
    6f88:	0f b6       	in	r0, 0x3f	; 63
    6f8a:	f8 94       	cli
    6f8c:	de bf       	out	0x3e, r29	; 62
    6f8e:	0f be       	out	0x3f, r0	; 63
    6f90:	cd bf       	out	0x3d, r28	; 61
    6f92:	cf 91       	pop	r28
    6f94:	df 91       	pop	r29
    6f96:	08 95       	ret

00006f98 <lcd_kick>:


void lcd_kick(void)
{
    6f98:	df 93       	push	r29
    6f9a:	cf 93       	push	r28
    6f9c:	cd b7       	in	r28, 0x3d	; 61
    6f9e:	de b7       	in	r29, 0x3e	; 62
    6fa0:	2e 97       	sbiw	r28, 0x0e	; 14
    6fa2:	0f b6       	in	r0, 0x3f	; 63
    6fa4:	f8 94       	cli
    6fa6:	de bf       	out	0x3e, r29	; 62
    6fa8:	0f be       	out	0x3f, r0	; 63
    6faa:	cd bf       	out	0x3d, r28	; 61
	Set_bit(lcd_ctrl_port, EN);
    6fac:	a2 e3       	ldi	r26, 0x32	; 50
    6fae:	b0 e0       	ldi	r27, 0x00	; 0
    6fb0:	e2 e3       	ldi	r30, 0x32	; 50
    6fb2:	f0 e0       	ldi	r31, 0x00	; 0
    6fb4:	80 81       	ld	r24, Z
    6fb6:	84 60       	ori	r24, 0x04	; 4
    6fb8:	8c 93       	st	X, r24
    6fba:	80 e0       	ldi	r24, 0x00	; 0
    6fbc:	90 e0       	ldi	r25, 0x00	; 0
    6fbe:	a0 ea       	ldi	r26, 0xA0	; 160
    6fc0:	b1 e4       	ldi	r27, 0x41	; 65
    6fc2:	8b 87       	std	Y+11, r24	; 0x0b
    6fc4:	9c 87       	std	Y+12, r25	; 0x0c
    6fc6:	ad 87       	std	Y+13, r26	; 0x0d
    6fc8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6fca:	6b 85       	ldd	r22, Y+11	; 0x0b
    6fcc:	7c 85       	ldd	r23, Y+12	; 0x0c
    6fce:	8d 85       	ldd	r24, Y+13	; 0x0d
    6fd0:	9e 85       	ldd	r25, Y+14	; 0x0e
    6fd2:	20 e0       	ldi	r18, 0x00	; 0
    6fd4:	30 e0       	ldi	r19, 0x00	; 0
    6fd6:	4a ef       	ldi	r20, 0xFA	; 250
    6fd8:	54 e4       	ldi	r21, 0x44	; 68
    6fda:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    6fde:	dc 01       	movw	r26, r24
    6fe0:	cb 01       	movw	r24, r22
    6fe2:	8f 83       	std	Y+7, r24	; 0x07
    6fe4:	98 87       	std	Y+8, r25	; 0x08
    6fe6:	a9 87       	std	Y+9, r26	; 0x09
    6fe8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6fea:	6f 81       	ldd	r22, Y+7	; 0x07
    6fec:	78 85       	ldd	r23, Y+8	; 0x08
    6fee:	89 85       	ldd	r24, Y+9	; 0x09
    6ff0:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ff2:	20 e0       	ldi	r18, 0x00	; 0
    6ff4:	30 e0       	ldi	r19, 0x00	; 0
    6ff6:	40 e8       	ldi	r20, 0x80	; 128
    6ff8:	5f e3       	ldi	r21, 0x3F	; 63
    6ffa:	0e 94 20 05 	call	0xa40	; 0xa40 <__ltsf2>
    6ffe:	88 23       	and	r24, r24
    7000:	2c f4       	brge	.+10     	; 0x700c <lcd_kick+0x74>
		__ticks = 1;
    7002:	81 e0       	ldi	r24, 0x01	; 1
    7004:	90 e0       	ldi	r25, 0x00	; 0
    7006:	9e 83       	std	Y+6, r25	; 0x06
    7008:	8d 83       	std	Y+5, r24	; 0x05
    700a:	3f c0       	rjmp	.+126    	; 0x708a <lcd_kick+0xf2>
	else if (__tmp > 65535)
    700c:	6f 81       	ldd	r22, Y+7	; 0x07
    700e:	78 85       	ldd	r23, Y+8	; 0x08
    7010:	89 85       	ldd	r24, Y+9	; 0x09
    7012:	9a 85       	ldd	r25, Y+10	; 0x0a
    7014:	20 e0       	ldi	r18, 0x00	; 0
    7016:	3f ef       	ldi	r19, 0xFF	; 255
    7018:	4f e7       	ldi	r20, 0x7F	; 127
    701a:	57 e4       	ldi	r21, 0x47	; 71
    701c:	0e 94 c0 04 	call	0x980	; 0x980 <__gtsf2>
    7020:	18 16       	cp	r1, r24
    7022:	4c f5       	brge	.+82     	; 0x7076 <lcd_kick+0xde>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7024:	6b 85       	ldd	r22, Y+11	; 0x0b
    7026:	7c 85       	ldd	r23, Y+12	; 0x0c
    7028:	8d 85       	ldd	r24, Y+13	; 0x0d
    702a:	9e 85       	ldd	r25, Y+14	; 0x0e
    702c:	20 e0       	ldi	r18, 0x00	; 0
    702e:	30 e0       	ldi	r19, 0x00	; 0
    7030:	40 e2       	ldi	r20, 0x20	; 32
    7032:	51 e4       	ldi	r21, 0x41	; 65
    7034:	0e 94 1a 03 	call	0x634	; 0x634 <__mulsf3>
    7038:	dc 01       	movw	r26, r24
    703a:	cb 01       	movw	r24, r22
    703c:	bc 01       	movw	r22, r24
    703e:	cd 01       	movw	r24, r26
    7040:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    7044:	dc 01       	movw	r26, r24
    7046:	cb 01       	movw	r24, r22
    7048:	9e 83       	std	Y+6, r25	; 0x06
    704a:	8d 83       	std	Y+5, r24	; 0x05
    704c:	0f c0       	rjmp	.+30     	; 0x706c <lcd_kick+0xd4>
    704e:	88 ec       	ldi	r24, 0xC8	; 200
    7050:	90 e0       	ldi	r25, 0x00	; 0
    7052:	9c 83       	std	Y+4, r25	; 0x04
    7054:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7056:	8b 81       	ldd	r24, Y+3	; 0x03
    7058:	9c 81       	ldd	r25, Y+4	; 0x04
    705a:	01 97       	sbiw	r24, 0x01	; 1
    705c:	f1 f7       	brne	.-4      	; 0x705a <lcd_kick+0xc2>
    705e:	9c 83       	std	Y+4, r25	; 0x04
    7060:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7062:	8d 81       	ldd	r24, Y+5	; 0x05
    7064:	9e 81       	ldd	r25, Y+6	; 0x06
    7066:	01 97       	sbiw	r24, 0x01	; 1
    7068:	9e 83       	std	Y+6, r25	; 0x06
    706a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    706c:	8d 81       	ldd	r24, Y+5	; 0x05
    706e:	9e 81       	ldd	r25, Y+6	; 0x06
    7070:	00 97       	sbiw	r24, 0x00	; 0
    7072:	69 f7       	brne	.-38     	; 0x704e <lcd_kick+0xb6>
    7074:	14 c0       	rjmp	.+40     	; 0x709e <lcd_kick+0x106>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7076:	6f 81       	ldd	r22, Y+7	; 0x07
    7078:	78 85       	ldd	r23, Y+8	; 0x08
    707a:	89 85       	ldd	r24, Y+9	; 0x09
    707c:	9a 85       	ldd	r25, Y+10	; 0x0a
    707e:	0e 94 44 01 	call	0x288	; 0x288 <__fixunssfsi>
    7082:	dc 01       	movw	r26, r24
    7084:	cb 01       	movw	r24, r22
    7086:	9e 83       	std	Y+6, r25	; 0x06
    7088:	8d 83       	std	Y+5, r24	; 0x05
    708a:	8d 81       	ldd	r24, Y+5	; 0x05
    708c:	9e 81       	ldd	r25, Y+6	; 0x06
    708e:	9a 83       	std	Y+2, r25	; 0x02
    7090:	89 83       	std	Y+1, r24	; 0x01
    7092:	89 81       	ldd	r24, Y+1	; 0x01
    7094:	9a 81       	ldd	r25, Y+2	; 0x02
    7096:	01 97       	sbiw	r24, 0x01	; 1
    7098:	f1 f7       	brne	.-4      	; 0x7096 <lcd_kick+0xfe>
    709a:	9a 83       	std	Y+2, r25	; 0x02
    709c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
	Clear_bit(lcd_ctrl_port, EN);
    709e:	a2 e3       	ldi	r26, 0x32	; 50
    70a0:	b0 e0       	ldi	r27, 0x00	; 0
    70a2:	e2 e3       	ldi	r30, 0x32	; 50
    70a4:	f0 e0       	ldi	r31, 0x00	; 0
    70a6:	80 81       	ld	r24, Z
    70a8:	8b 7f       	andi	r24, 0xFB	; 251
    70aa:	8c 93       	st	X, r24
}
    70ac:	2e 96       	adiw	r28, 0x0e	; 14
    70ae:	0f b6       	in	r0, 0x3f	; 63
    70b0:	f8 94       	cli
    70b2:	de bf       	out	0x3e, r29	; 62
    70b4:	0f be       	out	0x3f, r0	; 63
    70b6:	cd bf       	out	0x3d, r28	; 61
    70b8:	cf 91       	pop	r28
    70ba:	df 91       	pop	r29
    70bc:	08 95       	ret

000070be <lcd_write_char>:

void lcd_write_char(unsigned char data)
{
    70be:	df 93       	push	r29
    70c0:	cf 93       	push	r28
    70c2:	0f 92       	push	r0
    70c4:	cd b7       	in	r28, 0x3d	; 61
    70c6:	de b7       	in	r29, 0x3e	; 62
    70c8:	89 83       	std	Y+1, r24	; 0x01
	#ifdef EIGHT_BIT_MODE
	lcd_is_busy();
    70ca:	0e 94 c1 38 	call	0x7182	; 0x7182 <lcd_is_busy>
	//make LCD in write mode
	set_RS;
    70ce:	a2 e3       	ldi	r26, 0x32	; 50
    70d0:	b0 e0       	ldi	r27, 0x00	; 0
    70d2:	e2 e3       	ldi	r30, 0x32	; 50
    70d4:	f0 e0       	ldi	r31, 0x00	; 0
    70d6:	80 81       	ld	r24, Z
    70d8:	81 60       	ori	r24, 0x01	; 1
    70da:	8c 93       	st	X, r24
	clear_RW;
    70dc:	a2 e3       	ldi	r26, 0x32	; 50
    70de:	b0 e0       	ldi	r27, 0x00	; 0
    70e0:	e2 e3       	ldi	r30, 0x32	; 50
    70e2:	f0 e0       	ldi	r31, 0x00	; 0
    70e4:	80 81       	ld	r24, Z
    70e6:	8d 7f       	andi	r24, 0xFD	; 253
    70e8:	8c 93       	st	X, r24
	//write data
	lcd_data_port = data;
    70ea:	e5 e3       	ldi	r30, 0x35	; 53
    70ec:	f0 e0       	ldi	r31, 0x00	; 0
    70ee:	89 81       	ldd	r24, Y+1	; 0x01
    70f0:	80 83       	st	Z, r24
	lcd_kick();
    70f2:	0e 94 cc 37 	call	0x6f98	; 0x6f98 <lcd_kick>
	set_RS;
	clear_RW;
	lcd_data_port = ((lcd_data_port & 0x0F) | (data << 4));
	lcd_kick();
	#endif
}
    70f6:	0f 90       	pop	r0
    70f8:	cf 91       	pop	r28
    70fa:	df 91       	pop	r29
    70fc:	08 95       	ret

000070fe <lcd_write_string>:

void lcd_write_string(char *str)
{
    70fe:	df 93       	push	r29
    7100:	cf 93       	push	r28
    7102:	00 d0       	rcall	.+0      	; 0x7104 <lcd_write_string+0x6>
    7104:	00 d0       	rcall	.+0      	; 0x7106 <lcd_write_string+0x8>
    7106:	cd b7       	in	r28, 0x3d	; 61
    7108:	de b7       	in	r29, 0x3e	; 62
    710a:	9c 83       	std	Y+4, r25	; 0x04
    710c:	8b 83       	std	Y+3, r24	; 0x03
	int character_counter = 0;
    710e:	1a 82       	std	Y+2, r1	; 0x02
    7110:	19 82       	std	Y+1, r1	; 0x01
    7112:	2b c0       	rjmp	.+86     	; 0x716a <lcd_write_string+0x6c>
	while(*str != '\0')
	{
		character_counter++;
    7114:	89 81       	ldd	r24, Y+1	; 0x01
    7116:	9a 81       	ldd	r25, Y+2	; 0x02
    7118:	01 96       	adiw	r24, 0x01	; 1
    711a:	9a 83       	std	Y+2, r25	; 0x02
    711c:	89 83       	std	Y+1, r24	; 0x01
		if(character_counter == 17)
    711e:	89 81       	ldd	r24, Y+1	; 0x01
    7120:	9a 81       	ldd	r25, Y+2	; 0x02
    7122:	81 31       	cpi	r24, 0x11	; 17
    7124:	91 05       	cpc	r25, r1
    7126:	39 f4       	brne	.+14     	; 0x7136 <lcd_write_string+0x38>
		{
			//go to second line position 0
			lcd_goto_xy(2,0);
    7128:	82 e0       	ldi	r24, 0x02	; 2
    712a:	90 e0       	ldi	r25, 0x00	; 0
    712c:	60 e0       	ldi	r22, 0x00	; 0
    712e:	70 e0       	ldi	r23, 0x00	; 0
    7130:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
    7134:	10 c0       	rjmp	.+32     	; 0x7156 <lcd_write_string+0x58>
		}
		else if(character_counter > 32)
    7136:	89 81       	ldd	r24, Y+1	; 0x01
    7138:	9a 81       	ldd	r25, Y+2	; 0x02
    713a:	81 32       	cpi	r24, 0x21	; 33
    713c:	91 05       	cpc	r25, r1
    713e:	5c f0       	brlt	.+22     	; 0x7156 <lcd_write_string+0x58>
		{
			//clear display
			lcd_write_command(clear_display);
    7140:	81 e0       	ldi	r24, 0x01	; 1
    7142:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
			//go to first line position 0
			lcd_goto_xy(1,0);
    7146:	81 e0       	ldi	r24, 0x01	; 1
    7148:	90 e0       	ldi	r25, 0x00	; 0
    714a:	60 e0       	ldi	r22, 0x00	; 0
    714c:	70 e0       	ldi	r23, 0x00	; 0
    714e:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
			character_counter = 0;
    7152:	1a 82       	std	Y+2, r1	; 0x02
    7154:	19 82       	std	Y+1, r1	; 0x01
		}
		lcd_write_char(*str);
    7156:	eb 81       	ldd	r30, Y+3	; 0x03
    7158:	fc 81       	ldd	r31, Y+4	; 0x04
    715a:	80 81       	ld	r24, Z
    715c:	0e 94 5f 38 	call	0x70be	; 0x70be <lcd_write_char>
		str++;
    7160:	8b 81       	ldd	r24, Y+3	; 0x03
    7162:	9c 81       	ldd	r25, Y+4	; 0x04
    7164:	01 96       	adiw	r24, 0x01	; 1
    7166:	9c 83       	std	Y+4, r25	; 0x04
    7168:	8b 83       	std	Y+3, r24	; 0x03
}

void lcd_write_string(char *str)
{
	int character_counter = 0;
	while(*str != '\0')
    716a:	eb 81       	ldd	r30, Y+3	; 0x03
    716c:	fc 81       	ldd	r31, Y+4	; 0x04
    716e:	80 81       	ld	r24, Z
    7170:	88 23       	and	r24, r24
    7172:	81 f6       	brne	.-96     	; 0x7114 <lcd_write_string+0x16>
			character_counter = 0;
		}
		lcd_write_char(*str);
		str++;
	}
}
    7174:	0f 90       	pop	r0
    7176:	0f 90       	pop	r0
    7178:	0f 90       	pop	r0
    717a:	0f 90       	pop	r0
    717c:	cf 91       	pop	r28
    717e:	df 91       	pop	r29
    7180:	08 95       	ret

00007182 <lcd_is_busy>:

void lcd_is_busy(void)
{
    7182:	df 93       	push	r29
    7184:	cf 93       	push	r28
    7186:	cd b7       	in	r28, 0x3d	; 61
    7188:	de b7       	in	r29, 0x3e	; 62
	//make data lines as input
	lcd_data_dir &= ~(0xFF<<Data_shift);
    718a:	a4 e3       	ldi	r26, 0x34	; 52
    718c:	b0 e0       	ldi	r27, 0x00	; 0
    718e:	e4 e3       	ldi	r30, 0x34	; 52
    7190:	f0 e0       	ldi	r31, 0x00	; 0
    7192:	80 81       	ld	r24, Z
    7194:	8f 70       	andi	r24, 0x0F	; 15
    7196:	8c 93       	st	X, r24
	//make LCD in read mode RS = 0, RW = 1
	Clear_bit(lcd_ctrl_port, RS);
    7198:	a2 e3       	ldi	r26, 0x32	; 50
    719a:	b0 e0       	ldi	r27, 0x00	; 0
    719c:	e2 e3       	ldi	r30, 0x32	; 50
    719e:	f0 e0       	ldi	r31, 0x00	; 0
    71a0:	80 81       	ld	r24, Z
    71a2:	8e 7f       	andi	r24, 0xFE	; 254
    71a4:	8c 93       	st	X, r24
	Set_bit(lcd_ctrl_port, RW);
    71a6:	a2 e3       	ldi	r26, 0x32	; 50
    71a8:	b0 e0       	ldi	r27, 0x00	; 0
    71aa:	e2 e3       	ldi	r30, 0x32	; 50
    71ac:	f0 e0       	ldi	r31, 0x00	; 0
    71ae:	80 81       	ld	r24, Z
    71b0:	82 60       	ori	r24, 0x02	; 2
    71b2:	8c 93       	st	X, r24
	lcd_kick();
    71b4:	0e 94 cc 37 	call	0x6f98	; 0x6f98 <lcd_kick>
	//make data lines as output
	lcd_data_dir |= (0xFF<<Data_shift);
    71b8:	a4 e3       	ldi	r26, 0x34	; 52
    71ba:	b0 e0       	ldi	r27, 0x00	; 0
    71bc:	e4 e3       	ldi	r30, 0x34	; 52
    71be:	f0 e0       	ldi	r31, 0x00	; 0
    71c0:	80 81       	ld	r24, Z
    71c2:	80 6f       	ori	r24, 0xF0	; 240
    71c4:	8c 93       	st	X, r24
}
    71c6:	cf 91       	pop	r28
    71c8:	df 91       	pop	r29
    71ca:	08 95       	ret

000071cc <lcd_write_command>:

void lcd_write_command(unsigned char command)
{
    71cc:	df 93       	push	r29
    71ce:	cf 93       	push	r28
    71d0:	0f 92       	push	r0
    71d2:	cd b7       	in	r28, 0x3d	; 61
    71d4:	de b7       	in	r29, 0x3e	; 62
    71d6:	89 83       	std	Y+1, r24	; 0x01
	#ifdef EIGHT_BIT_MODE
	lcd_is_busy();
    71d8:	0e 94 c1 38 	call	0x7182	; 0x7182 <lcd_is_busy>
	//switch to write mode and select instruction reg to send command
	clear_RS;
    71dc:	a2 e3       	ldi	r26, 0x32	; 50
    71de:	b0 e0       	ldi	r27, 0x00	; 0
    71e0:	e2 e3       	ldi	r30, 0x32	; 50
    71e2:	f0 e0       	ldi	r31, 0x00	; 0
    71e4:	80 81       	ld	r24, Z
    71e6:	8e 7f       	andi	r24, 0xFE	; 254
    71e8:	8c 93       	st	X, r24
	clear_RW;
    71ea:	a2 e3       	ldi	r26, 0x32	; 50
    71ec:	b0 e0       	ldi	r27, 0x00	; 0
    71ee:	e2 e3       	ldi	r30, 0x32	; 50
    71f0:	f0 e0       	ldi	r31, 0x00	; 0
    71f2:	80 81       	ld	r24, Z
    71f4:	8d 7f       	andi	r24, 0xFD	; 253
    71f6:	8c 93       	st	X, r24
	lcd_data_port = command;
    71f8:	e5 e3       	ldi	r30, 0x35	; 53
    71fa:	f0 e0       	ldi	r31, 0x00	; 0
    71fc:	89 81       	ldd	r24, Y+1	; 0x01
    71fe:	80 83       	st	Z, r24
	lcd_kick();
    7200:	0e 94 cc 37 	call	0x6f98	; 0x6f98 <lcd_kick>
	clear_RS;
	clear_RW;
	lcd_data_port = ((lcd_data_port & 0x0F) | (command << 4));
	lcd_kick();
	#endif
}
    7204:	0f 90       	pop	r0
    7206:	cf 91       	pop	r28
    7208:	df 91       	pop	r29
    720a:	08 95       	ret

0000720c <lcd_goto_xy>:


void lcd_goto_xy(int line, int position)
{
    720c:	df 93       	push	r29
    720e:	cf 93       	push	r28
    7210:	00 d0       	rcall	.+0      	; 0x7212 <lcd_goto_xy+0x6>
    7212:	00 d0       	rcall	.+0      	; 0x7214 <lcd_goto_xy+0x8>
    7214:	cd b7       	in	r28, 0x3d	; 61
    7216:	de b7       	in	r29, 0x3e	; 62
    7218:	9a 83       	std	Y+2, r25	; 0x02
    721a:	89 83       	std	Y+1, r24	; 0x01
    721c:	7c 83       	std	Y+4, r23	; 0x04
    721e:	6b 83       	std	Y+3, r22	; 0x03
	if(line == 1)
    7220:	89 81       	ldd	r24, Y+1	; 0x01
    7222:	9a 81       	ldd	r25, Y+2	; 0x02
    7224:	81 30       	cpi	r24, 0x01	; 1
    7226:	91 05       	cpc	r25, r1
    7228:	71 f4       	brne	.+28     	; 0x7246 <lcd_goto_xy+0x3a>
	{
		if(position >= 0 && position < 16)
    722a:	8b 81       	ldd	r24, Y+3	; 0x03
    722c:	9c 81       	ldd	r25, Y+4	; 0x04
    722e:	99 23       	and	r25, r25
    7230:	e4 f0       	brlt	.+56     	; 0x726a <lcd_goto_xy+0x5e>
    7232:	8b 81       	ldd	r24, Y+3	; 0x03
    7234:	9c 81       	ldd	r25, Y+4	; 0x04
    7236:	80 31       	cpi	r24, 0x10	; 16
    7238:	91 05       	cpc	r25, r1
    723a:	bc f4       	brge	.+46     	; 0x726a <lcd_goto_xy+0x5e>
		{
			lcd_write_command(cursor_first_line + position);
    723c:	8b 81       	ldd	r24, Y+3	; 0x03
    723e:	80 58       	subi	r24, 0x80	; 128
    7240:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
    7244:	12 c0       	rjmp	.+36     	; 0x726a <lcd_goto_xy+0x5e>
		}
	}

	else if (line == 2)
    7246:	89 81       	ldd	r24, Y+1	; 0x01
    7248:	9a 81       	ldd	r25, Y+2	; 0x02
    724a:	82 30       	cpi	r24, 0x02	; 2
    724c:	91 05       	cpc	r25, r1
    724e:	69 f4       	brne	.+26     	; 0x726a <lcd_goto_xy+0x5e>
	{
		if(position >= 0 && position < 16)
    7250:	8b 81       	ldd	r24, Y+3	; 0x03
    7252:	9c 81       	ldd	r25, Y+4	; 0x04
    7254:	99 23       	and	r25, r25
    7256:	4c f0       	brlt	.+18     	; 0x726a <lcd_goto_xy+0x5e>
    7258:	8b 81       	ldd	r24, Y+3	; 0x03
    725a:	9c 81       	ldd	r25, Y+4	; 0x04
    725c:	80 31       	cpi	r24, 0x10	; 16
    725e:	91 05       	cpc	r25, r1
    7260:	24 f4       	brge	.+8      	; 0x726a <lcd_goto_xy+0x5e>
		{
			lcd_write_command(cursor_second_line + position);
    7262:	8b 81       	ldd	r24, Y+3	; 0x03
    7264:	80 54       	subi	r24, 0x40	; 64
    7266:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
		}
	}
}
    726a:	0f 90       	pop	r0
    726c:	0f 90       	pop	r0
    726e:	0f 90       	pop	r0
    7270:	0f 90       	pop	r0
    7272:	cf 91       	pop	r28
    7274:	df 91       	pop	r29
    7276:	08 95       	ret

00007278 <lcd_clear>:

void lcd_clear(void)
{
    7278:	df 93       	push	r29
    727a:	cf 93       	push	r28
    727c:	cd b7       	in	r28, 0x3d	; 61
    727e:	de b7       	in	r29, 0x3e	; 62
	lcd_write_command(clear_display);
    7280:	81 e0       	ldi	r24, 0x01	; 1
    7282:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
}
    7286:	cf 91       	pop	r28
    7288:	df 91       	pop	r29
    728a:	08 95       	ret

0000728c <lcd_shift_right>:

void lcd_shift_right(void)
{
    728c:	df 93       	push	r29
    728e:	cf 93       	push	r28
    7290:	cd b7       	in	r28, 0x3d	; 61
    7292:	de b7       	in	r29, 0x3e	; 62
	lcd_write_command(shift_display_right);
    7294:	8c e1       	ldi	r24, 0x1C	; 28
    7296:	0e 94 e6 38 	call	0x71cc	; 0x71cc <lcd_write_command>
}
    729a:	cf 91       	pop	r28
    729c:	df 91       	pop	r29
    729e:	08 95       	ret

000072a0 <lcd_Write_Number>:


void lcd_Write_Number(unsigned long number)
{
    72a0:	df 93       	push	r29
    72a2:	cf 93       	push	r28
    72a4:	cd b7       	in	r28, 0x3d	; 61
    72a6:	de b7       	in	r29, 0x3e	; 62
    72a8:	69 97       	sbiw	r28, 0x19	; 25
    72aa:	0f b6       	in	r0, 0x3f	; 63
    72ac:	f8 94       	cli
    72ae:	de bf       	out	0x3e, r29	; 62
    72b0:	0f be       	out	0x3f, r0	; 63
    72b2:	cd bf       	out	0x3d, r28	; 61
    72b4:	6e 8b       	std	Y+22, r22	; 0x16
    72b6:	7f 8b       	std	Y+23, r23	; 0x17
    72b8:	88 8f       	std	Y+24, r24	; 0x18
    72ba:	99 8f       	std	Y+25, r25	; 0x19
	unsigned long temp_num = number;
    72bc:	8e 89       	ldd	r24, Y+22	; 0x16
    72be:	9f 89       	ldd	r25, Y+23	; 0x17
    72c0:	a8 8d       	ldd	r26, Y+24	; 0x18
    72c2:	b9 8d       	ldd	r27, Y+25	; 0x19
    72c4:	8f 83       	std	Y+7, r24	; 0x07
    72c6:	98 87       	std	Y+8, r25	; 0x08
    72c8:	a9 87       	std	Y+9, r26	; 0x09
    72ca:	ba 87       	std	Y+10, r27	; 0x0a
	unsigned int num_length = 0, i = 0, rem ;
    72cc:	1e 82       	std	Y+6, r1	; 0x06
    72ce:	1d 82       	std	Y+5, r1	; 0x05
    72d0:	1c 82       	std	Y+4, r1	; 0x04
    72d2:	1b 82       	std	Y+3, r1	; 0x03
	char str_arr[11];
	/* special handling for 0 */
	if (!number) {
    72d4:	8e 89       	ldd	r24, Y+22	; 0x16
    72d6:	9f 89       	ldd	r25, Y+23	; 0x17
    72d8:	a8 8d       	ldd	r26, Y+24	; 0x18
    72da:	b9 8d       	ldd	r27, Y+25	; 0x19
    72dc:	00 97       	sbiw	r24, 0x00	; 0
    72de:	a1 05       	cpc	r26, r1
    72e0:	b1 05       	cpc	r27, r1
    72e2:	d9 f4       	brne	.+54     	; 0x731a <lcd_Write_Number+0x7a>
		str_arr[0] = '0';
    72e4:	80 e3       	ldi	r24, 0x30	; 48
    72e6:	8b 87       	std	Y+11, r24	; 0x0b
		str_arr[1] = '\0';
    72e8:	1c 86       	std	Y+12, r1	; 0x0c
    72ea:	6c c0       	rjmp	.+216    	; 0x73c4 <lcd_Write_Number+0x124>
		goto exit;
	}
	//Calculate Length of number
	while(temp_num != 0)
	{
		temp_num /= 10;
    72ec:	8f 81       	ldd	r24, Y+7	; 0x07
    72ee:	98 85       	ldd	r25, Y+8	; 0x08
    72f0:	a9 85       	ldd	r26, Y+9	; 0x09
    72f2:	ba 85       	ldd	r27, Y+10	; 0x0a
    72f4:	2a e0       	ldi	r18, 0x0A	; 10
    72f6:	30 e0       	ldi	r19, 0x00	; 0
    72f8:	40 e0       	ldi	r20, 0x00	; 0
    72fa:	50 e0       	ldi	r21, 0x00	; 0
    72fc:	bc 01       	movw	r22, r24
    72fe:	cd 01       	movw	r24, r26
    7300:	0e 94 7d 42 	call	0x84fa	; 0x84fa <__udivmodsi4>
    7304:	da 01       	movw	r26, r20
    7306:	c9 01       	movw	r24, r18
    7308:	8f 83       	std	Y+7, r24	; 0x07
    730a:	98 87       	std	Y+8, r25	; 0x08
    730c:	a9 87       	std	Y+9, r26	; 0x09
    730e:	ba 87       	std	Y+10, r27	; 0x0a
		num_length++;
    7310:	8d 81       	ldd	r24, Y+5	; 0x05
    7312:	9e 81       	ldd	r25, Y+6	; 0x06
    7314:	01 96       	adiw	r24, 0x01	; 1
    7316:	9e 83       	std	Y+6, r25	; 0x06
    7318:	8d 83       	std	Y+5, r24	; 0x05
		str_arr[0] = '0';
		str_arr[1] = '\0';
		goto exit;
	}
	//Calculate Length of number
	while(temp_num != 0)
    731a:	8f 81       	ldd	r24, Y+7	; 0x07
    731c:	98 85       	ldd	r25, Y+8	; 0x08
    731e:	a9 85       	ldd	r26, Y+9	; 0x09
    7320:	ba 85       	ldd	r27, Y+10	; 0x0a
    7322:	00 97       	sbiw	r24, 0x00	; 0
    7324:	a1 05       	cpc	r26, r1
    7326:	b1 05       	cpc	r27, r1
    7328:	09 f7       	brne	.-62     	; 0x72ec <lcd_Write_Number+0x4c>
		temp_num /= 10;
		num_length++;
	}
	//split each digit of number
	//temp_num = number;
	for(i=0; i<num_length; i++)
    732a:	1c 82       	std	Y+4, r1	; 0x04
    732c:	1b 82       	std	Y+3, r1	; 0x03
    732e:	39 c0       	rjmp	.+114    	; 0x73a2 <lcd_Write_Number+0x102>
	{
		rem = number % 10;
    7330:	8e 89       	ldd	r24, Y+22	; 0x16
    7332:	9f 89       	ldd	r25, Y+23	; 0x17
    7334:	a8 8d       	ldd	r26, Y+24	; 0x18
    7336:	b9 8d       	ldd	r27, Y+25	; 0x19
    7338:	2a e0       	ldi	r18, 0x0A	; 10
    733a:	30 e0       	ldi	r19, 0x00	; 0
    733c:	40 e0       	ldi	r20, 0x00	; 0
    733e:	50 e0       	ldi	r21, 0x00	; 0
    7340:	bc 01       	movw	r22, r24
    7342:	cd 01       	movw	r24, r26
    7344:	0e 94 7d 42 	call	0x84fa	; 0x84fa <__udivmodsi4>
    7348:	dc 01       	movw	r26, r24
    734a:	cb 01       	movw	r24, r22
    734c:	9a 83       	std	Y+2, r25	; 0x02
    734e:	89 83       	std	Y+1, r24	; 0x01
		number = number / 10;
    7350:	8e 89       	ldd	r24, Y+22	; 0x16
    7352:	9f 89       	ldd	r25, Y+23	; 0x17
    7354:	a8 8d       	ldd	r26, Y+24	; 0x18
    7356:	b9 8d       	ldd	r27, Y+25	; 0x19
    7358:	2a e0       	ldi	r18, 0x0A	; 10
    735a:	30 e0       	ldi	r19, 0x00	; 0
    735c:	40 e0       	ldi	r20, 0x00	; 0
    735e:	50 e0       	ldi	r21, 0x00	; 0
    7360:	bc 01       	movw	r22, r24
    7362:	cd 01       	movw	r24, r26
    7364:	0e 94 7d 42 	call	0x84fa	; 0x84fa <__udivmodsi4>
    7368:	da 01       	movw	r26, r20
    736a:	c9 01       	movw	r24, r18
    736c:	8e 8b       	std	Y+22, r24	; 0x16
    736e:	9f 8b       	std	Y+23, r25	; 0x17
    7370:	a8 8f       	std	Y+24, r26	; 0x18
    7372:	b9 8f       	std	Y+25, r27	; 0x19
		str_arr[num_length - (i+1)] = rem + '0';
    7374:	8b 81       	ldd	r24, Y+3	; 0x03
    7376:	9c 81       	ldd	r25, Y+4	; 0x04
    7378:	9c 01       	movw	r18, r24
    737a:	20 95       	com	r18
    737c:	30 95       	com	r19
    737e:	8d 81       	ldd	r24, Y+5	; 0x05
    7380:	9e 81       	ldd	r25, Y+6	; 0x06
    7382:	28 0f       	add	r18, r24
    7384:	39 1f       	adc	r19, r25
    7386:	89 81       	ldd	r24, Y+1	; 0x01
    7388:	48 2f       	mov	r20, r24
    738a:	40 5d       	subi	r20, 0xD0	; 208
    738c:	ce 01       	movw	r24, r28
    738e:	0b 96       	adiw	r24, 0x0b	; 11
    7390:	fc 01       	movw	r30, r24
    7392:	e2 0f       	add	r30, r18
    7394:	f3 1f       	adc	r31, r19
    7396:	40 83       	st	Z, r20
		temp_num /= 10;
		num_length++;
	}
	//split each digit of number
	//temp_num = number;
	for(i=0; i<num_length; i++)
    7398:	8b 81       	ldd	r24, Y+3	; 0x03
    739a:	9c 81       	ldd	r25, Y+4	; 0x04
    739c:	01 96       	adiw	r24, 0x01	; 1
    739e:	9c 83       	std	Y+4, r25	; 0x04
    73a0:	8b 83       	std	Y+3, r24	; 0x03
    73a2:	2b 81       	ldd	r18, Y+3	; 0x03
    73a4:	3c 81       	ldd	r19, Y+4	; 0x04
    73a6:	8d 81       	ldd	r24, Y+5	; 0x05
    73a8:	9e 81       	ldd	r25, Y+6	; 0x06
    73aa:	28 17       	cp	r18, r24
    73ac:	39 07       	cpc	r19, r25
    73ae:	08 f4       	brcc	.+2      	; 0x73b2 <lcd_Write_Number+0x112>
    73b0:	bf cf       	rjmp	.-130    	; 0x7330 <lcd_Write_Number+0x90>
	{
		rem = number % 10;
		number = number / 10;
		str_arr[num_length - (i+1)] = rem + '0';
	}
	str_arr[i] = '\0';
    73b2:	8b 81       	ldd	r24, Y+3	; 0x03
    73b4:	9c 81       	ldd	r25, Y+4	; 0x04
    73b6:	9e 01       	movw	r18, r28
    73b8:	25 5f       	subi	r18, 0xF5	; 245
    73ba:	3f 4f       	sbci	r19, 0xFF	; 255
    73bc:	f9 01       	movw	r30, r18
    73be:	e8 0f       	add	r30, r24
    73c0:	f9 1f       	adc	r31, r25
    73c2:	10 82       	st	Z, r1
exit:
	lcd_write_string(str_arr);
    73c4:	ce 01       	movw	r24, r28
    73c6:	0b 96       	adiw	r24, 0x0b	; 11
    73c8:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
}
    73cc:	69 96       	adiw	r28, 0x19	; 25
    73ce:	0f b6       	in	r0, 0x3f	; 63
    73d0:	f8 94       	cli
    73d2:	de bf       	out	0x3e, r29	; 62
    73d4:	0f be       	out	0x3f, r0	; 63
    73d6:	cd bf       	out	0x3d, r28	; 61
    73d8:	cf 91       	pop	r28
    73da:	df 91       	pop	r29
    73dc:	08 95       	ret

000073de <keypad_init>:
// Array for keypad columns
int keypad_columns[] = {C0, C1, C2, C3};

// Initialization of the keypad
void keypad_init(void)
{
    73de:	df 93       	push	r29
    73e0:	cf 93       	push	r28
    73e2:	cd b7       	in	r28, 0x3d	; 61
    73e4:	de b7       	in	r29, 0x3e	; 62
	// Set rows of keypad to input
	KEYPAD_PORT_DDR_R &= ~((1 << R0) | (1 << R1) | (1 << R2) | (1 << R3));
    73e6:	aa e3       	ldi	r26, 0x3A	; 58
    73e8:	b0 e0       	ldi	r27, 0x00	; 0
    73ea:	ea e3       	ldi	r30, 0x3A	; 58
    73ec:	f0 e0       	ldi	r31, 0x00	; 0
    73ee:	80 81       	ld	r24, Z
    73f0:	80 7f       	andi	r24, 0xF0	; 240
    73f2:	8c 93       	st	X, r24

	// Set columns of keypad to output
	KEYPAD_PORT_DDR_R |= ((1 << C0) | (1 << C1) | (1 << C2) | (1 << C3));
    73f4:	aa e3       	ldi	r26, 0x3A	; 58
    73f6:	b0 e0       	ldi	r27, 0x00	; 0
    73f8:	ea e3       	ldi	r30, 0x3A	; 58
    73fa:	f0 e0       	ldi	r31, 0x00	; 0
    73fc:	80 81       	ld	r24, Z
    73fe:	80 6f       	ori	r24, 0xF0	; 240
    7400:	8c 93       	st	X, r24

	// Set Port Data Register to 1
	KEYPAD_PORT_DATA_R = 0xFF;
    7402:	eb e3       	ldi	r30, 0x3B	; 59
    7404:	f0 e0       	ldi	r31, 0x00	; 0
    7406:	8f ef       	ldi	r24, 0xFF	; 255
    7408:	80 83       	st	Z, r24
}
    740a:	cf 91       	pop	r28
    740c:	df 91       	pop	r29
    740e:	08 95       	ret

00007410 <keypad_getchar>:

// keypad get char function
// loop for rows and loop for columns also
// to know the button pressed in each ( row, column )
char keypad_getchar()
{
    7410:	df 93       	push	r29
    7412:	cf 93       	push	r28
    7414:	cd b7       	in	r28, 0x3d	; 61
    7416:	de b7       	in	r29, 0x3e	; 62
    7418:	27 97       	sbiw	r28, 0x07	; 7
    741a:	0f b6       	in	r0, 0x3f	; 63
    741c:	f8 94       	cli
    741e:	de bf       	out	0x3e, r29	; 62
    7420:	0f be       	out	0x3f, r0	; 63
    7422:	cd bf       	out	0x3d, r28	; 61
	int i, j;
	for (i = 0; i < 4; i++)
    7424:	1c 82       	std	Y+4, r1	; 0x04
    7426:	1b 82       	std	Y+3, r1	; 0x03
    7428:	37 c1       	rjmp	.+622    	; 0x7698 <keypad_getchar+0x288>
	{
		// Set all keypad columns to 1
		KEYPAD_PORT_DATA_R |= ((1 << keypad_columns[0]) | (1 << keypad_columns[1]) | (1 << keypad_columns[2]) | (1 << keypad_columns[3]));
    742a:	ab e3       	ldi	r26, 0x3B	; 59
    742c:	b0 e0       	ldi	r27, 0x00	; 0
    742e:	eb e3       	ldi	r30, 0x3B	; 59
    7430:	f0 e0       	ldi	r31, 0x00	; 0
    7432:	80 81       	ld	r24, Z
    7434:	58 2f       	mov	r21, r24
    7436:	20 91 f3 00 	lds	r18, 0x00F3
    743a:	30 91 f4 00 	lds	r19, 0x00F4
    743e:	81 e0       	ldi	r24, 0x01	; 1
    7440:	90 e0       	ldi	r25, 0x00	; 0
    7442:	02 c0       	rjmp	.+4      	; 0x7448 <keypad_getchar+0x38>
    7444:	88 0f       	add	r24, r24
    7446:	99 1f       	adc	r25, r25
    7448:	2a 95       	dec	r18
    744a:	e2 f7       	brpl	.-8      	; 0x7444 <keypad_getchar+0x34>
    744c:	48 2f       	mov	r20, r24
    744e:	20 91 f5 00 	lds	r18, 0x00F5
    7452:	30 91 f6 00 	lds	r19, 0x00F6
    7456:	81 e0       	ldi	r24, 0x01	; 1
    7458:	90 e0       	ldi	r25, 0x00	; 0
    745a:	02 c0       	rjmp	.+4      	; 0x7460 <keypad_getchar+0x50>
    745c:	88 0f       	add	r24, r24
    745e:	99 1f       	adc	r25, r25
    7460:	2a 95       	dec	r18
    7462:	e2 f7       	brpl	.-8      	; 0x745c <keypad_getchar+0x4c>
    7464:	48 2b       	or	r20, r24
    7466:	20 91 f7 00 	lds	r18, 0x00F7
    746a:	30 91 f8 00 	lds	r19, 0x00F8
    746e:	81 e0       	ldi	r24, 0x01	; 1
    7470:	90 e0       	ldi	r25, 0x00	; 0
    7472:	02 c0       	rjmp	.+4      	; 0x7478 <keypad_getchar+0x68>
    7474:	88 0f       	add	r24, r24
    7476:	99 1f       	adc	r25, r25
    7478:	2a 95       	dec	r18
    747a:	e2 f7       	brpl	.-8      	; 0x7474 <keypad_getchar+0x64>
    747c:	48 2b       	or	r20, r24
    747e:	20 91 f9 00 	lds	r18, 0x00F9
    7482:	30 91 fa 00 	lds	r19, 0x00FA
    7486:	81 e0       	ldi	r24, 0x01	; 1
    7488:	90 e0       	ldi	r25, 0x00	; 0
    748a:	02 c0       	rjmp	.+4      	; 0x7490 <keypad_getchar+0x80>
    748c:	88 0f       	add	r24, r24
    748e:	99 1f       	adc	r25, r25
    7490:	2a 95       	dec	r18
    7492:	e2 f7       	brpl	.-8      	; 0x748c <keypad_getchar+0x7c>
    7494:	84 2b       	or	r24, r20
    7496:	85 2b       	or	r24, r21
    7498:	8c 93       	st	X, r24

		// Set the current column to 0
		KEYPAD_PORT_DATA_R &= ~ (1 << keypad_columns[i]);
    749a:	ab e3       	ldi	r26, 0x3B	; 59
    749c:	b0 e0       	ldi	r27, 0x00	; 0
    749e:	eb e3       	ldi	r30, 0x3B	; 59
    74a0:	f0 e0       	ldi	r31, 0x00	; 0
    74a2:	80 81       	ld	r24, Z
    74a4:	48 2f       	mov	r20, r24
    74a6:	8b 81       	ldd	r24, Y+3	; 0x03
    74a8:	9c 81       	ldd	r25, Y+4	; 0x04
    74aa:	88 0f       	add	r24, r24
    74ac:	99 1f       	adc	r25, r25
    74ae:	fc 01       	movw	r30, r24
    74b0:	ed 50       	subi	r30, 0x0D	; 13
    74b2:	ff 4f       	sbci	r31, 0xFF	; 255
    74b4:	20 81       	ld	r18, Z
    74b6:	31 81       	ldd	r19, Z+1	; 0x01
    74b8:	81 e0       	ldi	r24, 0x01	; 1
    74ba:	90 e0       	ldi	r25, 0x00	; 0
    74bc:	02 2e       	mov	r0, r18
    74be:	02 c0       	rjmp	.+4      	; 0x74c4 <keypad_getchar+0xb4>
    74c0:	88 0f       	add	r24, r24
    74c2:	99 1f       	adc	r25, r25
    74c4:	0a 94       	dec	r0
    74c6:	e2 f7       	brpl	.-8      	; 0x74c0 <keypad_getchar+0xb0>
    74c8:	80 95       	com	r24
    74ca:	84 23       	and	r24, r20
    74cc:	8c 93       	st	X, r24

		// inner for loop to know which button is pressed in column
		// row position
		for (j = 0; j < 4; j++)
    74ce:	1a 82       	std	Y+2, r1	; 0x02
    74d0:	19 82       	std	Y+1, r1	; 0x01
    74d2:	d7 c0       	rjmp	.+430    	; 0x7682 <keypad_getchar+0x272>
		{
			// Check if button is pressed in the row of column
			if (!(KEYPAD_PORT_PIN_R & (1 << keypad_rows[j])))
    74d4:	e9 e3       	ldi	r30, 0x39	; 57
    74d6:	f0 e0       	ldi	r31, 0x00	; 0
    74d8:	80 81       	ld	r24, Z
    74da:	28 2f       	mov	r18, r24
    74dc:	30 e0       	ldi	r19, 0x00	; 0
    74de:	89 81       	ldd	r24, Y+1	; 0x01
    74e0:	9a 81       	ldd	r25, Y+2	; 0x02
    74e2:	88 0f       	add	r24, r24
    74e4:	99 1f       	adc	r25, r25
    74e6:	fc 01       	movw	r30, r24
    74e8:	e5 51       	subi	r30, 0x15	; 21
    74ea:	ff 4f       	sbci	r31, 0xFF	; 255
    74ec:	80 81       	ld	r24, Z
    74ee:	91 81       	ldd	r25, Z+1	; 0x01
    74f0:	a9 01       	movw	r20, r18
    74f2:	02 c0       	rjmp	.+4      	; 0x74f8 <keypad_getchar+0xe8>
    74f4:	55 95       	asr	r21
    74f6:	47 95       	ror	r20
    74f8:	8a 95       	dec	r24
    74fa:	e2 f7       	brpl	.-8      	; 0x74f4 <keypad_getchar+0xe4>
    74fc:	ca 01       	movw	r24, r20
    74fe:	81 70       	andi	r24, 0x01	; 1
    7500:	90 70       	andi	r25, 0x00	; 0
    7502:	00 97       	sbiw	r24, 0x00	; 0
    7504:	09 f0       	breq	.+2      	; 0x7508 <keypad_getchar+0xf8>
    7506:	b8 c0       	rjmp	.+368    	; 0x7678 <keypad_getchar+0x268>
			{
				while(!(KEYPAD_PORT_PIN_R & (1 << keypad_rows[j])));  // Write only 1 char if pressed
    7508:	e9 e3       	ldi	r30, 0x39	; 57
    750a:	f0 e0       	ldi	r31, 0x00	; 0
    750c:	80 81       	ld	r24, Z
    750e:	28 2f       	mov	r18, r24
    7510:	30 e0       	ldi	r19, 0x00	; 0
    7512:	89 81       	ldd	r24, Y+1	; 0x01
    7514:	9a 81       	ldd	r25, Y+2	; 0x02
    7516:	88 0f       	add	r24, r24
    7518:	99 1f       	adc	r25, r25
    751a:	fc 01       	movw	r30, r24
    751c:	e5 51       	subi	r30, 0x15	; 21
    751e:	ff 4f       	sbci	r31, 0xFF	; 255
    7520:	80 81       	ld	r24, Z
    7522:	91 81       	ldd	r25, Z+1	; 0x01
    7524:	a9 01       	movw	r20, r18
    7526:	02 c0       	rjmp	.+4      	; 0x752c <keypad_getchar+0x11c>
    7528:	55 95       	asr	r21
    752a:	47 95       	ror	r20
    752c:	8a 95       	dec	r24
    752e:	e2 f7       	brpl	.-8      	; 0x7528 <keypad_getchar+0x118>
    7530:	ca 01       	movw	r24, r20
    7532:	81 70       	andi	r24, 0x01	; 1
    7534:	90 70       	andi	r25, 0x00	; 0
    7536:	00 97       	sbiw	r24, 0x00	; 0
    7538:	39 f3       	breq	.-50     	; 0x7508 <keypad_getchar+0xf8>

				// Switch to get column number
				switch(i)
    753a:	8b 81       	ldd	r24, Y+3	; 0x03
    753c:	9c 81       	ldd	r25, Y+4	; 0x04
    753e:	9f 83       	std	Y+7, r25	; 0x07
    7540:	8e 83       	std	Y+6, r24	; 0x06
    7542:	4e 81       	ldd	r20, Y+6	; 0x06
    7544:	5f 81       	ldd	r21, Y+7	; 0x07
    7546:	41 30       	cpi	r20, 0x01	; 1
    7548:	51 05       	cpc	r21, r1
    754a:	c1 f1       	breq	.+112    	; 0x75bc <keypad_getchar+0x1ac>
    754c:	8e 81       	ldd	r24, Y+6	; 0x06
    754e:	9f 81       	ldd	r25, Y+7	; 0x07
    7550:	82 30       	cpi	r24, 0x02	; 2
    7552:	91 05       	cpc	r25, r1
    7554:	34 f4       	brge	.+12     	; 0x7562 <keypad_getchar+0x152>
    7556:	4e 81       	ldd	r20, Y+6	; 0x06
    7558:	5f 81       	ldd	r21, Y+7	; 0x07
    755a:	41 15       	cp	r20, r1
    755c:	51 05       	cpc	r21, r1
    755e:	71 f0       	breq	.+28     	; 0x757c <keypad_getchar+0x16c>
    7560:	8b c0       	rjmp	.+278    	; 0x7678 <keypad_getchar+0x268>
    7562:	8e 81       	ldd	r24, Y+6	; 0x06
    7564:	9f 81       	ldd	r25, Y+7	; 0x07
    7566:	82 30       	cpi	r24, 0x02	; 2
    7568:	91 05       	cpc	r25, r1
    756a:	09 f4       	brne	.+2      	; 0x756e <keypad_getchar+0x15e>
    756c:	47 c0       	rjmp	.+142    	; 0x75fc <keypad_getchar+0x1ec>
    756e:	4e 81       	ldd	r20, Y+6	; 0x06
    7570:	5f 81       	ldd	r21, Y+7	; 0x07
    7572:	43 30       	cpi	r20, 0x03	; 3
    7574:	51 05       	cpc	r21, r1
    7576:	09 f4       	brne	.+2      	; 0x757a <keypad_getchar+0x16a>
    7578:	60 c0       	rjmp	.+192    	; 0x763a <keypad_getchar+0x22a>
    757a:	7e c0       	rjmp	.+252    	; 0x7678 <keypad_getchar+0x268>
				{
					case(0):
						if (j == 0)       // Column 0 , Row 0
    757c:	89 81       	ldd	r24, Y+1	; 0x01
    757e:	9a 81       	ldd	r25, Y+2	; 0x02
    7580:	00 97       	sbiw	r24, 0x00	; 0
    7582:	19 f4       	brne	.+6      	; 0x758a <keypad_getchar+0x17a>
							return '7';
    7584:	57 e3       	ldi	r21, 0x37	; 55
    7586:	5d 83       	std	Y+5, r21	; 0x05
    7588:	8f c0       	rjmp	.+286    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 1)  // Column 0 , Row 1
    758a:	89 81       	ldd	r24, Y+1	; 0x01
    758c:	9a 81       	ldd	r25, Y+2	; 0x02
    758e:	81 30       	cpi	r24, 0x01	; 1
    7590:	91 05       	cpc	r25, r1
    7592:	19 f4       	brne	.+6      	; 0x759a <keypad_getchar+0x18a>
							return '4';
    7594:	84 e3       	ldi	r24, 0x34	; 52
    7596:	8d 83       	std	Y+5, r24	; 0x05
    7598:	87 c0       	rjmp	.+270    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 2)  // Column 0 , Row 2
    759a:	89 81       	ldd	r24, Y+1	; 0x01
    759c:	9a 81       	ldd	r25, Y+2	; 0x02
    759e:	82 30       	cpi	r24, 0x02	; 2
    75a0:	91 05       	cpc	r25, r1
    75a2:	19 f4       	brne	.+6      	; 0x75aa <keypad_getchar+0x19a>
							return '1';
    75a4:	91 e3       	ldi	r25, 0x31	; 49
    75a6:	9d 83       	std	Y+5, r25	; 0x05
    75a8:	7f c0       	rjmp	.+254    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 3)  // Column 0 , Row 3
    75aa:	89 81       	ldd	r24, Y+1	; 0x01
    75ac:	9a 81       	ldd	r25, Y+2	; 0x02
    75ae:	83 30       	cpi	r24, 0x03	; 3
    75b0:	91 05       	cpc	r25, r1
    75b2:	09 f0       	breq	.+2      	; 0x75b6 <keypad_getchar+0x1a6>
    75b4:	61 c0       	rjmp	.+194    	; 0x7678 <keypad_getchar+0x268>
							return '!';
    75b6:	41 e2       	ldi	r20, 0x21	; 33
    75b8:	4d 83       	std	Y+5, r20	; 0x05
    75ba:	76 c0       	rjmp	.+236    	; 0x76a8 <keypad_getchar+0x298>
						break;
					case(1):
						if (j == 0)       // Column 1 , Row 0
    75bc:	89 81       	ldd	r24, Y+1	; 0x01
    75be:	9a 81       	ldd	r25, Y+2	; 0x02
    75c0:	00 97       	sbiw	r24, 0x00	; 0
    75c2:	19 f4       	brne	.+6      	; 0x75ca <keypad_getchar+0x1ba>
							return '8';
    75c4:	58 e3       	ldi	r21, 0x38	; 56
    75c6:	5d 83       	std	Y+5, r21	; 0x05
    75c8:	6f c0       	rjmp	.+222    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 1)  // Column 1 , Row 1
    75ca:	89 81       	ldd	r24, Y+1	; 0x01
    75cc:	9a 81       	ldd	r25, Y+2	; 0x02
    75ce:	81 30       	cpi	r24, 0x01	; 1
    75d0:	91 05       	cpc	r25, r1
    75d2:	19 f4       	brne	.+6      	; 0x75da <keypad_getchar+0x1ca>
							return '5';
    75d4:	85 e3       	ldi	r24, 0x35	; 53
    75d6:	8d 83       	std	Y+5, r24	; 0x05
    75d8:	67 c0       	rjmp	.+206    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 2)  // Column 1 , Row 2
    75da:	89 81       	ldd	r24, Y+1	; 0x01
    75dc:	9a 81       	ldd	r25, Y+2	; 0x02
    75de:	82 30       	cpi	r24, 0x02	; 2
    75e0:	91 05       	cpc	r25, r1
    75e2:	19 f4       	brne	.+6      	; 0x75ea <keypad_getchar+0x1da>
							return '2';
    75e4:	92 e3       	ldi	r25, 0x32	; 50
    75e6:	9d 83       	std	Y+5, r25	; 0x05
    75e8:	5f c0       	rjmp	.+190    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 3)  // Column 1 , Row 3
    75ea:	89 81       	ldd	r24, Y+1	; 0x01
    75ec:	9a 81       	ldd	r25, Y+2	; 0x02
    75ee:	83 30       	cpi	r24, 0x03	; 3
    75f0:	91 05       	cpc	r25, r1
    75f2:	09 f0       	breq	.+2      	; 0x75f6 <keypad_getchar+0x1e6>
    75f4:	41 c0       	rjmp	.+130    	; 0x7678 <keypad_getchar+0x268>
							return '0';
    75f6:	40 e3       	ldi	r20, 0x30	; 48
    75f8:	4d 83       	std	Y+5, r20	; 0x05
    75fa:	56 c0       	rjmp	.+172    	; 0x76a8 <keypad_getchar+0x298>
						break;
					case(2):
						if (j == 0)       // Column 2 , Row 0
    75fc:	89 81       	ldd	r24, Y+1	; 0x01
    75fe:	9a 81       	ldd	r25, Y+2	; 0x02
    7600:	00 97       	sbiw	r24, 0x00	; 0
    7602:	19 f4       	brne	.+6      	; 0x760a <keypad_getchar+0x1fa>
							return '9';
    7604:	59 e3       	ldi	r21, 0x39	; 57
    7606:	5d 83       	std	Y+5, r21	; 0x05
    7608:	4f c0       	rjmp	.+158    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 1)  // Column 2 , Row 1
    760a:	89 81       	ldd	r24, Y+1	; 0x01
    760c:	9a 81       	ldd	r25, Y+2	; 0x02
    760e:	81 30       	cpi	r24, 0x01	; 1
    7610:	91 05       	cpc	r25, r1
    7612:	19 f4       	brne	.+6      	; 0x761a <keypad_getchar+0x20a>
							return '6';
    7614:	86 e3       	ldi	r24, 0x36	; 54
    7616:	8d 83       	std	Y+5, r24	; 0x05
    7618:	47 c0       	rjmp	.+142    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 2)  // Column 2 , Row 2
    761a:	89 81       	ldd	r24, Y+1	; 0x01
    761c:	9a 81       	ldd	r25, Y+2	; 0x02
    761e:	82 30       	cpi	r24, 0x02	; 2
    7620:	91 05       	cpc	r25, r1
    7622:	19 f4       	brne	.+6      	; 0x762a <keypad_getchar+0x21a>
							return '3';
    7624:	93 e3       	ldi	r25, 0x33	; 51
    7626:	9d 83       	std	Y+5, r25	; 0x05
    7628:	3f c0       	rjmp	.+126    	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 4)  // Column 2 , Row 3
    762a:	89 81       	ldd	r24, Y+1	; 0x01
    762c:	9a 81       	ldd	r25, Y+2	; 0x02
    762e:	84 30       	cpi	r24, 0x04	; 4
    7630:	91 05       	cpc	r25, r1
    7632:	11 f5       	brne	.+68     	; 0x7678 <keypad_getchar+0x268>
							return '=';
    7634:	4d e3       	ldi	r20, 0x3D	; 61
    7636:	4d 83       	std	Y+5, r20	; 0x05
    7638:	37 c0       	rjmp	.+110    	; 0x76a8 <keypad_getchar+0x298>
						break;
					case(3):
						if (j == 0)       // Column 3 , Row 0
    763a:	89 81       	ldd	r24, Y+1	; 0x01
    763c:	9a 81       	ldd	r25, Y+2	; 0x02
    763e:	00 97       	sbiw	r24, 0x00	; 0
    7640:	19 f4       	brne	.+6      	; 0x7648 <keypad_getchar+0x238>
							return '/';
    7642:	5f e2       	ldi	r21, 0x2F	; 47
    7644:	5d 83       	std	Y+5, r21	; 0x05
    7646:	30 c0       	rjmp	.+96     	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 1)  // Column 3 , Row 1
    7648:	89 81       	ldd	r24, Y+1	; 0x01
    764a:	9a 81       	ldd	r25, Y+2	; 0x02
    764c:	81 30       	cpi	r24, 0x01	; 1
    764e:	91 05       	cpc	r25, r1
    7650:	19 f4       	brne	.+6      	; 0x7658 <keypad_getchar+0x248>
							return '*';
    7652:	8a e2       	ldi	r24, 0x2A	; 42
    7654:	8d 83       	std	Y+5, r24	; 0x05
    7656:	28 c0       	rjmp	.+80     	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 2)  // Column 3 , Row 2
    7658:	89 81       	ldd	r24, Y+1	; 0x01
    765a:	9a 81       	ldd	r25, Y+2	; 0x02
    765c:	82 30       	cpi	r24, 0x02	; 2
    765e:	91 05       	cpc	r25, r1
    7660:	19 f4       	brne	.+6      	; 0x7668 <keypad_getchar+0x258>
							return '-';
    7662:	9d e2       	ldi	r25, 0x2D	; 45
    7664:	9d 83       	std	Y+5, r25	; 0x05
    7666:	20 c0       	rjmp	.+64     	; 0x76a8 <keypad_getchar+0x298>
						else if (j == 3)  // Column 3 , Row 3
    7668:	89 81       	ldd	r24, Y+1	; 0x01
    766a:	9a 81       	ldd	r25, Y+2	; 0x02
    766c:	83 30       	cpi	r24, 0x03	; 3
    766e:	91 05       	cpc	r25, r1
    7670:	19 f4       	brne	.+6      	; 0x7678 <keypad_getchar+0x268>
							return '+';
    7672:	4b e2       	ldi	r20, 0x2B	; 43
    7674:	4d 83       	std	Y+5, r20	; 0x05
    7676:	18 c0       	rjmp	.+48     	; 0x76a8 <keypad_getchar+0x298>
		// Set the current column to 0
		KEYPAD_PORT_DATA_R &= ~ (1 << keypad_columns[i]);

		// inner for loop to know which button is pressed in column
		// row position
		for (j = 0; j < 4; j++)
    7678:	89 81       	ldd	r24, Y+1	; 0x01
    767a:	9a 81       	ldd	r25, Y+2	; 0x02
    767c:	01 96       	adiw	r24, 0x01	; 1
    767e:	9a 83       	std	Y+2, r25	; 0x02
    7680:	89 83       	std	Y+1, r24	; 0x01
    7682:	89 81       	ldd	r24, Y+1	; 0x01
    7684:	9a 81       	ldd	r25, Y+2	; 0x02
    7686:	84 30       	cpi	r24, 0x04	; 4
    7688:	91 05       	cpc	r25, r1
    768a:	0c f4       	brge	.+2      	; 0x768e <keypad_getchar+0x27e>
    768c:	23 cf       	rjmp	.-442    	; 0x74d4 <keypad_getchar+0xc4>
// loop for rows and loop for columns also
// to know the button pressed in each ( row, column )
char keypad_getchar()
{
	int i, j;
	for (i = 0; i < 4; i++)
    768e:	8b 81       	ldd	r24, Y+3	; 0x03
    7690:	9c 81       	ldd	r25, Y+4	; 0x04
    7692:	01 96       	adiw	r24, 0x01	; 1
    7694:	9c 83       	std	Y+4, r25	; 0x04
    7696:	8b 83       	std	Y+3, r24	; 0x03
    7698:	8b 81       	ldd	r24, Y+3	; 0x03
    769a:	9c 81       	ldd	r25, Y+4	; 0x04
    769c:	84 30       	cpi	r24, 0x04	; 4
    769e:	91 05       	cpc	r25, r1
    76a0:	0c f4       	brge	.+2      	; 0x76a4 <keypad_getchar+0x294>
    76a2:	c3 ce       	rjmp	.-634    	; 0x742a <keypad_getchar+0x1a>
				}
			}

		}
	}
	return 'N';
    76a4:	5e e4       	ldi	r21, 0x4E	; 78
    76a6:	5d 83       	std	Y+5, r21	; 0x05
    76a8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    76aa:	27 96       	adiw	r28, 0x07	; 7
    76ac:	0f b6       	in	r0, 0x3f	; 63
    76ae:	f8 94       	cli
    76b0:	de bf       	out	0x3e, r29	; 62
    76b2:	0f be       	out	0x3f, r0	; 63
    76b4:	cd bf       	out	0x3d, r28	; 61
    76b6:	cf 91       	pop	r28
    76b8:	df 91       	pop	r29
    76ba:	08 95       	ret

000076bc <power>:

#define ID_NUM_DIGITS 4
#define PASSWORD_NUM_DIGITS 4

u64 power(u16 base, u16 exp)
{
    76bc:	af 92       	push	r10
    76be:	bf 92       	push	r11
    76c0:	cf 92       	push	r12
    76c2:	df 92       	push	r13
    76c4:	ef 92       	push	r14
    76c6:	ff 92       	push	r15
    76c8:	0f 93       	push	r16
    76ca:	1f 93       	push	r17
    76cc:	df 93       	push	r29
    76ce:	cf 93       	push	r28
    76d0:	cd b7       	in	r28, 0x3d	; 61
    76d2:	de b7       	in	r29, 0x3e	; 62
    76d4:	2a 97       	sbiw	r28, 0x0a	; 10
    76d6:	0f b6       	in	r0, 0x3f	; 63
    76d8:	f8 94       	cli
    76da:	de bf       	out	0x3e, r29	; 62
    76dc:	0f be       	out	0x3f, r0	; 63
    76de:	cd bf       	out	0x3d, r28	; 61
    76e0:	98 87       	std	Y+8, r25	; 0x08
    76e2:	8f 83       	std	Y+7, r24	; 0x07
    76e4:	7a 87       	std	Y+10, r23	; 0x0a
    76e6:	69 87       	std	Y+9, r22	; 0x09
	u32 res = 1;
    76e8:	81 e0       	ldi	r24, 0x01	; 1
    76ea:	90 e0       	ldi	r25, 0x00	; 0
    76ec:	a0 e0       	ldi	r26, 0x00	; 0
    76ee:	b0 e0       	ldi	r27, 0x00	; 0
    76f0:	8b 83       	std	Y+3, r24	; 0x03
    76f2:	9c 83       	std	Y+4, r25	; 0x04
    76f4:	ad 83       	std	Y+5, r26	; 0x05
    76f6:	be 83       	std	Y+6, r27	; 0x06

	for (u16 i = 0; i < exp; i++) {
    76f8:	1a 82       	std	Y+2, r1	; 0x02
    76fa:	19 82       	std	Y+1, r1	; 0x01
    76fc:	18 c0       	rjmp	.+48     	; 0x772e <power+0x72>
		res *= base;
    76fe:	8f 81       	ldd	r24, Y+7	; 0x07
    7700:	98 85       	ldd	r25, Y+8	; 0x08
    7702:	9c 01       	movw	r18, r24
    7704:	40 e0       	ldi	r20, 0x00	; 0
    7706:	50 e0       	ldi	r21, 0x00	; 0
    7708:	8b 81       	ldd	r24, Y+3	; 0x03
    770a:	9c 81       	ldd	r25, Y+4	; 0x04
    770c:	ad 81       	ldd	r26, Y+5	; 0x05
    770e:	be 81       	ldd	r27, Y+6	; 0x06
    7710:	bc 01       	movw	r22, r24
    7712:	cd 01       	movw	r24, r26
    7714:	0e 94 4a 42 	call	0x8494	; 0x8494 <__mulsi3>
    7718:	dc 01       	movw	r26, r24
    771a:	cb 01       	movw	r24, r22
    771c:	8b 83       	std	Y+3, r24	; 0x03
    771e:	9c 83       	std	Y+4, r25	; 0x04
    7720:	ad 83       	std	Y+5, r26	; 0x05
    7722:	be 83       	std	Y+6, r27	; 0x06

u64 power(u16 base, u16 exp)
{
	u32 res = 1;

	for (u16 i = 0; i < exp; i++) {
    7724:	89 81       	ldd	r24, Y+1	; 0x01
    7726:	9a 81       	ldd	r25, Y+2	; 0x02
    7728:	01 96       	adiw	r24, 0x01	; 1
    772a:	9a 83       	std	Y+2, r25	; 0x02
    772c:	89 83       	std	Y+1, r24	; 0x01
    772e:	29 81       	ldd	r18, Y+1	; 0x01
    7730:	3a 81       	ldd	r19, Y+2	; 0x02
    7732:	89 85       	ldd	r24, Y+9	; 0x09
    7734:	9a 85       	ldd	r25, Y+10	; 0x0a
    7736:	28 17       	cp	r18, r24
    7738:	39 07       	cpc	r19, r25
    773a:	08 f3       	brcs	.-62     	; 0x76fe <power+0x42>
		res *= base;
	}
	return res;
    773c:	8b 81       	ldd	r24, Y+3	; 0x03
    773e:	9c 81       	ldd	r25, Y+4	; 0x04
    7740:	ad 81       	ldd	r26, Y+5	; 0x05
    7742:	be 81       	ldd	r27, Y+6	; 0x06
    7744:	9c 01       	movw	r18, r24
    7746:	ad 01       	movw	r20, r26
    7748:	60 e0       	ldi	r22, 0x00	; 0
    774a:	70 e0       	ldi	r23, 0x00	; 0
    774c:	80 e0       	ldi	r24, 0x00	; 0
    774e:	90 e0       	ldi	r25, 0x00	; 0
    7750:	a2 2e       	mov	r10, r18
    7752:	b3 2e       	mov	r11, r19
    7754:	c4 2e       	mov	r12, r20
    7756:	d5 2e       	mov	r13, r21
    7758:	e6 2e       	mov	r14, r22
    775a:	f7 2e       	mov	r15, r23
    775c:	08 2f       	mov	r16, r24
    775e:	19 2f       	mov	r17, r25
}
    7760:	2a 2d       	mov	r18, r10
    7762:	3b 2d       	mov	r19, r11
    7764:	4c 2d       	mov	r20, r12
    7766:	5d 2d       	mov	r21, r13
    7768:	6e 2d       	mov	r22, r14
    776a:	7f 2d       	mov	r23, r15
    776c:	80 2f       	mov	r24, r16
    776e:	91 2f       	mov	r25, r17
    7770:	2a 96       	adiw	r28, 0x0a	; 10
    7772:	0f b6       	in	r0, 0x3f	; 63
    7774:	f8 94       	cli
    7776:	de bf       	out	0x3e, r29	; 62
    7778:	0f be       	out	0x3f, r0	; 63
    777a:	cd bf       	out	0x3d, r28	; 61
    777c:	cf 91       	pop	r28
    777e:	df 91       	pop	r29
    7780:	1f 91       	pop	r17
    7782:	0f 91       	pop	r16
    7784:	ff 90       	pop	r15
    7786:	ef 90       	pop	r14
    7788:	df 90       	pop	r13
    778a:	cf 90       	pop	r12
    778c:	bf 90       	pop	r11
    778e:	af 90       	pop	r10
    7790:	08 95       	ret

00007792 <chartoint>:

u16 chartoint(u8 char_number){
    7792:	df 93       	push	r29
    7794:	cf 93       	push	r28
    7796:	00 d0       	rcall	.+0      	; 0x7798 <chartoint+0x6>
    7798:	0f 92       	push	r0
    779a:	cd b7       	in	r28, 0x3d	; 61
    779c:	de b7       	in	r29, 0x3e	; 62
    779e:	8b 83       	std	Y+3, r24	; 0x03
	u16 num =0;
    77a0:	1a 82       	std	Y+2, r1	; 0x02
    77a2:	19 82       	std	Y+1, r1	; 0x01
	num = char_number - '0';
    77a4:	8b 81       	ldd	r24, Y+3	; 0x03
    77a6:	88 2f       	mov	r24, r24
    77a8:	90 e0       	ldi	r25, 0x00	; 0
    77aa:	c0 97       	sbiw	r24, 0x30	; 48
    77ac:	9a 83       	std	Y+2, r25	; 0x02
    77ae:	89 83       	std	Y+1, r24	; 0x01

	return num;
    77b0:	89 81       	ldd	r24, Y+1	; 0x01
    77b2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    77b4:	0f 90       	pop	r0
    77b6:	0f 90       	pop	r0
    77b8:	0f 90       	pop	r0
    77ba:	cf 91       	pop	r28
    77bc:	df 91       	pop	r29
    77be:	08 95       	ret

000077c0 <main>:
void APP_VidShowBalance(void *pv);
//void APP_VidCangePass(void *pv);
void APP_vidTaskExit(void *pv);

int main(void)
{
    77c0:	ef 92       	push	r14
    77c2:	ff 92       	push	r15
    77c4:	0f 93       	push	r16
    77c6:	df 93       	push	r29
    77c8:	cf 93       	push	r28
    77ca:	cd b7       	in	r28, 0x3d	; 61
    77cc:	de b7       	in	r29, 0x3e	; 62
	/*semaphore welcome Task*/
	LCDSem     = xSemaphoreCreateCounting(1, 1);
    77ce:	81 e0       	ldi	r24, 0x01	; 1
    77d0:	61 e0       	ldi	r22, 0x01	; 1
    77d2:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    77d6:	90 93 20 08 	sts	0x0820, r25
    77da:	80 93 1f 08 	sts	0x081F, r24
	/*semaphore card use to enter ID*/
	CardSem    = xSemaphoreCreateCounting(1, 0);
    77de:	81 e0       	ldi	r24, 0x01	; 1
    77e0:	60 e0       	ldi	r22, 0x00	; 0
    77e2:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    77e6:	90 93 22 08 	sts	0x0822, r25
    77ea:	80 93 21 08 	sts	0x0821, r24
	/*semaphore password*/
	PassSem    = xSemaphoreCreateCounting(1, 0);
    77ee:	81 e0       	ldi	r24, 0x01	; 1
    77f0:	60 e0       	ldi	r22, 0x00	; 0
    77f2:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    77f6:	90 93 2a 08 	sts	0x082A, r25
    77fa:	80 93 29 08 	sts	0x0829, r24
	/*semaphore choice from list ATM*/
	OptionSem  = xSemaphoreCreateCounting(1, 0);
    77fe:	81 e0       	ldi	r24, 0x01	; 1
    7800:	60 e0       	ldi	r22, 0x00	; 0
    7802:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    7806:	90 93 26 08 	sts	0x0826, r25
    780a:	80 93 25 08 	sts	0x0825, r24
	/*semaphore Cash withdraw Task*/
	CashSem    = xSemaphoreCreateCounting(1,0);
    780e:	81 e0       	ldi	r24, 0x01	; 1
    7810:	60 e0       	ldi	r22, 0x00	; 0
    7812:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    7816:	90 93 2e 08 	sts	0x082E, r25
    781a:	80 93 2d 08 	sts	0x082D, r24
	/*semaphore Balance inquiry Task*/
	BalanceSem = xSemaphoreCreateCounting(1,0);
    781e:	81 e0       	ldi	r24, 0x01	; 1
    7820:	60 e0       	ldi	r22, 0x00	; 0
    7822:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    7826:	90 93 2c 08 	sts	0x082C, r25
    782a:	80 93 2b 08 	sts	0x082B, r24
	/*semaphore Exit Task*/
	ExitSem    = xSemaphoreCreateCounting(1, 0);
    782e:	81 e0       	ldi	r24, 0x01	; 1
    7830:	60 e0       	ldi	r22, 0x00	; 0
    7832:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <xQueueCreateCountingSemaphore>
    7836:	90 93 28 08 	sts	0x0828, r25
    783a:	80 93 27 08 	sts	0x0827, r24


	MDIO_Error_State_SetPinDirection(PIN0, MDIO_PORTB, PIN_INPUT);
    783e:	80 e0       	ldi	r24, 0x00	; 0
    7840:	61 e0       	ldi	r22, 0x01	; 1
    7842:	40 e0       	ldi	r20, 0x00	; 0
    7844:	0e 94 4a 07 	call	0xe94	; 0xe94 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN1, MDIO_PORTB, PIN_INPUT);
    7848:	81 e0       	ldi	r24, 0x01	; 1
    784a:	61 e0       	ldi	r22, 0x01	; 1
    784c:	40 e0       	ldi	r20, 0x00	; 0
    784e:	0e 94 4a 07 	call	0xe94	; 0xe94 <MDIO_Error_State_SetPinDirection>

	lcd_init();
    7852:	0e 94 dd 35 	call	0x6bba	; 0x6bba <lcd_init>
	keypad_init();
    7856:	0e 94 ef 39 	call	0x73de	; 0x73de <keypad_init>

	xTaskCreate(APP_VidWelcomeTask,NULL,85,NULL,5,NULL);
    785a:	8e e7       	ldi	r24, 0x7E	; 126
    785c:	9c e3       	ldi	r25, 0x3C	; 60
    785e:	60 e0       	ldi	r22, 0x00	; 0
    7860:	70 e0       	ldi	r23, 0x00	; 0
    7862:	45 e5       	ldi	r20, 0x55	; 85
    7864:	50 e0       	ldi	r21, 0x00	; 0
    7866:	20 e0       	ldi	r18, 0x00	; 0
    7868:	30 e0       	ldi	r19, 0x00	; 0
    786a:	05 e0       	ldi	r16, 0x05	; 5
    786c:	ee 24       	eor	r14, r14
    786e:	ff 24       	eor	r15, r15
    7870:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>
	xTaskCreate(APP_VidGet_ID_From_Keypad,NULL,85,NULL,1,NULL);
    7874:	8a ec       	ldi	r24, 0xCA	; 202
    7876:	9c e3       	ldi	r25, 0x3C	; 60
    7878:	60 e0       	ldi	r22, 0x00	; 0
    787a:	70 e0       	ldi	r23, 0x00	; 0
    787c:	45 e5       	ldi	r20, 0x55	; 85
    787e:	50 e0       	ldi	r21, 0x00	; 0
    7880:	20 e0       	ldi	r18, 0x00	; 0
    7882:	30 e0       	ldi	r19, 0x00	; 0
    7884:	01 e0       	ldi	r16, 0x01	; 1
    7886:	ee 24       	eor	r14, r14
    7888:	ff 24       	eor	r15, r15
    788a:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>


	xTaskCreate(APP_VidGet_PASS_From_Keypad,NULL,85,NULL,1,NULL);
    788e:	89 ef       	ldi	r24, 0xF9	; 249
    7890:	9f e3       	ldi	r25, 0x3F	; 63
    7892:	60 e0       	ldi	r22, 0x00	; 0
    7894:	70 e0       	ldi	r23, 0x00	; 0
    7896:	45 e5       	ldi	r20, 0x55	; 85
    7898:	50 e0       	ldi	r21, 0x00	; 0
    789a:	20 e0       	ldi	r18, 0x00	; 0
    789c:	30 e0       	ldi	r19, 0x00	; 0
    789e:	01 e0       	ldi	r16, 0x01	; 1
    78a0:	ee 24       	eor	r14, r14
    78a2:	ff 24       	eor	r15, r15
    78a4:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>
	xTaskCreate(APP_VidChoiceOption,NULL,85,NULL,1,NULL);
    78a8:	8f e4       	ldi	r24, 0x4F	; 79
    78aa:	91 e4       	ldi	r25, 0x41	; 65
    78ac:	60 e0       	ldi	r22, 0x00	; 0
    78ae:	70 e0       	ldi	r23, 0x00	; 0
    78b0:	45 e5       	ldi	r20, 0x55	; 85
    78b2:	50 e0       	ldi	r21, 0x00	; 0
    78b4:	20 e0       	ldi	r18, 0x00	; 0
    78b6:	30 e0       	ldi	r19, 0x00	; 0
    78b8:	01 e0       	ldi	r16, 0x01	; 1
    78ba:	ee 24       	eor	r14, r14
    78bc:	ff 24       	eor	r15, r15
    78be:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>
	//xTaskCreate(APP_VidCashWithdraw,NULL,100,NULL,1,NULL);
	xTaskCreate(APP_VidShowBalance,NULL,85,NULL,1,NULL);
    78c2:	83 ee       	ldi	r24, 0xE3	; 227
    78c4:	91 e4       	ldi	r25, 0x41	; 65
    78c6:	60 e0       	ldi	r22, 0x00	; 0
    78c8:	70 e0       	ldi	r23, 0x00	; 0
    78ca:	45 e5       	ldi	r20, 0x55	; 85
    78cc:	50 e0       	ldi	r21, 0x00	; 0
    78ce:	20 e0       	ldi	r18, 0x00	; 0
    78d0:	30 e0       	ldi	r19, 0x00	; 0
    78d2:	01 e0       	ldi	r16, 0x01	; 1
    78d4:	ee 24       	eor	r14, r14
    78d6:	ff 24       	eor	r15, r15
    78d8:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>
	//xTaskCreate(APP_VidCangePass,NULL,100,NULL,1,NULL);
	xTaskCreate(APP_vidTaskExit,NULL,85,NULL,5,NULL);
    78dc:	8a e1       	ldi	r24, 0x1A	; 26
    78de:	92 e4       	ldi	r25, 0x42	; 66
    78e0:	60 e0       	ldi	r22, 0x00	; 0
    78e2:	70 e0       	ldi	r23, 0x00	; 0
    78e4:	45 e5       	ldi	r20, 0x55	; 85
    78e6:	50 e0       	ldi	r21, 0x00	; 0
    78e8:	20 e0       	ldi	r18, 0x00	; 0
    78ea:	30 e0       	ldi	r19, 0x00	; 0
    78ec:	05 e0       	ldi	r16, 0x05	; 5
    78ee:	ee 24       	eor	r14, r14
    78f0:	ff 24       	eor	r15, r15
    78f2:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <xTaskCreate>

	vTaskStartScheduler();
    78f6:	0e 94 66 25 	call	0x4acc	; 0x4acc <vTaskStartScheduler>
    78fa:	ff cf       	rjmp	.-2      	; 0x78fa <main+0x13a>

000078fc <APP_VidWelcomeTask>:

	return 0;
}

void APP_VidWelcomeTask(void *Pv)
{
    78fc:	df 93       	push	r29
    78fe:	cf 93       	push	r28
    7900:	00 d0       	rcall	.+0      	; 0x7902 <APP_VidWelcomeTask+0x6>
    7902:	00 d0       	rcall	.+0      	; 0x7904 <APP_VidWelcomeTask+0x8>
    7904:	0f 92       	push	r0
    7906:	cd b7       	in	r28, 0x3d	; 61
    7908:	de b7       	in	r29, 0x3e	; 62
    790a:	9d 83       	std	Y+5, r25	; 0x05
    790c:	8c 83       	std	Y+4, r24	; 0x04
	u8 Loc_u8ButtonState = 1;
    790e:	81 e0       	ldi	r24, 0x01	; 1
    7910:	8b 83       	std	Y+3, r24	; 0x03
	u8 LCDSemState = 0;
    7912:	1a 82       	std	Y+2, r1	; 0x02
	u8 LCDFlag = 0;
    7914:	19 82       	std	Y+1, r1	; 0x01

	while(1) {

		LCDSemState=xSemaphoreTake(LCDSem,10);
    7916:	80 91 1f 08 	lds	r24, 0x081F
    791a:	90 91 20 08 	lds	r25, 0x0820
    791e:	6a e0       	ldi	r22, 0x0A	; 10
    7920:	70 e0       	ldi	r23, 0x00	; 0
    7922:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    7926:	8a 83       	std	Y+2, r24	; 0x02
		if(LCDSemState==pdPASS)
    7928:	8a 81       	ldd	r24, Y+2	; 0x02
    792a:	81 30       	cpi	r24, 0x01	; 1
    792c:	71 f5       	brne	.+92     	; 0x798a <APP_VidWelcomeTask+0x8e>
		{
			if (!LCDFlag) {
    792e:	89 81       	ldd	r24, Y+1	; 0x01
    7930:	88 23       	and	r24, r24
    7932:	41 f4       	brne	.+16     	; 0x7944 <APP_VidWelcomeTask+0x48>
				lcd_clear();
    7934:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
				lcd_write_string("NTI Bank...");
    7938:	85 e6       	ldi	r24, 0x65	; 101
    793a:	90 e0       	ldi	r25, 0x00	; 0
    793c:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				LCDFlag = 1;
    7940:	81 e0       	ldi	r24, 0x01	; 1
    7942:	89 83       	std	Y+1, r24	; 0x01
			}
			MDIO_Error_State_GetPinValue(PIN0, MDIO_PORTB, &Loc_u8ButtonState);
    7944:	9e 01       	movw	r18, r28
    7946:	2d 5f       	subi	r18, 0xFD	; 253
    7948:	3f 4f       	sbci	r19, 0xFF	; 255
    794a:	80 e0       	ldi	r24, 0x00	; 0
    794c:	61 e0       	ldi	r22, 0x01	; 1
    794e:	a9 01       	movw	r20, r18
    7950:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <MDIO_Error_State_GetPinValue>
			if(Loc_u8ButtonState == 0)
    7954:	8b 81       	ldd	r24, Y+3	; 0x03
    7956:	88 23       	and	r24, r24
    7958:	69 f4       	brne	.+26     	; 0x7974 <APP_VidWelcomeTask+0x78>
			{
				xSemaphoreGive(CardSem);
    795a:	80 91 21 08 	lds	r24, 0x0821
    795e:	90 91 22 08 	lds	r25, 0x0822
    7962:	60 e0       	ldi	r22, 0x00	; 0
    7964:	70 e0       	ldi	r23, 0x00	; 0
    7966:	40 e0       	ldi	r20, 0x00	; 0
    7968:	50 e0       	ldi	r21, 0x00	; 0
    796a:	20 e0       	ldi	r18, 0x00	; 0
    796c:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
				LCDFlag = 0;
    7970:	19 82       	std	Y+1, r1	; 0x01
    7972:	0b c0       	rjmp	.+22     	; 0x798a <APP_VidWelcomeTask+0x8e>
			}
			else
			{
				xSemaphoreGive(ExitSem);
    7974:	80 91 27 08 	lds	r24, 0x0827
    7978:	90 91 28 08 	lds	r25, 0x0828
    797c:	60 e0       	ldi	r22, 0x00	; 0
    797e:	70 e0       	ldi	r23, 0x00	; 0
    7980:	40 e0       	ldi	r20, 0x00	; 0
    7982:	50 e0       	ldi	r21, 0x00	; 0
    7984:	20 e0       	ldi	r18, 0x00	; 0
    7986:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
		else
		{
			/*Do Nothing*/
		}

		vTaskDelay(20);
    798a:	84 e1       	ldi	r24, 0x14	; 20
    798c:	90 e0       	ldi	r25, 0x00	; 0
    798e:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    7992:	c1 cf       	rjmp	.-126    	; 0x7916 <APP_VidWelcomeTask+0x1a>

00007994 <APP_VidGet_ID_From_Keypad>:
	}
}

void APP_VidGet_ID_From_Keypad(void *Pv)
{
    7994:	2f 92       	push	r2
    7996:	3f 92       	push	r3
    7998:	4f 92       	push	r4
    799a:	5f 92       	push	r5
    799c:	6f 92       	push	r6
    799e:	7f 92       	push	r7
    79a0:	8f 92       	push	r8
    79a2:	9f 92       	push	r9
    79a4:	af 92       	push	r10
    79a6:	bf 92       	push	r11
    79a8:	cf 92       	push	r12
    79aa:	df 92       	push	r13
    79ac:	ef 92       	push	r14
    79ae:	ff 92       	push	r15
    79b0:	0f 93       	push	r16
    79b2:	1f 93       	push	r17
    79b4:	df 93       	push	r29
    79b6:	cf 93       	push	r28
    79b8:	cd b7       	in	r28, 0x3d	; 61
    79ba:	de b7       	in	r29, 0x3e	; 62
    79bc:	ca 55       	subi	r28, 0x5A	; 90
    79be:	d0 40       	sbci	r29, 0x00	; 0
    79c0:	0f b6       	in	r0, 0x3f	; 63
    79c2:	f8 94       	cli
    79c4:	de bf       	out	0x3e, r29	; 62
    79c6:	0f be       	out	0x3f, r0	; 63
    79c8:	cd bf       	out	0x3d, r28	; 61
    79ca:	9f a3       	std	Y+39, r25	; 0x27
    79cc:	8e a3       	std	Y+38, r24	; 0x26
	u8 Loc_u8CardSemState;
	char Loc_u8KeyPressed = 'N';
    79ce:	8e e4       	ldi	r24, 0x4E	; 78
    79d0:	8c 87       	std	Y+12, r24	; 0x0c
	u16 ID[12]={0};
    79d2:	88 e1       	ldi	r24, 0x18	; 24
    79d4:	fe 01       	movw	r30, r28
    79d6:	3e 96       	adiw	r30, 0x0e	; 14
    79d8:	df 01       	movw	r26, r30
    79da:	98 2f       	mov	r25, r24
    79dc:	1d 92       	st	X+, r1
    79de:	9a 95       	dec	r25
    79e0:	e9 f7       	brne	.-6      	; 0x79dc <APP_VidGet_ID_From_Keypad+0x48>
	u64 id = 0;
    79e2:	1c 82       	std	Y+4, r1	; 0x04
    79e4:	1d 82       	std	Y+5, r1	; 0x05
    79e6:	1e 82       	std	Y+6, r1	; 0x06
    79e8:	1f 82       	std	Y+7, r1	; 0x07
    79ea:	18 86       	std	Y+8, r1	; 0x08
    79ec:	19 86       	std	Y+9, r1	; 0x09
    79ee:	1a 86       	std	Y+10, r1	; 0x0a
    79f0:	1b 86       	std	Y+11, r1	; 0x0b
	u8 Loc_u8Flag=0;
    79f2:	1b 82       	std	Y+3, r1	; 0x03
	u8 Loc_Count = 0;
    79f4:	1a 82       	std	Y+2, r1	; 0x02

	while(1)
	{
		Loc_Count = 0;
    79f6:	1a 82       	std	Y+2, r1	; 0x02
		Loc_u8KeyPressed = 'N';
    79f8:	8e e4       	ldi	r24, 0x4E	; 78
    79fa:	8c 87       	std	Y+12, r24	; 0x0c
		Loc_u8Flag=0;
    79fc:	1b 82       	std	Y+3, r1	; 0x03
		id = 0;
    79fe:	1c 82       	std	Y+4, r1	; 0x04
    7a00:	1d 82       	std	Y+5, r1	; 0x05
    7a02:	1e 82       	std	Y+6, r1	; 0x06
    7a04:	1f 82       	std	Y+7, r1	; 0x07
    7a06:	18 86       	std	Y+8, r1	; 0x08
    7a08:	19 86       	std	Y+9, r1	; 0x09
    7a0a:	1a 86       	std	Y+10, r1	; 0x0a
    7a0c:	1b 86       	std	Y+11, r1	; 0x0b
		Loc_u8CardSemState = xSemaphoreTake(CardSem,10);
    7a0e:	80 91 21 08 	lds	r24, 0x0821
    7a12:	90 91 22 08 	lds	r25, 0x0822
    7a16:	6a e0       	ldi	r22, 0x0A	; 10
    7a18:	70 e0       	ldi	r23, 0x00	; 0
    7a1a:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    7a1e:	8d 87       	std	Y+13, r24	; 0x0d
		if(Loc_u8CardSemState==pdPASS)
    7a20:	8d 85       	ldd	r24, Y+13	; 0x0d
    7a22:	81 30       	cpi	r24, 0x01	; 1
    7a24:	09 f0       	breq	.+2      	; 0x7a28 <APP_VidGet_ID_From_Keypad+0x94>
    7a26:	e0 c2       	rjmp	.+1472   	; 0x7fe8 <APP_VidGet_ID_From_Keypad+0x654>
		{
			lcd_clear();
    7a28:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
			lcd_write_string("EnterID:");
    7a2c:	81 e7       	ldi	r24, 0x71	; 113
    7a2e:	90 e0       	ldi	r25, 0x00	; 0
    7a30:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
    7a34:	33 c0       	rjmp	.+102    	; 0x7a9c <APP_VidGet_ID_From_Keypad+0x108>
			//lcd_goto_xy(1,0);
			while (Loc_u8KeyPressed != '*')
			{
				if (Loc_Count > 11)
    7a36:	8a 81       	ldd	r24, Y+2	; 0x02
    7a38:	8c 30       	cpi	r24, 0x0C	; 12
    7a3a:	98 f5       	brcc	.+102    	; 0x7aa2 <APP_VidGet_ID_From_Keypad+0x10e>
					break;
				if(Loc_u8KeyPressed != 'N')
    7a3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a3e:	8e 34       	cpi	r24, 0x4E	; 78
    7a40:	51 f1       	breq	.+84     	; 0x7a96 <APP_VidGet_ID_From_Keypad+0x102>
				{
					ID[Loc_Count] = chartoint(Loc_u8KeyPressed);
    7a42:	8a 81       	ldd	r24, Y+2	; 0x02
    7a44:	08 2f       	mov	r16, r24
    7a46:	10 e0       	ldi	r17, 0x00	; 0
    7a48:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a4a:	0e 94 c9 3b 	call	0x7792	; 0x7792 <chartoint>
    7a4e:	ac 01       	movw	r20, r24
    7a50:	98 01       	movw	r18, r16
    7a52:	22 0f       	add	r18, r18
    7a54:	33 1f       	adc	r19, r19
    7a56:	ce 01       	movw	r24, r28
    7a58:	01 96       	adiw	r24, 0x01	; 1
    7a5a:	82 0f       	add	r24, r18
    7a5c:	93 1f       	adc	r25, r19
    7a5e:	fc 01       	movw	r30, r24
    7a60:	3d 96       	adiw	r30, 0x0d	; 13
    7a62:	51 83       	std	Z+1, r21	; 0x01
    7a64:	40 83       	st	Z, r20
					lcd_Write_Number(ID[Loc_Count]);
    7a66:	8a 81       	ldd	r24, Y+2	; 0x02
    7a68:	88 2f       	mov	r24, r24
    7a6a:	90 e0       	ldi	r25, 0x00	; 0
    7a6c:	9c 01       	movw	r18, r24
    7a6e:	22 0f       	add	r18, r18
    7a70:	33 1f       	adc	r19, r19
    7a72:	ce 01       	movw	r24, r28
    7a74:	01 96       	adiw	r24, 0x01	; 1
    7a76:	82 0f       	add	r24, r18
    7a78:	93 1f       	adc	r25, r19
    7a7a:	fc 01       	movw	r30, r24
    7a7c:	3d 96       	adiw	r30, 0x0d	; 13
    7a7e:	80 81       	ld	r24, Z
    7a80:	91 81       	ldd	r25, Z+1	; 0x01
    7a82:	cc 01       	movw	r24, r24
    7a84:	a0 e0       	ldi	r26, 0x00	; 0
    7a86:	b0 e0       	ldi	r27, 0x00	; 0
    7a88:	bc 01       	movw	r22, r24
    7a8a:	cd 01       	movw	r24, r26
    7a8c:	0e 94 50 39 	call	0x72a0	; 0x72a0 <lcd_Write_Number>
					Loc_Count++;
    7a90:	8a 81       	ldd	r24, Y+2	; 0x02
    7a92:	8f 5f       	subi	r24, 0xFF	; 255
    7a94:	8a 83       	std	Y+2, r24	; 0x02
				}
				else
				{
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
    7a96:	0e 94 08 3a 	call	0x7410	; 0x7410 <keypad_getchar>
    7a9a:	8c 87       	std	Y+12, r24	; 0x0c
		if(Loc_u8CardSemState==pdPASS)
		{
			lcd_clear();
			lcd_write_string("EnterID:");
			//lcd_goto_xy(1,0);
			while (Loc_u8KeyPressed != '*')
    7a9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a9e:	8a 32       	cpi	r24, 0x2A	; 42
    7aa0:	51 f6       	brne	.-108    	; 0x7a36 <APP_VidGet_ID_From_Keypad+0xa2>
				{
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
			}
			for (u8 i = ID_NUM_DIGITS; i >= 1; i--) {
    7aa2:	84 e0       	ldi	r24, 0x04	; 4
    7aa4:	89 83       	std	Y+1, r24	; 0x01
    7aa6:	0a c2       	rjmp	.+1044   	; 0x7ebc <APP_VidGet_ID_From_Keypad+0x528>
				id += ID[ID_NUM_DIGITS - i] * power(10, i - 1);
    7aa8:	89 81       	ldd	r24, Y+1	; 0x01
    7aaa:	28 2f       	mov	r18, r24
    7aac:	30 e0       	ldi	r19, 0x00	; 0
    7aae:	84 e0       	ldi	r24, 0x04	; 4
    7ab0:	90 e0       	ldi	r25, 0x00	; 0
    7ab2:	82 1b       	sub	r24, r18
    7ab4:	93 0b       	sbc	r25, r19
    7ab6:	9c 01       	movw	r18, r24
    7ab8:	22 0f       	add	r18, r18
    7aba:	33 1f       	adc	r19, r19
    7abc:	ce 01       	movw	r24, r28
    7abe:	01 96       	adiw	r24, 0x01	; 1
    7ac0:	82 0f       	add	r24, r18
    7ac2:	93 1f       	adc	r25, r19
    7ac4:	fc 01       	movw	r30, r24
    7ac6:	3d 96       	adiw	r30, 0x0d	; 13
    7ac8:	80 81       	ld	r24, Z
    7aca:	91 81       	ldd	r25, Z+1	; 0x01
    7acc:	5c 01       	movw	r10, r24
    7ace:	cc 24       	eor	r12, r12
    7ad0:	dd 24       	eor	r13, r13
    7ad2:	ee 24       	eor	r14, r14
    7ad4:	ff 24       	eor	r15, r15
    7ad6:	87 01       	movw	r16, r14
    7ad8:	89 81       	ldd	r24, Y+1	; 0x01
    7ada:	88 2f       	mov	r24, r24
    7adc:	90 e0       	ldi	r25, 0x00	; 0
    7ade:	01 97       	sbiw	r24, 0x01	; 1
    7ae0:	9c 01       	movw	r18, r24
    7ae2:	8a e0       	ldi	r24, 0x0A	; 10
    7ae4:	90 e0       	ldi	r25, 0x00	; 0
    7ae6:	b9 01       	movw	r22, r18
    7ae8:	0e 94 5e 3b 	call	0x76bc	; 0x76bc <power>
    7aec:	22 2e       	mov	r2, r18
    7aee:	33 2e       	mov	r3, r19
    7af0:	44 2e       	mov	r4, r20
    7af2:	55 2e       	mov	r5, r21
    7af4:	66 2e       	mov	r6, r22
    7af6:	77 2e       	mov	r7, r23
    7af8:	88 2e       	mov	r8, r24
    7afa:	99 2e       	mov	r9, r25
    7afc:	2a 2d       	mov	r18, r10
    7afe:	3b 2d       	mov	r19, r11
    7b00:	4c 2d       	mov	r20, r12
    7b02:	5d 2d       	mov	r21, r13
    7b04:	6e 2d       	mov	r22, r14
    7b06:	7f 2d       	mov	r23, r15
    7b08:	80 2f       	mov	r24, r16
    7b0a:	91 2f       	mov	r25, r17
    7b0c:	a2 2c       	mov	r10, r2
    7b0e:	b3 2c       	mov	r11, r3
    7b10:	c4 2c       	mov	r12, r4
    7b12:	d5 2c       	mov	r13, r5
    7b14:	e6 2c       	mov	r14, r6
    7b16:	f7 2c       	mov	r15, r7
    7b18:	08 2d       	mov	r16, r8
    7b1a:	19 2d       	mov	r17, r9
    7b1c:	0e 94 49 00 	call	0x92	; 0x92 <__muldi3>
    7b20:	a2 2e       	mov	r10, r18
    7b22:	b3 2e       	mov	r11, r19
    7b24:	c4 2e       	mov	r12, r20
    7b26:	d5 2e       	mov	r13, r21
    7b28:	e6 2e       	mov	r14, r22
    7b2a:	f7 2e       	mov	r15, r23
    7b2c:	08 2f       	mov	r16, r24
    7b2e:	19 2f       	mov	r17, r25
    7b30:	a8 aa       	std	Y+48, r10	; 0x30
    7b32:	b9 aa       	std	Y+49, r11	; 0x31
    7b34:	ca aa       	std	Y+50, r12	; 0x32
    7b36:	db aa       	std	Y+51, r13	; 0x33
    7b38:	ec aa       	std	Y+52, r14	; 0x34
    7b3a:	fd aa       	std	Y+53, r15	; 0x35
    7b3c:	0e ab       	std	Y+54, r16	; 0x36
    7b3e:	1f ab       	std	Y+55, r17	; 0x37
    7b40:	ac 81       	ldd	r26, Y+4	; 0x04
    7b42:	a8 af       	std	Y+56, r26	; 0x38
    7b44:	bd 81       	ldd	r27, Y+5	; 0x05
    7b46:	b9 af       	std	Y+57, r27	; 0x39
    7b48:	8e 81       	ldd	r24, Y+6	; 0x06
    7b4a:	8a af       	std	Y+58, r24	; 0x3a
    7b4c:	9f 81       	ldd	r25, Y+7	; 0x07
    7b4e:	9b af       	std	Y+59, r25	; 0x3b
    7b50:	a8 85       	ldd	r26, Y+8	; 0x08
    7b52:	ac af       	std	Y+60, r26	; 0x3c
    7b54:	b9 85       	ldd	r27, Y+9	; 0x09
    7b56:	bd af       	std	Y+61, r27	; 0x3d
    7b58:	8a 85       	ldd	r24, Y+10	; 0x0a
    7b5a:	8e af       	std	Y+62, r24	; 0x3e
    7b5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    7b5e:	9f af       	std	Y+63, r25	; 0x3f
    7b60:	a8 ad       	ldd	r26, Y+56	; 0x38
    7b62:	b8 a9       	ldd	r27, Y+48	; 0x30
    7b64:	ab 0f       	add	r26, r27
    7b66:	21 96       	adiw	r28, 0x01	; 1
    7b68:	af af       	std	Y+63, r26	; 0x3f
    7b6a:	21 97       	sbiw	r28, 0x01	; 1
    7b6c:	81 e0       	ldi	r24, 0x01	; 1
    7b6e:	29 96       	adiw	r28, 0x09	; 9
    7b70:	8f af       	std	Y+63, r24	; 0x3f
    7b72:	29 97       	sbiw	r28, 0x09	; 9
    7b74:	21 96       	adiw	r28, 0x01	; 1
    7b76:	9f ad       	ldd	r25, Y+63	; 0x3f
    7b78:	21 97       	sbiw	r28, 0x01	; 1
    7b7a:	a8 ad       	ldd	r26, Y+56	; 0x38
    7b7c:	9a 17       	cp	r25, r26
    7b7e:	18 f0       	brcs	.+6      	; 0x7b86 <APP_VidGet_ID_From_Keypad+0x1f2>
    7b80:	29 96       	adiw	r28, 0x09	; 9
    7b82:	1f ae       	std	Y+63, r1	; 0x3f
    7b84:	29 97       	sbiw	r28, 0x09	; 9
    7b86:	b9 ad       	ldd	r27, Y+57	; 0x39
    7b88:	89 a9       	ldd	r24, Y+49	; 0x31
    7b8a:	b8 0f       	add	r27, r24
    7b8c:	22 96       	adiw	r28, 0x02	; 2
    7b8e:	bf af       	std	Y+63, r27	; 0x3f
    7b90:	22 97       	sbiw	r28, 0x02	; 2
    7b92:	91 e0       	ldi	r25, 0x01	; 1
    7b94:	2a 96       	adiw	r28, 0x0a	; 10
    7b96:	9f af       	std	Y+63, r25	; 0x3f
    7b98:	2a 97       	sbiw	r28, 0x0a	; 10
    7b9a:	22 96       	adiw	r28, 0x02	; 2
    7b9c:	af ad       	ldd	r26, Y+63	; 0x3f
    7b9e:	22 97       	sbiw	r28, 0x02	; 2
    7ba0:	b9 ad       	ldd	r27, Y+57	; 0x39
    7ba2:	ab 17       	cp	r26, r27
    7ba4:	18 f0       	brcs	.+6      	; 0x7bac <APP_VidGet_ID_From_Keypad+0x218>
    7ba6:	2a 96       	adiw	r28, 0x0a	; 10
    7ba8:	1f ae       	std	Y+63, r1	; 0x3f
    7baa:	2a 97       	sbiw	r28, 0x0a	; 10
    7bac:	29 96       	adiw	r28, 0x09	; 9
    7bae:	8f ad       	ldd	r24, Y+63	; 0x3f
    7bb0:	29 97       	sbiw	r28, 0x09	; 9
    7bb2:	22 96       	adiw	r28, 0x02	; 2
    7bb4:	9f ad       	ldd	r25, Y+63	; 0x3f
    7bb6:	22 97       	sbiw	r28, 0x02	; 2
    7bb8:	89 0f       	add	r24, r25
    7bba:	2b 96       	adiw	r28, 0x0b	; 11
    7bbc:	8f af       	std	Y+63, r24	; 0x3f
    7bbe:	2b 97       	sbiw	r28, 0x0b	; 11
    7bc0:	a1 e0       	ldi	r26, 0x01	; 1
    7bc2:	2c 96       	adiw	r28, 0x0c	; 12
    7bc4:	af af       	std	Y+63, r26	; 0x3f
    7bc6:	2c 97       	sbiw	r28, 0x0c	; 12
    7bc8:	2b 96       	adiw	r28, 0x0b	; 11
    7bca:	bf ad       	ldd	r27, Y+63	; 0x3f
    7bcc:	2b 97       	sbiw	r28, 0x0b	; 11
    7bce:	22 96       	adiw	r28, 0x02	; 2
    7bd0:	8f ad       	ldd	r24, Y+63	; 0x3f
    7bd2:	22 97       	sbiw	r28, 0x02	; 2
    7bd4:	b8 17       	cp	r27, r24
    7bd6:	18 f0       	brcs	.+6      	; 0x7bde <APP_VidGet_ID_From_Keypad+0x24a>
    7bd8:	2c 96       	adiw	r28, 0x0c	; 12
    7bda:	1f ae       	std	Y+63, r1	; 0x3f
    7bdc:	2c 97       	sbiw	r28, 0x0c	; 12
    7bde:	2a 96       	adiw	r28, 0x0a	; 10
    7be0:	9f ad       	ldd	r25, Y+63	; 0x3f
    7be2:	2a 97       	sbiw	r28, 0x0a	; 10
    7be4:	2c 96       	adiw	r28, 0x0c	; 12
    7be6:	af ad       	ldd	r26, Y+63	; 0x3f
    7be8:	2c 97       	sbiw	r28, 0x0c	; 12
    7bea:	9a 2b       	or	r25, r26
    7bec:	2a 96       	adiw	r28, 0x0a	; 10
    7bee:	9f af       	std	Y+63, r25	; 0x3f
    7bf0:	2a 97       	sbiw	r28, 0x0a	; 10
    7bf2:	2b 96       	adiw	r28, 0x0b	; 11
    7bf4:	bf ad       	ldd	r27, Y+63	; 0x3f
    7bf6:	2b 97       	sbiw	r28, 0x0b	; 11
    7bf8:	22 96       	adiw	r28, 0x02	; 2
    7bfa:	bf af       	std	Y+63, r27	; 0x3f
    7bfc:	22 97       	sbiw	r28, 0x02	; 2
    7bfe:	8a ad       	ldd	r24, Y+58	; 0x3a
    7c00:	9a a9       	ldd	r25, Y+50	; 0x32
    7c02:	89 0f       	add	r24, r25
    7c04:	23 96       	adiw	r28, 0x03	; 3
    7c06:	8f af       	std	Y+63, r24	; 0x3f
    7c08:	23 97       	sbiw	r28, 0x03	; 3
    7c0a:	a1 e0       	ldi	r26, 0x01	; 1
    7c0c:	2d 96       	adiw	r28, 0x0d	; 13
    7c0e:	af af       	std	Y+63, r26	; 0x3f
    7c10:	2d 97       	sbiw	r28, 0x0d	; 13
    7c12:	23 96       	adiw	r28, 0x03	; 3
    7c14:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c16:	23 97       	sbiw	r28, 0x03	; 3
    7c18:	8a ad       	ldd	r24, Y+58	; 0x3a
    7c1a:	b8 17       	cp	r27, r24
    7c1c:	18 f0       	brcs	.+6      	; 0x7c24 <APP_VidGet_ID_From_Keypad+0x290>
    7c1e:	2d 96       	adiw	r28, 0x0d	; 13
    7c20:	1f ae       	std	Y+63, r1	; 0x3f
    7c22:	2d 97       	sbiw	r28, 0x0d	; 13
    7c24:	2a 96       	adiw	r28, 0x0a	; 10
    7c26:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c28:	2a 97       	sbiw	r28, 0x0a	; 10
    7c2a:	23 96       	adiw	r28, 0x03	; 3
    7c2c:	af ad       	ldd	r26, Y+63	; 0x3f
    7c2e:	23 97       	sbiw	r28, 0x03	; 3
    7c30:	9a 0f       	add	r25, r26
    7c32:	2e 96       	adiw	r28, 0x0e	; 14
    7c34:	9f af       	std	Y+63, r25	; 0x3f
    7c36:	2e 97       	sbiw	r28, 0x0e	; 14
    7c38:	b1 e0       	ldi	r27, 0x01	; 1
    7c3a:	2f 96       	adiw	r28, 0x0f	; 15
    7c3c:	bf af       	std	Y+63, r27	; 0x3f
    7c3e:	2f 97       	sbiw	r28, 0x0f	; 15
    7c40:	2e 96       	adiw	r28, 0x0e	; 14
    7c42:	8f ad       	ldd	r24, Y+63	; 0x3f
    7c44:	2e 97       	sbiw	r28, 0x0e	; 14
    7c46:	23 96       	adiw	r28, 0x03	; 3
    7c48:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c4a:	23 97       	sbiw	r28, 0x03	; 3
    7c4c:	89 17       	cp	r24, r25
    7c4e:	18 f0       	brcs	.+6      	; 0x7c56 <APP_VidGet_ID_From_Keypad+0x2c2>
    7c50:	2f 96       	adiw	r28, 0x0f	; 15
    7c52:	1f ae       	std	Y+63, r1	; 0x3f
    7c54:	2f 97       	sbiw	r28, 0x0f	; 15
    7c56:	2d 96       	adiw	r28, 0x0d	; 13
    7c58:	af ad       	ldd	r26, Y+63	; 0x3f
    7c5a:	2d 97       	sbiw	r28, 0x0d	; 13
    7c5c:	2f 96       	adiw	r28, 0x0f	; 15
    7c5e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c60:	2f 97       	sbiw	r28, 0x0f	; 15
    7c62:	ab 2b       	or	r26, r27
    7c64:	2d 96       	adiw	r28, 0x0d	; 13
    7c66:	af af       	std	Y+63, r26	; 0x3f
    7c68:	2d 97       	sbiw	r28, 0x0d	; 13
    7c6a:	2e 96       	adiw	r28, 0x0e	; 14
    7c6c:	8f ad       	ldd	r24, Y+63	; 0x3f
    7c6e:	2e 97       	sbiw	r28, 0x0e	; 14
    7c70:	23 96       	adiw	r28, 0x03	; 3
    7c72:	8f af       	std	Y+63, r24	; 0x3f
    7c74:	23 97       	sbiw	r28, 0x03	; 3
    7c76:	9b ad       	ldd	r25, Y+59	; 0x3b
    7c78:	ab a9       	ldd	r26, Y+51	; 0x33
    7c7a:	9a 0f       	add	r25, r26
    7c7c:	24 96       	adiw	r28, 0x04	; 4
    7c7e:	9f af       	std	Y+63, r25	; 0x3f
    7c80:	24 97       	sbiw	r28, 0x04	; 4
    7c82:	b1 e0       	ldi	r27, 0x01	; 1
    7c84:	60 96       	adiw	r28, 0x10	; 16
    7c86:	bf af       	std	Y+63, r27	; 0x3f
    7c88:	60 97       	sbiw	r28, 0x10	; 16
    7c8a:	24 96       	adiw	r28, 0x04	; 4
    7c8c:	8f ad       	ldd	r24, Y+63	; 0x3f
    7c8e:	24 97       	sbiw	r28, 0x04	; 4
    7c90:	9b ad       	ldd	r25, Y+59	; 0x3b
    7c92:	89 17       	cp	r24, r25
    7c94:	18 f0       	brcs	.+6      	; 0x7c9c <APP_VidGet_ID_From_Keypad+0x308>
    7c96:	60 96       	adiw	r28, 0x10	; 16
    7c98:	1f ae       	std	Y+63, r1	; 0x3f
    7c9a:	60 97       	sbiw	r28, 0x10	; 16
    7c9c:	2d 96       	adiw	r28, 0x0d	; 13
    7c9e:	af ad       	ldd	r26, Y+63	; 0x3f
    7ca0:	2d 97       	sbiw	r28, 0x0d	; 13
    7ca2:	24 96       	adiw	r28, 0x04	; 4
    7ca4:	bf ad       	ldd	r27, Y+63	; 0x3f
    7ca6:	24 97       	sbiw	r28, 0x04	; 4
    7ca8:	ab 0f       	add	r26, r27
    7caa:	61 96       	adiw	r28, 0x11	; 17
    7cac:	af af       	std	Y+63, r26	; 0x3f
    7cae:	61 97       	sbiw	r28, 0x11	; 17
    7cb0:	81 e0       	ldi	r24, 0x01	; 1
    7cb2:	62 96       	adiw	r28, 0x12	; 18
    7cb4:	8f af       	std	Y+63, r24	; 0x3f
    7cb6:	62 97       	sbiw	r28, 0x12	; 18
    7cb8:	61 96       	adiw	r28, 0x11	; 17
    7cba:	9f ad       	ldd	r25, Y+63	; 0x3f
    7cbc:	61 97       	sbiw	r28, 0x11	; 17
    7cbe:	24 96       	adiw	r28, 0x04	; 4
    7cc0:	af ad       	ldd	r26, Y+63	; 0x3f
    7cc2:	24 97       	sbiw	r28, 0x04	; 4
    7cc4:	9a 17       	cp	r25, r26
    7cc6:	18 f0       	brcs	.+6      	; 0x7cce <APP_VidGet_ID_From_Keypad+0x33a>
    7cc8:	62 96       	adiw	r28, 0x12	; 18
    7cca:	1f ae       	std	Y+63, r1	; 0x3f
    7ccc:	62 97       	sbiw	r28, 0x12	; 18
    7cce:	60 96       	adiw	r28, 0x10	; 16
    7cd0:	bf ad       	ldd	r27, Y+63	; 0x3f
    7cd2:	60 97       	sbiw	r28, 0x10	; 16
    7cd4:	62 96       	adiw	r28, 0x12	; 18
    7cd6:	8f ad       	ldd	r24, Y+63	; 0x3f
    7cd8:	62 97       	sbiw	r28, 0x12	; 18
    7cda:	b8 2b       	or	r27, r24
    7cdc:	60 96       	adiw	r28, 0x10	; 16
    7cde:	bf af       	std	Y+63, r27	; 0x3f
    7ce0:	60 97       	sbiw	r28, 0x10	; 16
    7ce2:	61 96       	adiw	r28, 0x11	; 17
    7ce4:	9f ad       	ldd	r25, Y+63	; 0x3f
    7ce6:	61 97       	sbiw	r28, 0x11	; 17
    7ce8:	24 96       	adiw	r28, 0x04	; 4
    7cea:	9f af       	std	Y+63, r25	; 0x3f
    7cec:	24 97       	sbiw	r28, 0x04	; 4
    7cee:	ac ad       	ldd	r26, Y+60	; 0x3c
    7cf0:	bc a9       	ldd	r27, Y+52	; 0x34
    7cf2:	ab 0f       	add	r26, r27
    7cf4:	25 96       	adiw	r28, 0x05	; 5
    7cf6:	af af       	std	Y+63, r26	; 0x3f
    7cf8:	25 97       	sbiw	r28, 0x05	; 5
    7cfa:	81 e0       	ldi	r24, 0x01	; 1
    7cfc:	63 96       	adiw	r28, 0x13	; 19
    7cfe:	8f af       	std	Y+63, r24	; 0x3f
    7d00:	63 97       	sbiw	r28, 0x13	; 19
    7d02:	25 96       	adiw	r28, 0x05	; 5
    7d04:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d06:	25 97       	sbiw	r28, 0x05	; 5
    7d08:	ac ad       	ldd	r26, Y+60	; 0x3c
    7d0a:	9a 17       	cp	r25, r26
    7d0c:	18 f0       	brcs	.+6      	; 0x7d14 <APP_VidGet_ID_From_Keypad+0x380>
    7d0e:	63 96       	adiw	r28, 0x13	; 19
    7d10:	1f ae       	std	Y+63, r1	; 0x3f
    7d12:	63 97       	sbiw	r28, 0x13	; 19
    7d14:	60 96       	adiw	r28, 0x10	; 16
    7d16:	bf ad       	ldd	r27, Y+63	; 0x3f
    7d18:	60 97       	sbiw	r28, 0x10	; 16
    7d1a:	25 96       	adiw	r28, 0x05	; 5
    7d1c:	8f ad       	ldd	r24, Y+63	; 0x3f
    7d1e:	25 97       	sbiw	r28, 0x05	; 5
    7d20:	b8 0f       	add	r27, r24
    7d22:	64 96       	adiw	r28, 0x14	; 20
    7d24:	bf af       	std	Y+63, r27	; 0x3f
    7d26:	64 97       	sbiw	r28, 0x14	; 20
    7d28:	91 e0       	ldi	r25, 0x01	; 1
    7d2a:	65 96       	adiw	r28, 0x15	; 21
    7d2c:	9f af       	std	Y+63, r25	; 0x3f
    7d2e:	65 97       	sbiw	r28, 0x15	; 21
    7d30:	64 96       	adiw	r28, 0x14	; 20
    7d32:	af ad       	ldd	r26, Y+63	; 0x3f
    7d34:	64 97       	sbiw	r28, 0x14	; 20
    7d36:	25 96       	adiw	r28, 0x05	; 5
    7d38:	bf ad       	ldd	r27, Y+63	; 0x3f
    7d3a:	25 97       	sbiw	r28, 0x05	; 5
    7d3c:	ab 17       	cp	r26, r27
    7d3e:	18 f0       	brcs	.+6      	; 0x7d46 <APP_VidGet_ID_From_Keypad+0x3b2>
    7d40:	65 96       	adiw	r28, 0x15	; 21
    7d42:	1f ae       	std	Y+63, r1	; 0x3f
    7d44:	65 97       	sbiw	r28, 0x15	; 21
    7d46:	63 96       	adiw	r28, 0x13	; 19
    7d48:	8f ad       	ldd	r24, Y+63	; 0x3f
    7d4a:	63 97       	sbiw	r28, 0x13	; 19
    7d4c:	65 96       	adiw	r28, 0x15	; 21
    7d4e:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d50:	65 97       	sbiw	r28, 0x15	; 21
    7d52:	89 2b       	or	r24, r25
    7d54:	63 96       	adiw	r28, 0x13	; 19
    7d56:	8f af       	std	Y+63, r24	; 0x3f
    7d58:	63 97       	sbiw	r28, 0x13	; 19
    7d5a:	64 96       	adiw	r28, 0x14	; 20
    7d5c:	af ad       	ldd	r26, Y+63	; 0x3f
    7d5e:	64 97       	sbiw	r28, 0x14	; 20
    7d60:	25 96       	adiw	r28, 0x05	; 5
    7d62:	af af       	std	Y+63, r26	; 0x3f
    7d64:	25 97       	sbiw	r28, 0x05	; 5
    7d66:	bd ad       	ldd	r27, Y+61	; 0x3d
    7d68:	8d a9       	ldd	r24, Y+53	; 0x35
    7d6a:	b8 0f       	add	r27, r24
    7d6c:	26 96       	adiw	r28, 0x06	; 6
    7d6e:	bf af       	std	Y+63, r27	; 0x3f
    7d70:	26 97       	sbiw	r28, 0x06	; 6
    7d72:	91 e0       	ldi	r25, 0x01	; 1
    7d74:	66 96       	adiw	r28, 0x16	; 22
    7d76:	9f af       	std	Y+63, r25	; 0x3f
    7d78:	66 97       	sbiw	r28, 0x16	; 22
    7d7a:	26 96       	adiw	r28, 0x06	; 6
    7d7c:	af ad       	ldd	r26, Y+63	; 0x3f
    7d7e:	26 97       	sbiw	r28, 0x06	; 6
    7d80:	bd ad       	ldd	r27, Y+61	; 0x3d
    7d82:	ab 17       	cp	r26, r27
    7d84:	18 f0       	brcs	.+6      	; 0x7d8c <APP_VidGet_ID_From_Keypad+0x3f8>
    7d86:	66 96       	adiw	r28, 0x16	; 22
    7d88:	1f ae       	std	Y+63, r1	; 0x3f
    7d8a:	66 97       	sbiw	r28, 0x16	; 22
    7d8c:	63 96       	adiw	r28, 0x13	; 19
    7d8e:	8f ad       	ldd	r24, Y+63	; 0x3f
    7d90:	63 97       	sbiw	r28, 0x13	; 19
    7d92:	26 96       	adiw	r28, 0x06	; 6
    7d94:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d96:	26 97       	sbiw	r28, 0x06	; 6
    7d98:	89 0f       	add	r24, r25
    7d9a:	67 96       	adiw	r28, 0x17	; 23
    7d9c:	8f af       	std	Y+63, r24	; 0x3f
    7d9e:	67 97       	sbiw	r28, 0x17	; 23
    7da0:	a1 e0       	ldi	r26, 0x01	; 1
    7da2:	68 96       	adiw	r28, 0x18	; 24
    7da4:	af af       	std	Y+63, r26	; 0x3f
    7da6:	68 97       	sbiw	r28, 0x18	; 24
    7da8:	67 96       	adiw	r28, 0x17	; 23
    7daa:	bf ad       	ldd	r27, Y+63	; 0x3f
    7dac:	67 97       	sbiw	r28, 0x17	; 23
    7dae:	26 96       	adiw	r28, 0x06	; 6
    7db0:	8f ad       	ldd	r24, Y+63	; 0x3f
    7db2:	26 97       	sbiw	r28, 0x06	; 6
    7db4:	b8 17       	cp	r27, r24
    7db6:	18 f0       	brcs	.+6      	; 0x7dbe <APP_VidGet_ID_From_Keypad+0x42a>
    7db8:	68 96       	adiw	r28, 0x18	; 24
    7dba:	1f ae       	std	Y+63, r1	; 0x3f
    7dbc:	68 97       	sbiw	r28, 0x18	; 24
    7dbe:	66 96       	adiw	r28, 0x16	; 22
    7dc0:	9f ad       	ldd	r25, Y+63	; 0x3f
    7dc2:	66 97       	sbiw	r28, 0x16	; 22
    7dc4:	68 96       	adiw	r28, 0x18	; 24
    7dc6:	af ad       	ldd	r26, Y+63	; 0x3f
    7dc8:	68 97       	sbiw	r28, 0x18	; 24
    7dca:	9a 2b       	or	r25, r26
    7dcc:	66 96       	adiw	r28, 0x16	; 22
    7dce:	9f af       	std	Y+63, r25	; 0x3f
    7dd0:	66 97       	sbiw	r28, 0x16	; 22
    7dd2:	67 96       	adiw	r28, 0x17	; 23
    7dd4:	bf ad       	ldd	r27, Y+63	; 0x3f
    7dd6:	67 97       	sbiw	r28, 0x17	; 23
    7dd8:	26 96       	adiw	r28, 0x06	; 6
    7dda:	bf af       	std	Y+63, r27	; 0x3f
    7ddc:	26 97       	sbiw	r28, 0x06	; 6
    7dde:	8e ad       	ldd	r24, Y+62	; 0x3e
    7de0:	9e a9       	ldd	r25, Y+54	; 0x36
    7de2:	89 0f       	add	r24, r25
    7de4:	27 96       	adiw	r28, 0x07	; 7
    7de6:	8f af       	std	Y+63, r24	; 0x3f
    7de8:	27 97       	sbiw	r28, 0x07	; 7
    7dea:	a1 e0       	ldi	r26, 0x01	; 1
    7dec:	69 96       	adiw	r28, 0x19	; 25
    7dee:	af af       	std	Y+63, r26	; 0x3f
    7df0:	69 97       	sbiw	r28, 0x19	; 25
    7df2:	27 96       	adiw	r28, 0x07	; 7
    7df4:	bf ad       	ldd	r27, Y+63	; 0x3f
    7df6:	27 97       	sbiw	r28, 0x07	; 7
    7df8:	8e ad       	ldd	r24, Y+62	; 0x3e
    7dfa:	b8 17       	cp	r27, r24
    7dfc:	18 f0       	brcs	.+6      	; 0x7e04 <APP_VidGet_ID_From_Keypad+0x470>
    7dfe:	69 96       	adiw	r28, 0x19	; 25
    7e00:	1f ae       	std	Y+63, r1	; 0x3f
    7e02:	69 97       	sbiw	r28, 0x19	; 25
    7e04:	66 96       	adiw	r28, 0x16	; 22
    7e06:	9f ad       	ldd	r25, Y+63	; 0x3f
    7e08:	66 97       	sbiw	r28, 0x16	; 22
    7e0a:	27 96       	adiw	r28, 0x07	; 7
    7e0c:	af ad       	ldd	r26, Y+63	; 0x3f
    7e0e:	27 97       	sbiw	r28, 0x07	; 7
    7e10:	9a 0f       	add	r25, r26
    7e12:	6a 96       	adiw	r28, 0x1a	; 26
    7e14:	9f af       	std	Y+63, r25	; 0x3f
    7e16:	6a 97       	sbiw	r28, 0x1a	; 26
    7e18:	b1 e0       	ldi	r27, 0x01	; 1
    7e1a:	6b 96       	adiw	r28, 0x1b	; 27
    7e1c:	bf af       	std	Y+63, r27	; 0x3f
    7e1e:	6b 97       	sbiw	r28, 0x1b	; 27
    7e20:	6a 96       	adiw	r28, 0x1a	; 26
    7e22:	8f ad       	ldd	r24, Y+63	; 0x3f
    7e24:	6a 97       	sbiw	r28, 0x1a	; 26
    7e26:	27 96       	adiw	r28, 0x07	; 7
    7e28:	9f ad       	ldd	r25, Y+63	; 0x3f
    7e2a:	27 97       	sbiw	r28, 0x07	; 7
    7e2c:	89 17       	cp	r24, r25
    7e2e:	18 f0       	brcs	.+6      	; 0x7e36 <APP_VidGet_ID_From_Keypad+0x4a2>
    7e30:	6b 96       	adiw	r28, 0x1b	; 27
    7e32:	1f ae       	std	Y+63, r1	; 0x3f
    7e34:	6b 97       	sbiw	r28, 0x1b	; 27
    7e36:	69 96       	adiw	r28, 0x19	; 25
    7e38:	af ad       	ldd	r26, Y+63	; 0x3f
    7e3a:	69 97       	sbiw	r28, 0x19	; 25
    7e3c:	6b 96       	adiw	r28, 0x1b	; 27
    7e3e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7e40:	6b 97       	sbiw	r28, 0x1b	; 27
    7e42:	ab 2b       	or	r26, r27
    7e44:	69 96       	adiw	r28, 0x19	; 25
    7e46:	af af       	std	Y+63, r26	; 0x3f
    7e48:	69 97       	sbiw	r28, 0x19	; 25
    7e4a:	6a 96       	adiw	r28, 0x1a	; 26
    7e4c:	8f ad       	ldd	r24, Y+63	; 0x3f
    7e4e:	6a 97       	sbiw	r28, 0x1a	; 26
    7e50:	27 96       	adiw	r28, 0x07	; 7
    7e52:	8f af       	std	Y+63, r24	; 0x3f
    7e54:	27 97       	sbiw	r28, 0x07	; 7
    7e56:	9f ad       	ldd	r25, Y+63	; 0x3f
    7e58:	af a9       	ldd	r26, Y+55	; 0x37
    7e5a:	9a 0f       	add	r25, r26
    7e5c:	28 96       	adiw	r28, 0x08	; 8
    7e5e:	9f af       	std	Y+63, r25	; 0x3f
    7e60:	28 97       	sbiw	r28, 0x08	; 8
    7e62:	69 96       	adiw	r28, 0x19	; 25
    7e64:	8f ad       	ldd	r24, Y+63	; 0x3f
    7e66:	69 97       	sbiw	r28, 0x19	; 25
    7e68:	28 96       	adiw	r28, 0x08	; 8
    7e6a:	bf ad       	ldd	r27, Y+63	; 0x3f
    7e6c:	28 97       	sbiw	r28, 0x08	; 8
    7e6e:	8b 0f       	add	r24, r27
    7e70:	28 96       	adiw	r28, 0x08	; 8
    7e72:	8f af       	std	Y+63, r24	; 0x3f
    7e74:	28 97       	sbiw	r28, 0x08	; 8
    7e76:	21 96       	adiw	r28, 0x01	; 1
    7e78:	8f ad       	ldd	r24, Y+63	; 0x3f
    7e7a:	21 97       	sbiw	r28, 0x01	; 1
    7e7c:	8c 83       	std	Y+4, r24	; 0x04
    7e7e:	22 96       	adiw	r28, 0x02	; 2
    7e80:	9f ad       	ldd	r25, Y+63	; 0x3f
    7e82:	22 97       	sbiw	r28, 0x02	; 2
    7e84:	9d 83       	std	Y+5, r25	; 0x05
    7e86:	23 96       	adiw	r28, 0x03	; 3
    7e88:	af ad       	ldd	r26, Y+63	; 0x3f
    7e8a:	23 97       	sbiw	r28, 0x03	; 3
    7e8c:	ae 83       	std	Y+6, r26	; 0x06
    7e8e:	24 96       	adiw	r28, 0x04	; 4
    7e90:	bf ad       	ldd	r27, Y+63	; 0x3f
    7e92:	24 97       	sbiw	r28, 0x04	; 4
    7e94:	bf 83       	std	Y+7, r27	; 0x07
    7e96:	25 96       	adiw	r28, 0x05	; 5
    7e98:	8f ad       	ldd	r24, Y+63	; 0x3f
    7e9a:	25 97       	sbiw	r28, 0x05	; 5
    7e9c:	88 87       	std	Y+8, r24	; 0x08
    7e9e:	26 96       	adiw	r28, 0x06	; 6
    7ea0:	9f ad       	ldd	r25, Y+63	; 0x3f
    7ea2:	26 97       	sbiw	r28, 0x06	; 6
    7ea4:	99 87       	std	Y+9, r25	; 0x09
    7ea6:	27 96       	adiw	r28, 0x07	; 7
    7ea8:	af ad       	ldd	r26, Y+63	; 0x3f
    7eaa:	27 97       	sbiw	r28, 0x07	; 7
    7eac:	aa 87       	std	Y+10, r26	; 0x0a
    7eae:	28 96       	adiw	r28, 0x08	; 8
    7eb0:	bf ad       	ldd	r27, Y+63	; 0x3f
    7eb2:	28 97       	sbiw	r28, 0x08	; 8
    7eb4:	bb 87       	std	Y+11, r27	; 0x0b
				{
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
			}
			for (u8 i = ID_NUM_DIGITS; i >= 1; i--) {
    7eb6:	89 81       	ldd	r24, Y+1	; 0x01
    7eb8:	81 50       	subi	r24, 0x01	; 1
    7eba:	89 83       	std	Y+1, r24	; 0x01
    7ebc:	89 81       	ldd	r24, Y+1	; 0x01
    7ebe:	88 23       	and	r24, r24
    7ec0:	09 f0       	breq	.+2      	; 0x7ec4 <APP_VidGet_ID_From_Keypad+0x530>
    7ec2:	f2 cd       	rjmp	.-1052   	; 0x7aa8 <APP_VidGet_ID_From_Keypad+0x114>
				id += ID[ID_NUM_DIGITS - i] * power(10, i - 1);
			}
			Loc_Count = 0;
    7ec4:	1a 82       	std	Y+2, r1	; 0x02
    7ec6:	58 c0       	rjmp	.+176    	; 0x7f78 <APP_VidGet_ID_From_Keypad+0x5e4>
			while(Customers[Loc_Count].ID != 0)
			{
				if(Customers[Loc_Count].ID == id)
    7ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    7eca:	88 2f       	mov	r24, r24
    7ecc:	90 e0       	ldi	r25, 0x00	; 0
    7ece:	88 0f       	add	r24, r24
    7ed0:	99 1f       	adc	r25, r25
    7ed2:	9c 01       	movw	r18, r24
    7ed4:	22 95       	swap	r18
    7ed6:	32 95       	swap	r19
    7ed8:	30 7f       	andi	r19, 0xF0	; 240
    7eda:	32 27       	eor	r19, r18
    7edc:	20 7f       	andi	r18, 0xF0	; 240
    7ede:	32 27       	eor	r19, r18
    7ee0:	82 0f       	add	r24, r18
    7ee2:	93 1f       	adc	r25, r19
    7ee4:	fc 01       	movw	r30, r24
    7ee6:	e5 50       	subi	r30, 0x05	; 5
    7ee8:	ff 4f       	sbci	r31, 0xFF	; 255
    7eea:	80 81       	ld	r24, Z
    7eec:	88 a7       	std	Y+40, r24	; 0x28
    7eee:	91 81       	ldd	r25, Z+1	; 0x01
    7ef0:	99 a7       	std	Y+41, r25	; 0x29
    7ef2:	a2 81       	ldd	r26, Z+2	; 0x02
    7ef4:	aa a7       	std	Y+42, r26	; 0x2a
    7ef6:	b3 81       	ldd	r27, Z+3	; 0x03
    7ef8:	bb a7       	std	Y+43, r27	; 0x2b
    7efa:	84 81       	ldd	r24, Z+4	; 0x04
    7efc:	8c a7       	std	Y+44, r24	; 0x2c
    7efe:	95 81       	ldd	r25, Z+5	; 0x05
    7f00:	9d a7       	std	Y+45, r25	; 0x2d
    7f02:	a6 81       	ldd	r26, Z+6	; 0x06
    7f04:	ae a7       	std	Y+46, r26	; 0x2e
    7f06:	b7 81       	ldd	r27, Z+7	; 0x07
    7f08:	bf a7       	std	Y+47, r27	; 0x2f
    7f0a:	8c 81       	ldd	r24, Y+4	; 0x04
    7f0c:	98 a5       	ldd	r25, Y+40	; 0x28
    7f0e:	89 17       	cp	r24, r25
    7f10:	81 f5       	brne	.+96     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f12:	8d 81       	ldd	r24, Y+5	; 0x05
    7f14:	a9 a5       	ldd	r26, Y+41	; 0x29
    7f16:	8a 17       	cp	r24, r26
    7f18:	61 f5       	brne	.+88     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    7f1c:	ba a5       	ldd	r27, Y+42	; 0x2a
    7f1e:	8b 17       	cp	r24, r27
    7f20:	41 f5       	brne	.+80     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f22:	8f 81       	ldd	r24, Y+7	; 0x07
    7f24:	9b a5       	ldd	r25, Y+43	; 0x2b
    7f26:	89 17       	cp	r24, r25
    7f28:	21 f5       	brne	.+72     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f2a:	88 85       	ldd	r24, Y+8	; 0x08
    7f2c:	ac a5       	ldd	r26, Y+44	; 0x2c
    7f2e:	8a 17       	cp	r24, r26
    7f30:	01 f5       	brne	.+64     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f32:	89 85       	ldd	r24, Y+9	; 0x09
    7f34:	bd a5       	ldd	r27, Y+45	; 0x2d
    7f36:	8b 17       	cp	r24, r27
    7f38:	e1 f4       	brne	.+56     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f3a:	8a 85       	ldd	r24, Y+10	; 0x0a
    7f3c:	9e a5       	ldd	r25, Y+46	; 0x2e
    7f3e:	89 17       	cp	r24, r25
    7f40:	c1 f4       	brne	.+48     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
    7f42:	8b 85       	ldd	r24, Y+11	; 0x0b
    7f44:	af a5       	ldd	r26, Y+47	; 0x2f
    7f46:	8a 17       	cp	r24, r26
    7f48:	a1 f4       	brne	.+40     	; 0x7f72 <APP_VidGet_ID_From_Keypad+0x5de>
				{
					lcd_clear();
    7f4a:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
					lcd_write_string("Enter PASS:");
    7f4e:	8a e7       	ldi	r24, 0x7A	; 122
    7f50:	90 e0       	ldi	r25, 0x00	; 0
    7f52:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
					Loc_u8Flag = 1;
    7f56:	81 e0       	ldi	r24, 0x01	; 1
    7f58:	8b 83       	std	Y+3, r24	; 0x03
					xSemaphoreGive(PassSem);
    7f5a:	80 91 29 08 	lds	r24, 0x0829
    7f5e:	90 91 2a 08 	lds	r25, 0x082A
    7f62:	60 e0       	ldi	r22, 0x00	; 0
    7f64:	70 e0       	ldi	r23, 0x00	; 0
    7f66:	40 e0       	ldi	r20, 0x00	; 0
    7f68:	50 e0       	ldi	r21, 0x00	; 0
    7f6a:	20 e0       	ldi	r18, 0x00	; 0
    7f6c:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
    7f70:	27 c0       	rjmp	.+78     	; 0x7fc0 <APP_VidGet_ID_From_Keypad+0x62c>
					break;
				}
				else
				{
					Loc_Count++;
    7f72:	8a 81       	ldd	r24, Y+2	; 0x02
    7f74:	8f 5f       	subi	r24, 0xFF	; 255
    7f76:	8a 83       	std	Y+2, r24	; 0x02
			}
			for (u8 i = ID_NUM_DIGITS; i >= 1; i--) {
				id += ID[ID_NUM_DIGITS - i] * power(10, i - 1);
			}
			Loc_Count = 0;
			while(Customers[Loc_Count].ID != 0)
    7f78:	8a 81       	ldd	r24, Y+2	; 0x02
    7f7a:	88 2f       	mov	r24, r24
    7f7c:	90 e0       	ldi	r25, 0x00	; 0
    7f7e:	88 0f       	add	r24, r24
    7f80:	99 1f       	adc	r25, r25
    7f82:	9c 01       	movw	r18, r24
    7f84:	22 95       	swap	r18
    7f86:	32 95       	swap	r19
    7f88:	30 7f       	andi	r19, 0xF0	; 240
    7f8a:	32 27       	eor	r19, r18
    7f8c:	20 7f       	andi	r18, 0xF0	; 240
    7f8e:	32 27       	eor	r19, r18
    7f90:	82 0f       	add	r24, r18
    7f92:	93 1f       	adc	r25, r19
    7f94:	fc 01       	movw	r30, r24
    7f96:	e5 50       	subi	r30, 0x05	; 5
    7f98:	ff 4f       	sbci	r31, 0xFF	; 255
    7f9a:	20 81       	ld	r18, Z
    7f9c:	31 81       	ldd	r19, Z+1	; 0x01
    7f9e:	42 81       	ldd	r20, Z+2	; 0x02
    7fa0:	53 81       	ldd	r21, Z+3	; 0x03
    7fa2:	64 81       	ldd	r22, Z+4	; 0x04
    7fa4:	75 81       	ldd	r23, Z+5	; 0x05
    7fa6:	86 81       	ldd	r24, Z+6	; 0x06
    7fa8:	97 81       	ldd	r25, Z+7	; 0x07
    7faa:	e2 2f       	mov	r30, r18
    7fac:	e3 2b       	or	r30, r19
    7fae:	e4 2b       	or	r30, r20
    7fb0:	e5 2b       	or	r30, r21
    7fb2:	e6 2b       	or	r30, r22
    7fb4:	e7 2b       	or	r30, r23
    7fb6:	e8 2b       	or	r30, r24
    7fb8:	e9 2b       	or	r30, r25
    7fba:	ee 23       	and	r30, r30
    7fbc:	09 f0       	breq	.+2      	; 0x7fc0 <APP_VidGet_ID_From_Keypad+0x62c>
    7fbe:	84 cf       	rjmp	.-248    	; 0x7ec8 <APP_VidGet_ID_From_Keypad+0x534>
				else
				{
					Loc_Count++;
				}
			}
			if(Loc_u8Flag == 0)
    7fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    7fc2:	88 23       	and	r24, r24
    7fc4:	89 f4       	brne	.+34     	; 0x7fe8 <APP_VidGet_ID_From_Keypad+0x654>
			{
				lcd_clear();
    7fc6:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
				lcd_write_string("ID Is not Valid..");
    7fca:	86 e8       	ldi	r24, 0x86	; 134
    7fcc:	90 e0       	ldi	r25, 0x00	; 0
    7fce:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				xSemaphoreGive(ExitSem);
    7fd2:	80 91 27 08 	lds	r24, 0x0827
    7fd6:	90 91 28 08 	lds	r25, 0x0828
    7fda:	60 e0       	ldi	r22, 0x00	; 0
    7fdc:	70 e0       	ldi	r23, 0x00	; 0
    7fde:	40 e0       	ldi	r20, 0x00	; 0
    7fe0:	50 e0       	ldi	r21, 0x00	; 0
    7fe2:	20 e0       	ldi	r18, 0x00	; 0
    7fe4:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(100);
    7fe8:	84 e6       	ldi	r24, 0x64	; 100
    7fea:	90 e0       	ldi	r25, 0x00	; 0
    7fec:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    7ff0:	02 cd       	rjmp	.-1532   	; 0x79f6 <APP_VidGet_ID_From_Keypad+0x62>

00007ff2 <APP_VidGet_PASS_From_Keypad>:
		vTaskDelay(100);
	}
}
#endif

void APP_VidGet_PASS_From_Keypad(void *Pv) {
    7ff2:	2f 92       	push	r2
    7ff4:	3f 92       	push	r3
    7ff6:	4f 92       	push	r4
    7ff8:	5f 92       	push	r5
    7ffa:	6f 92       	push	r6
    7ffc:	7f 92       	push	r7
    7ffe:	8f 92       	push	r8
    8000:	9f 92       	push	r9
    8002:	af 92       	push	r10
    8004:	bf 92       	push	r11
    8006:	cf 92       	push	r12
    8008:	df 92       	push	r13
    800a:	ef 92       	push	r14
    800c:	ff 92       	push	r15
    800e:	0f 93       	push	r16
    8010:	1f 93       	push	r17
    8012:	df 93       	push	r29
    8014:	cf 93       	push	r28
    8016:	cd b7       	in	r28, 0x3d	; 61
    8018:	de b7       	in	r29, 0x3e	; 62
    801a:	63 97       	sbiw	r28, 0x13	; 19
    801c:	0f b6       	in	r0, 0x3f	; 63
    801e:	f8 94       	cli
    8020:	de bf       	out	0x3e, r29	; 62
    8022:	0f be       	out	0x3f, r0	; 63
    8024:	cd bf       	out	0x3d, r28	; 61
    8026:	9b 8b       	std	Y+19, r25	; 0x13
    8028:	8a 8b       	std	Y+18, r24	; 0x12
	u8 Loc_u8CardSemState;
	char Loc_u8KeyPressed = 'N';
    802a:	8e e4       	ldi	r24, 0x4E	; 78
    802c:	8e 83       	std	Y+6, r24	; 0x06
	u16 pass[5]={0};
    802e:	8a e0       	ldi	r24, 0x0A	; 10
    8030:	fe 01       	movw	r30, r28
    8032:	38 96       	adiw	r30, 0x08	; 8
    8034:	df 01       	movw	r26, r30
    8036:	98 2f       	mov	r25, r24
    8038:	1d 92       	st	X+, r1
    803a:	9a 95       	dec	r25
    803c:	e9 f7       	brne	.-6      	; 0x8038 <APP_VidGet_PASS_From_Keypad+0x46>
	//u16 Loc_u16PASS;
	u8 Loc_Count=0;
    803e:	1d 82       	std	Y+5, r1	; 0x05
	u16 password;
	u8 Loc_u8Flag=0;
    8040:	1a 82       	std	Y+2, r1	; 0x02

	while(1)
	{
		Loc_u8Flag = 0;
    8042:	1a 82       	std	Y+2, r1	; 0x02
		Loc_Count = 0;
    8044:	1d 82       	std	Y+5, r1	; 0x05
		password = 0;
    8046:	1c 82       	std	Y+4, r1	; 0x04
    8048:	1b 82       	std	Y+3, r1	; 0x03
		Loc_u8CardSemState = xSemaphoreTake(PassSem,10);
    804a:	80 91 29 08 	lds	r24, 0x0829
    804e:	90 91 2a 08 	lds	r25, 0x082A
    8052:	6a e0       	ldi	r22, 0x0A	; 10
    8054:	70 e0       	ldi	r23, 0x00	; 0
    8056:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    805a:	8f 83       	std	Y+7, r24	; 0x07
		if(Loc_u8CardSemState==pdPASS)
    805c:	8f 81       	ldd	r24, Y+7	; 0x07
    805e:	81 30       	cpi	r24, 0x01	; 1
    8060:	09 f0       	breq	.+2      	; 0x8064 <APP_VidGet_PASS_From_Keypad+0x72>
    8062:	18 c1       	rjmp	.+560    	; 0x8294 <APP_VidGet_PASS_From_Keypad+0x2a2>
    8064:	21 c0       	rjmp	.+66     	; 0x80a8 <APP_VidGet_PASS_From_Keypad+0xb6>
		{
			while(Loc_u8KeyPressed != '*')
			{
				if (Loc_Count > 3)
    8066:	8d 81       	ldd	r24, Y+5	; 0x05
    8068:	84 30       	cpi	r24, 0x04	; 4
    806a:	08 f5       	brcc	.+66     	; 0x80ae <APP_VidGet_PASS_From_Keypad+0xbc>
					break;
				if(Loc_u8KeyPressed != 'N') {
    806c:	8e 81       	ldd	r24, Y+6	; 0x06
    806e:	8e 34       	cpi	r24, 0x4E	; 78
    8070:	c1 f0       	breq	.+48     	; 0x80a2 <APP_VidGet_PASS_From_Keypad+0xb0>
					pass[Loc_Count] = chartoint(Loc_u8KeyPressed);
    8072:	8d 81       	ldd	r24, Y+5	; 0x05
    8074:	08 2f       	mov	r16, r24
    8076:	10 e0       	ldi	r17, 0x00	; 0
    8078:	8e 81       	ldd	r24, Y+6	; 0x06
    807a:	0e 94 c9 3b 	call	0x7792	; 0x7792 <chartoint>
    807e:	ac 01       	movw	r20, r24
    8080:	98 01       	movw	r18, r16
    8082:	22 0f       	add	r18, r18
    8084:	33 1f       	adc	r19, r19
    8086:	ce 01       	movw	r24, r28
    8088:	01 96       	adiw	r24, 0x01	; 1
    808a:	82 0f       	add	r24, r18
    808c:	93 1f       	adc	r25, r19
    808e:	fc 01       	movw	r30, r24
    8090:	37 96       	adiw	r30, 0x07	; 7
    8092:	51 83       	std	Z+1, r21	; 0x01
    8094:	40 83       	st	Z, r20
					Loc_Count++;
    8096:	8d 81       	ldd	r24, Y+5	; 0x05
    8098:	8f 5f       	subi	r24, 0xFF	; 255
    809a:	8d 83       	std	Y+5, r24	; 0x05
					lcd_write_char('*');
    809c:	8a e2       	ldi	r24, 0x2A	; 42
    809e:	0e 94 5f 38 	call	0x70be	; 0x70be <lcd_write_char>
				} else {
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
    80a2:	0e 94 08 3a 	call	0x7410	; 0x7410 <keypad_getchar>
    80a6:	8e 83       	std	Y+6, r24	; 0x06
		Loc_Count = 0;
		password = 0;
		Loc_u8CardSemState = xSemaphoreTake(PassSem,10);
		if(Loc_u8CardSemState==pdPASS)
		{
			while(Loc_u8KeyPressed != '*')
    80a8:	8e 81       	ldd	r24, Y+6	; 0x06
    80aa:	8a 32       	cpi	r24, 0x2A	; 42
    80ac:	e1 f6       	brne	.-72     	; 0x8066 <APP_VidGet_PASS_From_Keypad+0x74>
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
			}
			//Loc_u16PASS=(PASS[0]*1000)+(PASS[1]*100)+(PASS[2]*10)+(PASS[3]);
			for (u8 i = PASSWORD_NUM_DIGITS; i >= 1; i--) {
    80ae:	84 e0       	ldi	r24, 0x04	; 4
    80b0:	89 83       	std	Y+1, r24	; 0x01
    80b2:	55 c0       	rjmp	.+170    	; 0x815e <APP_VidGet_PASS_From_Keypad+0x16c>
				password += pass[PASSWORD_NUM_DIGITS - i] * power(10, i - 1);
    80b4:	89 81       	ldd	r24, Y+1	; 0x01
    80b6:	28 2f       	mov	r18, r24
    80b8:	30 e0       	ldi	r19, 0x00	; 0
    80ba:	84 e0       	ldi	r24, 0x04	; 4
    80bc:	90 e0       	ldi	r25, 0x00	; 0
    80be:	82 1b       	sub	r24, r18
    80c0:	93 0b       	sbc	r25, r19
    80c2:	9c 01       	movw	r18, r24
    80c4:	22 0f       	add	r18, r18
    80c6:	33 1f       	adc	r19, r19
    80c8:	ce 01       	movw	r24, r28
    80ca:	01 96       	adiw	r24, 0x01	; 1
    80cc:	82 0f       	add	r24, r18
    80ce:	93 1f       	adc	r25, r19
    80d0:	fc 01       	movw	r30, r24
    80d2:	37 96       	adiw	r30, 0x07	; 7
    80d4:	80 81       	ld	r24, Z
    80d6:	91 81       	ldd	r25, Z+1	; 0x01
    80d8:	5c 01       	movw	r10, r24
    80da:	cc 24       	eor	r12, r12
    80dc:	dd 24       	eor	r13, r13
    80de:	ee 24       	eor	r14, r14
    80e0:	ff 24       	eor	r15, r15
    80e2:	87 01       	movw	r16, r14
    80e4:	89 81       	ldd	r24, Y+1	; 0x01
    80e6:	88 2f       	mov	r24, r24
    80e8:	90 e0       	ldi	r25, 0x00	; 0
    80ea:	01 97       	sbiw	r24, 0x01	; 1
    80ec:	9c 01       	movw	r18, r24
    80ee:	8a e0       	ldi	r24, 0x0A	; 10
    80f0:	90 e0       	ldi	r25, 0x00	; 0
    80f2:	b9 01       	movw	r22, r18
    80f4:	0e 94 5e 3b 	call	0x76bc	; 0x76bc <power>
    80f8:	22 2e       	mov	r2, r18
    80fa:	33 2e       	mov	r3, r19
    80fc:	44 2e       	mov	r4, r20
    80fe:	55 2e       	mov	r5, r21
    8100:	66 2e       	mov	r6, r22
    8102:	77 2e       	mov	r7, r23
    8104:	88 2e       	mov	r8, r24
    8106:	99 2e       	mov	r9, r25
    8108:	2a 2d       	mov	r18, r10
    810a:	3b 2d       	mov	r19, r11
    810c:	4c 2d       	mov	r20, r12
    810e:	5d 2d       	mov	r21, r13
    8110:	6e 2d       	mov	r22, r14
    8112:	7f 2d       	mov	r23, r15
    8114:	80 2f       	mov	r24, r16
    8116:	91 2f       	mov	r25, r17
    8118:	a2 2c       	mov	r10, r2
    811a:	b3 2c       	mov	r11, r3
    811c:	c4 2c       	mov	r12, r4
    811e:	d5 2c       	mov	r13, r5
    8120:	e6 2c       	mov	r14, r6
    8122:	f7 2c       	mov	r15, r7
    8124:	08 2d       	mov	r16, r8
    8126:	19 2d       	mov	r17, r9
    8128:	0e 94 49 00 	call	0x92	; 0x92 <__muldi3>
    812c:	a2 2e       	mov	r10, r18
    812e:	b3 2e       	mov	r11, r19
    8130:	c4 2e       	mov	r12, r20
    8132:	d5 2e       	mov	r13, r21
    8134:	e6 2e       	mov	r14, r22
    8136:	f7 2e       	mov	r15, r23
    8138:	08 2f       	mov	r16, r24
    813a:	19 2f       	mov	r17, r25
    813c:	2a 2d       	mov	r18, r10
    813e:	3b 2d       	mov	r19, r11
    8140:	4c 2d       	mov	r20, r12
    8142:	5d 2d       	mov	r21, r13
    8144:	6e 2d       	mov	r22, r14
    8146:	7f 2d       	mov	r23, r15
    8148:	80 2f       	mov	r24, r16
    814a:	91 2f       	mov	r25, r17
    814c:	8b 81       	ldd	r24, Y+3	; 0x03
    814e:	9c 81       	ldd	r25, Y+4	; 0x04
    8150:	82 0f       	add	r24, r18
    8152:	93 1f       	adc	r25, r19
    8154:	9c 83       	std	Y+4, r25	; 0x04
    8156:	8b 83       	std	Y+3, r24	; 0x03
					/*Do Nothing*/
				}
				Loc_u8KeyPressed = keypad_getchar();
			}
			//Loc_u16PASS=(PASS[0]*1000)+(PASS[1]*100)+(PASS[2]*10)+(PASS[3]);
			for (u8 i = PASSWORD_NUM_DIGITS; i >= 1; i--) {
    8158:	89 81       	ldd	r24, Y+1	; 0x01
    815a:	81 50       	subi	r24, 0x01	; 1
    815c:	89 83       	std	Y+1, r24	; 0x01
    815e:	89 81       	ldd	r24, Y+1	; 0x01
    8160:	88 23       	and	r24, r24
    8162:	09 f0       	breq	.+2      	; 0x8166 <APP_VidGet_PASS_From_Keypad+0x174>
    8164:	a7 cf       	rjmp	.-178    	; 0x80b4 <APP_VidGet_PASS_From_Keypad+0xc2>
			}
#if 0
			xQueueSend(KPD_MessagePass, &password,10);
#endif
			//lcd_clear();
			lcd_Write_Number(password);
    8166:	8b 81       	ldd	r24, Y+3	; 0x03
    8168:	9c 81       	ldd	r25, Y+4	; 0x04
    816a:	cc 01       	movw	r24, r24
    816c:	a0 e0       	ldi	r26, 0x00	; 0
    816e:	b0 e0       	ldi	r27, 0x00	; 0
    8170:	bc 01       	movw	r22, r24
    8172:	cd 01       	movw	r24, r26
    8174:	0e 94 50 39 	call	0x72a0	; 0x72a0 <lcd_Write_Number>
			//_delay_ms(5000);
			Loc_Count = 0;
    8178:	1d 82       	std	Y+5, r1	; 0x05
    817a:	62 c0       	rjmp	.+196    	; 0x8240 <APP_VidGet_PASS_From_Keypad+0x24e>
			while(Customers[Loc_Count].Password != 0)
			{
				if(Customers[Loc_Count].Password == password)
    817c:	8d 81       	ldd	r24, Y+5	; 0x05
    817e:	88 2f       	mov	r24, r24
    8180:	90 e0       	ldi	r25, 0x00	; 0
    8182:	88 0f       	add	r24, r24
    8184:	99 1f       	adc	r25, r25
    8186:	9c 01       	movw	r18, r24
    8188:	22 95       	swap	r18
    818a:	32 95       	swap	r19
    818c:	30 7f       	andi	r19, 0xF0	; 240
    818e:	32 27       	eor	r19, r18
    8190:	20 7f       	andi	r18, 0xF0	; 240
    8192:	32 27       	eor	r19, r18
    8194:	82 0f       	add	r24, r18
    8196:	93 1f       	adc	r25, r19
    8198:	fc 01       	movw	r30, r24
    819a:	ed 5f       	subi	r30, 0xFD	; 253
    819c:	fe 4f       	sbci	r31, 0xFE	; 254
    819e:	20 81       	ld	r18, Z
    81a0:	31 81       	ldd	r19, Z+1	; 0x01
    81a2:	8b 81       	ldd	r24, Y+3	; 0x03
    81a4:	9c 81       	ldd	r25, Y+4	; 0x04
    81a6:	28 17       	cp	r18, r24
    81a8:	39 07       	cpc	r19, r25
    81aa:	09 f0       	breq	.+2      	; 0x81ae <APP_VidGet_PASS_From_Keypad+0x1bc>
    81ac:	46 c0       	rjmp	.+140    	; 0x823a <APP_VidGet_PASS_From_Keypad+0x248>
				{
					lcd_clear();
    81ae:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
					lcd_write_string("WAITING..");
    81b2:	88 e9       	ldi	r24, 0x98	; 152
    81b4:	90 e0       	ldi	r25, 0x00	; 0
    81b6:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
					Loc_u8Flag = 1;
    81ba:	81 e0       	ldi	r24, 0x01	; 1
    81bc:	8a 83       	std	Y+2, r24	; 0x02
					xSemaphoreGive(OptionSem);
    81be:	80 91 25 08 	lds	r24, 0x0825
    81c2:	90 91 26 08 	lds	r25, 0x0826
    81c6:	60 e0       	ldi	r22, 0x00	; 0
    81c8:	70 e0       	ldi	r23, 0x00	; 0
    81ca:	40 e0       	ldi	r20, 0x00	; 0
    81cc:	50 e0       	ldi	r21, 0x00	; 0
    81ce:	20 e0       	ldi	r18, 0x00	; 0
    81d0:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
					Global_Balance = Customers[Loc_Count].Balance;
    81d4:	8d 81       	ldd	r24, Y+5	; 0x05
    81d6:	88 2f       	mov	r24, r24
    81d8:	90 e0       	ldi	r25, 0x00	; 0
    81da:	88 0f       	add	r24, r24
    81dc:	99 1f       	adc	r25, r25
    81de:	9c 01       	movw	r18, r24
    81e0:	22 95       	swap	r18
    81e2:	32 95       	swap	r19
    81e4:	30 7f       	andi	r19, 0xF0	; 240
    81e6:	32 27       	eor	r19, r18
    81e8:	20 7f       	andi	r18, 0xF0	; 240
    81ea:	32 27       	eor	r19, r18
    81ec:	82 0f       	add	r24, r18
    81ee:	93 1f       	adc	r25, r19
    81f0:	fc 01       	movw	r30, r24
    81f2:	eb 5f       	subi	r30, 0xFB	; 251
    81f4:	fe 4f       	sbci	r31, 0xFE	; 254
    81f6:	80 81       	ld	r24, Z
    81f8:	91 81       	ldd	r25, Z+1	; 0x01
    81fa:	a2 81       	ldd	r26, Z+2	; 0x02
    81fc:	b3 81       	ldd	r27, Z+3	; 0x03
    81fe:	80 93 1a 08 	sts	0x081A, r24
    8202:	90 93 1b 08 	sts	0x081B, r25
    8206:	a0 93 1c 08 	sts	0x081C, r26
    820a:	b0 93 1d 08 	sts	0x081D, r27
					ptr = Customers[Loc_Count].name;
    820e:	8d 81       	ldd	r24, Y+5	; 0x05
    8210:	88 2f       	mov	r24, r24
    8212:	90 e0       	ldi	r25, 0x00	; 0
    8214:	88 0f       	add	r24, r24
    8216:	99 1f       	adc	r25, r25
    8218:	9c 01       	movw	r18, r24
    821a:	22 95       	swap	r18
    821c:	32 95       	swap	r19
    821e:	30 7f       	andi	r19, 0xF0	; 240
    8220:	32 27       	eor	r19, r18
    8222:	20 7f       	andi	r18, 0xF0	; 240
    8224:	32 27       	eor	r19, r18
    8226:	82 0f       	add	r24, r18
    8228:	93 1f       	adc	r25, r19
    822a:	0e 96       	adiw	r24, 0x0e	; 14
    822c:	85 50       	subi	r24, 0x05	; 5
    822e:	9f 4f       	sbci	r25, 0xFF	; 255
    8230:	90 93 24 08 	sts	0x0824, r25
    8234:	80 93 23 08 	sts	0x0823, r24
    8238:	19 c0       	rjmp	.+50     	; 0x826c <APP_VidGet_PASS_From_Keypad+0x27a>
					break;
				}
				else
				{
					Loc_Count++;
    823a:	8d 81       	ldd	r24, Y+5	; 0x05
    823c:	8f 5f       	subi	r24, 0xFF	; 255
    823e:	8d 83       	std	Y+5, r24	; 0x05
#endif
			//lcd_clear();
			lcd_Write_Number(password);
			//_delay_ms(5000);
			Loc_Count = 0;
			while(Customers[Loc_Count].Password != 0)
    8240:	8d 81       	ldd	r24, Y+5	; 0x05
    8242:	88 2f       	mov	r24, r24
    8244:	90 e0       	ldi	r25, 0x00	; 0
    8246:	88 0f       	add	r24, r24
    8248:	99 1f       	adc	r25, r25
    824a:	9c 01       	movw	r18, r24
    824c:	22 95       	swap	r18
    824e:	32 95       	swap	r19
    8250:	30 7f       	andi	r19, 0xF0	; 240
    8252:	32 27       	eor	r19, r18
    8254:	20 7f       	andi	r18, 0xF0	; 240
    8256:	32 27       	eor	r19, r18
    8258:	82 0f       	add	r24, r18
    825a:	93 1f       	adc	r25, r19
    825c:	fc 01       	movw	r30, r24
    825e:	ed 5f       	subi	r30, 0xFD	; 253
    8260:	fe 4f       	sbci	r31, 0xFE	; 254
    8262:	80 81       	ld	r24, Z
    8264:	91 81       	ldd	r25, Z+1	; 0x01
    8266:	00 97       	sbiw	r24, 0x00	; 0
    8268:	09 f0       	breq	.+2      	; 0x826c <APP_VidGet_PASS_From_Keypad+0x27a>
    826a:	88 cf       	rjmp	.-240    	; 0x817c <APP_VidGet_PASS_From_Keypad+0x18a>
				else
				{
					Loc_Count++;
				}
			}
			if(Loc_u8Flag==0)
    826c:	8a 81       	ldd	r24, Y+2	; 0x02
    826e:	88 23       	and	r24, r24
    8270:	89 f4       	brne	.+34     	; 0x8294 <APP_VidGet_PASS_From_Keypad+0x2a2>
			{
				lcd_clear();
    8272:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
				lcd_write_string("PASS Is not Valid..");
    8276:	82 ea       	ldi	r24, 0xA2	; 162
    8278:	90 e0       	ldi	r25, 0x00	; 0
    827a:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				xSemaphoreGive(ExitSem);
    827e:	80 91 27 08 	lds	r24, 0x0827
    8282:	90 91 28 08 	lds	r25, 0x0828
    8286:	60 e0       	ldi	r22, 0x00	; 0
    8288:	70 e0       	ldi	r23, 0x00	; 0
    828a:	40 e0       	ldi	r20, 0x00	; 0
    828c:	50 e0       	ldi	r21, 0x00	; 0
    828e:	20 e0       	ldi	r18, 0x00	; 0
    8290:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(100);
    8294:	84 e6       	ldi	r24, 0x64	; 100
    8296:	90 e0       	ldi	r25, 0x00	; 0
    8298:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    829c:	d2 ce       	rjmp	.-604    	; 0x8042 <APP_VidGet_PASS_From_Keypad+0x50>

0000829e <APP_VidChoiceOption>:
	}
}

#endif

void APP_VidChoiceOption(void *pv){
    829e:	df 93       	push	r29
    82a0:	cf 93       	push	r28
    82a2:	00 d0       	rcall	.+0      	; 0x82a4 <APP_VidChoiceOption+0x6>
    82a4:	00 d0       	rcall	.+0      	; 0x82a6 <APP_VidChoiceOption+0x8>
    82a6:	cd b7       	in	r28, 0x3d	; 61
    82a8:	de b7       	in	r29, 0x3e	; 62
    82aa:	9c 83       	std	Y+4, r25	; 0x04
    82ac:	8b 83       	std	Y+3, r24	; 0x03
	u8 Loc_chioceList;
	u8 Loc_Liststate;
	static u8 need_poll = 0;

	while(1) {
		Loc_Liststate = xSemaphoreTake(OptionSem,10);
    82ae:	80 91 25 08 	lds	r24, 0x0825
    82b2:	90 91 26 08 	lds	r25, 0x0826
    82b6:	6a e0       	ldi	r22, 0x0A	; 10
    82b8:	70 e0       	ldi	r23, 0x00	; 0
    82ba:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    82be:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_Liststate == pdPASS || need_poll == 1) {
    82c0:	89 81       	ldd	r24, Y+1	; 0x01
    82c2:	81 30       	cpi	r24, 0x01	; 1
    82c4:	29 f0       	breq	.+10     	; 0x82d0 <APP_VidChoiceOption+0x32>
    82c6:	80 91 1e 08 	lds	r24, 0x081E
    82ca:	81 30       	cpi	r24, 0x01	; 1
    82cc:	09 f0       	breq	.+2      	; 0x82d0 <APP_VidChoiceOption+0x32>
    82ce:	76 c0       	rjmp	.+236    	; 0x83bc <APP_VidChoiceOption+0x11e>
			need_poll = 1;
    82d0:	81 e0       	ldi	r24, 0x01	; 1
    82d2:	80 93 1e 08 	sts	0x081E, r24
			if (Loc_Liststate == pdPASS) {
    82d6:	89 81       	ldd	r24, Y+1	; 0x01
    82d8:	81 30       	cpi	r24, 0x01	; 1
    82da:	51 f5       	brne	.+84     	; 0x8330 <APP_VidChoiceOption+0x92>
				lcd_clear();
    82dc:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
				lcd_goto_xy(1,0);
    82e0:	81 e0       	ldi	r24, 0x01	; 1
    82e2:	90 e0       	ldi	r25, 0x00	; 0
    82e4:	60 e0       	ldi	r22, 0x00	; 0
    82e6:	70 e0       	ldi	r23, 0x00	; 0
    82e8:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
				lcd_write_string("1:Cash");
    82ec:	86 eb       	ldi	r24, 0xB6	; 182
    82ee:	90 e0       	ldi	r25, 0x00	; 0
    82f0:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				lcd_goto_xy(1,7);
    82f4:	81 e0       	ldi	r24, 0x01	; 1
    82f6:	90 e0       	ldi	r25, 0x00	; 0
    82f8:	67 e0       	ldi	r22, 0x07	; 7
    82fa:	70 e0       	ldi	r23, 0x00	; 0
    82fc:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
				lcd_write_string("2:Balance");
    8300:	8d eb       	ldi	r24, 0xBD	; 189
    8302:	90 e0       	ldi	r25, 0x00	; 0
    8304:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				lcd_goto_xy(2,0);
    8308:	82 e0       	ldi	r24, 0x02	; 2
    830a:	90 e0       	ldi	r25, 0x00	; 0
    830c:	60 e0       	ldi	r22, 0x00	; 0
    830e:	70 e0       	ldi	r23, 0x00	; 0
    8310:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
				lcd_write_string("3:New PASS");
    8314:	87 ec       	ldi	r24, 0xC7	; 199
    8316:	90 e0       	ldi	r25, 0x00	; 0
    8318:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
				lcd_goto_xy(2,10);
    831c:	82 e0       	ldi	r24, 0x02	; 2
    831e:	90 e0       	ldi	r25, 0x00	; 0
    8320:	6a e0       	ldi	r22, 0x0A	; 10
    8322:	70 e0       	ldi	r23, 0x00	; 0
    8324:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
				lcd_write_string("4:Exit");
    8328:	82 ed       	ldi	r24, 0xD2	; 210
    832a:	90 e0       	ldi	r25, 0x00	; 0
    832c:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
			}
			Loc_chioceList = keypad_getchar();
    8330:	0e 94 08 3a 	call	0x7410	; 0x7410 <keypad_getchar>
    8334:	8a 83       	std	Y+2, r24	; 0x02

			if (Loc_chioceList == '1') {
    8336:	8a 81       	ldd	r24, Y+2	; 0x02
    8338:	81 33       	cpi	r24, 0x31	; 49
    833a:	71 f4       	brne	.+28     	; 0x8358 <APP_VidChoiceOption+0xba>
				xSemaphoreGive(CashSem);
    833c:	80 91 2d 08 	lds	r24, 0x082D
    8340:	90 91 2e 08 	lds	r25, 0x082E
    8344:	60 e0       	ldi	r22, 0x00	; 0
    8346:	70 e0       	ldi	r23, 0x00	; 0
    8348:	40 e0       	ldi	r20, 0x00	; 0
    834a:	50 e0       	ldi	r21, 0x00	; 0
    834c:	20 e0       	ldi	r18, 0x00	; 0
    834e:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
				need_poll = 0;
    8352:	10 92 1e 08 	sts	0x081E, r1
    8356:	32 c0       	rjmp	.+100    	; 0x83bc <APP_VidChoiceOption+0x11e>
			} else if (Loc_chioceList == '2') {
    8358:	8a 81       	ldd	r24, Y+2	; 0x02
    835a:	82 33       	cpi	r24, 0x32	; 50
    835c:	71 f4       	brne	.+28     	; 0x837a <APP_VidChoiceOption+0xdc>
				xSemaphoreGive(BalanceSem);
    835e:	80 91 2b 08 	lds	r24, 0x082B
    8362:	90 91 2c 08 	lds	r25, 0x082C
    8366:	60 e0       	ldi	r22, 0x00	; 0
    8368:	70 e0       	ldi	r23, 0x00	; 0
    836a:	40 e0       	ldi	r20, 0x00	; 0
    836c:	50 e0       	ldi	r21, 0x00	; 0
    836e:	20 e0       	ldi	r18, 0x00	; 0
    8370:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
				need_poll = 0;
    8374:	10 92 1e 08 	sts	0x081E, r1
    8378:	21 c0       	rjmp	.+66     	; 0x83bc <APP_VidChoiceOption+0x11e>
			} else if (Loc_chioceList == '3') {
    837a:	8a 81       	ldd	r24, Y+2	; 0x02
    837c:	83 33       	cpi	r24, 0x33	; 51
    837e:	71 f4       	brne	.+28     	; 0x839c <APP_VidChoiceOption+0xfe>
				xSemaphoreGive(PassSem);
    8380:	80 91 29 08 	lds	r24, 0x0829
    8384:	90 91 2a 08 	lds	r25, 0x082A
    8388:	60 e0       	ldi	r22, 0x00	; 0
    838a:	70 e0       	ldi	r23, 0x00	; 0
    838c:	40 e0       	ldi	r20, 0x00	; 0
    838e:	50 e0       	ldi	r21, 0x00	; 0
    8390:	20 e0       	ldi	r18, 0x00	; 0
    8392:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
				need_poll = 0;
    8396:	10 92 1e 08 	sts	0x081E, r1
    839a:	10 c0       	rjmp	.+32     	; 0x83bc <APP_VidChoiceOption+0x11e>
			} else if (Loc_chioceList == '4') {
    839c:	8a 81       	ldd	r24, Y+2	; 0x02
    839e:	84 33       	cpi	r24, 0x34	; 52
    83a0:	69 f4       	brne	.+26     	; 0x83bc <APP_VidChoiceOption+0x11e>
				xSemaphoreGive(ExitSem);
    83a2:	80 91 27 08 	lds	r24, 0x0827
    83a6:	90 91 28 08 	lds	r25, 0x0828
    83aa:	60 e0       	ldi	r22, 0x00	; 0
    83ac:	70 e0       	ldi	r23, 0x00	; 0
    83ae:	40 e0       	ldi	r20, 0x00	; 0
    83b0:	50 e0       	ldi	r21, 0x00	; 0
    83b2:	20 e0       	ldi	r18, 0x00	; 0
    83b4:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
				need_poll = 0;
    83b8:	10 92 1e 08 	sts	0x081E, r1
			}
		} else{
			/*do nothing */
		}
		
		vTaskDelay(50);
    83bc:	82 e3       	ldi	r24, 0x32	; 50
    83be:	90 e0       	ldi	r25, 0x00	; 0
    83c0:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    83c4:	74 cf       	rjmp	.-280    	; 0x82ae <APP_VidChoiceOption+0x10>

000083c6 <APP_VidShowBalance>:
}




void APP_VidShowBalance(void *pv){
    83c6:	df 93       	push	r29
    83c8:	cf 93       	push	r28
    83ca:	00 d0       	rcall	.+0      	; 0x83cc <APP_VidShowBalance+0x6>
    83cc:	0f 92       	push	r0
    83ce:	cd b7       	in	r28, 0x3d	; 61
    83d0:	de b7       	in	r29, 0x3e	; 62
    83d2:	9b 83       	std	Y+3, r25	; 0x03
    83d4:	8a 83       	std	Y+2, r24	; 0x02

	u8 Loc_showbalance;

	while(1) {
		Loc_showbalance = xSemaphoreTake(BalanceSem,10);
    83d6:	80 91 2b 08 	lds	r24, 0x082B
    83da:	90 91 2c 08 	lds	r25, 0x082C
    83de:	6a e0       	ldi	r22, 0x0A	; 10
    83e0:	70 e0       	ldi	r23, 0x00	; 0
    83e2:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    83e6:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_showbalance == pdPASS) {
    83e8:	89 81       	ldd	r24, Y+1	; 0x01
    83ea:	81 30       	cpi	r24, 0x01	; 1
    83ec:	f1 f4       	brne	.+60     	; 0x842a <APP_VidShowBalance+0x64>
			lcd_clear();
    83ee:	0e 94 3c 39 	call	0x7278	; 0x7278 <lcd_clear>
			lcd_write_string("Balance:");
    83f2:	89 ed       	ldi	r24, 0xD9	; 217
    83f4:	90 e0       	ldi	r25, 0x00	; 0
    83f6:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
			lcd_Write_Number(Global_Balance);
    83fa:	80 91 1a 08 	lds	r24, 0x081A
    83fe:	90 91 1b 08 	lds	r25, 0x081B
    8402:	a0 91 1c 08 	lds	r26, 0x081C
    8406:	b0 91 1d 08 	lds	r27, 0x081D
    840a:	bc 01       	movw	r22, r24
    840c:	cd 01       	movw	r24, r26
    840e:	0e 94 50 39 	call	0x72a0	; 0x72a0 <lcd_Write_Number>
			lcd_goto_xy(2,0);
    8412:	82 e0       	ldi	r24, 0x02	; 2
    8414:	90 e0       	ldi	r25, 0x00	; 0
    8416:	60 e0       	ldi	r22, 0x00	; 0
    8418:	70 e0       	ldi	r23, 0x00	; 0
    841a:	0e 94 06 39 	call	0x720c	; 0x720c <lcd_goto_xy>
			lcd_write_string(ptr);
    841e:	80 91 23 08 	lds	r24, 0x0823
    8422:	90 91 24 08 	lds	r25, 0x0824
    8426:	0e 94 7f 38 	call	0x70fe	; 0x70fe <lcd_write_string>
		}
		else {
			/*do nothing*/
		}

		vTaskDelay(100);
    842a:	84 e6       	ldi	r24, 0x64	; 100
    842c:	90 e0       	ldi	r25, 0x00	; 0
    842e:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    8432:	d1 cf       	rjmp	.-94     	; 0x83d6 <APP_VidShowBalance+0x10>

00008434 <APP_vidTaskExit>:
}



void APP_vidTaskExit(void *pv)
{
    8434:	df 93       	push	r29
    8436:	cf 93       	push	r28
    8438:	00 d0       	rcall	.+0      	; 0x843a <APP_vidTaskExit+0x6>
    843a:	00 d0       	rcall	.+0      	; 0x843c <APP_vidTaskExit+0x8>
    843c:	cd b7       	in	r28, 0x3d	; 61
    843e:	de b7       	in	r29, 0x3e	; 62
    8440:	9c 83       	std	Y+4, r25	; 0x04
    8442:	8b 83       	std	Y+3, r24	; 0x03
	u8 Loc_u8exit;
	u8 Loc_u8ButtonState = 0;
    8444:	1a 82       	std	Y+2, r1	; 0x02
	while(1) {

		MDIO_Error_State_GetPinValue(PIN1, MDIO_PORTB, &Loc_u8ButtonState);
    8446:	9e 01       	movw	r18, r28
    8448:	2e 5f       	subi	r18, 0xFE	; 254
    844a:	3f 4f       	sbci	r19, 0xFF	; 255
    844c:	81 e0       	ldi	r24, 0x01	; 1
    844e:	61 e0       	ldi	r22, 0x01	; 1
    8450:	a9 01       	movw	r20, r18
    8452:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <MDIO_Error_State_GetPinValue>
		Loc_u8exit = xSemaphoreTake(ExitSem,10);
    8456:	80 91 27 08 	lds	r24, 0x0827
    845a:	90 91 28 08 	lds	r25, 0x0828
    845e:	6a e0       	ldi	r22, 0x0A	; 10
    8460:	70 e0       	ldi	r23, 0x00	; 0
    8462:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xQueueSemaphoreTake>
    8466:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_u8exit == pdPASS || Loc_u8ButtonState == 0){
    8468:	89 81       	ldd	r24, Y+1	; 0x01
    846a:	81 30       	cpi	r24, 0x01	; 1
    846c:	19 f0       	breq	.+6      	; 0x8474 <APP_vidTaskExit+0x40>
    846e:	8a 81       	ldd	r24, Y+2	; 0x02
    8470:	88 23       	and	r24, r24
    8472:	59 f4       	brne	.+22     	; 0x848a <APP_vidTaskExit+0x56>
			xSemaphoreGive(LCDSem);
    8474:	80 91 1f 08 	lds	r24, 0x081F
    8478:	90 91 20 08 	lds	r25, 0x0820
    847c:	60 e0       	ldi	r22, 0x00	; 0
    847e:	70 e0       	ldi	r23, 0x00	; 0
    8480:	40 e0       	ldi	r20, 0x00	; 0
    8482:	50 e0       	ldi	r21, 0x00	; 0
    8484:	20 e0       	ldi	r18, 0x00	; 0
    8486:	0e 94 84 14 	call	0x2908	; 0x2908 <xQueueGenericSend>
		}
		else {

		}
	
		vTaskDelay(50); /*80*/
    848a:	82 e3       	ldi	r24, 0x32	; 50
    848c:	90 e0       	ldi	r25, 0x00	; 0
    848e:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskDelay>
    8492:	d9 cf       	rjmp	.-78     	; 0x8446 <APP_vidTaskExit+0x12>

00008494 <__mulsi3>:
    8494:	62 9f       	mul	r22, r18
    8496:	d0 01       	movw	r26, r0
    8498:	73 9f       	mul	r23, r19
    849a:	f0 01       	movw	r30, r0
    849c:	82 9f       	mul	r24, r18
    849e:	e0 0d       	add	r30, r0
    84a0:	f1 1d       	adc	r31, r1
    84a2:	64 9f       	mul	r22, r20
    84a4:	e0 0d       	add	r30, r0
    84a6:	f1 1d       	adc	r31, r1
    84a8:	92 9f       	mul	r25, r18
    84aa:	f0 0d       	add	r31, r0
    84ac:	83 9f       	mul	r24, r19
    84ae:	f0 0d       	add	r31, r0
    84b0:	74 9f       	mul	r23, r20
    84b2:	f0 0d       	add	r31, r0
    84b4:	65 9f       	mul	r22, r21
    84b6:	f0 0d       	add	r31, r0
    84b8:	99 27       	eor	r25, r25
    84ba:	72 9f       	mul	r23, r18
    84bc:	b0 0d       	add	r27, r0
    84be:	e1 1d       	adc	r30, r1
    84c0:	f9 1f       	adc	r31, r25
    84c2:	63 9f       	mul	r22, r19
    84c4:	b0 0d       	add	r27, r0
    84c6:	e1 1d       	adc	r30, r1
    84c8:	f9 1f       	adc	r31, r25
    84ca:	bd 01       	movw	r22, r26
    84cc:	cf 01       	movw	r24, r30
    84ce:	11 24       	eor	r1, r1
    84d0:	08 95       	ret

000084d2 <__udivmodhi4>:
    84d2:	aa 1b       	sub	r26, r26
    84d4:	bb 1b       	sub	r27, r27
    84d6:	51 e1       	ldi	r21, 0x11	; 17
    84d8:	07 c0       	rjmp	.+14     	; 0x84e8 <__udivmodhi4_ep>

000084da <__udivmodhi4_loop>:
    84da:	aa 1f       	adc	r26, r26
    84dc:	bb 1f       	adc	r27, r27
    84de:	a6 17       	cp	r26, r22
    84e0:	b7 07       	cpc	r27, r23
    84e2:	10 f0       	brcs	.+4      	; 0x84e8 <__udivmodhi4_ep>
    84e4:	a6 1b       	sub	r26, r22
    84e6:	b7 0b       	sbc	r27, r23

000084e8 <__udivmodhi4_ep>:
    84e8:	88 1f       	adc	r24, r24
    84ea:	99 1f       	adc	r25, r25
    84ec:	5a 95       	dec	r21
    84ee:	a9 f7       	brne	.-22     	; 0x84da <__udivmodhi4_loop>
    84f0:	80 95       	com	r24
    84f2:	90 95       	com	r25
    84f4:	bc 01       	movw	r22, r24
    84f6:	cd 01       	movw	r24, r26
    84f8:	08 95       	ret

000084fa <__udivmodsi4>:
    84fa:	a1 e2       	ldi	r26, 0x21	; 33
    84fc:	1a 2e       	mov	r1, r26
    84fe:	aa 1b       	sub	r26, r26
    8500:	bb 1b       	sub	r27, r27
    8502:	fd 01       	movw	r30, r26
    8504:	0d c0       	rjmp	.+26     	; 0x8520 <__udivmodsi4_ep>

00008506 <__udivmodsi4_loop>:
    8506:	aa 1f       	adc	r26, r26
    8508:	bb 1f       	adc	r27, r27
    850a:	ee 1f       	adc	r30, r30
    850c:	ff 1f       	adc	r31, r31
    850e:	a2 17       	cp	r26, r18
    8510:	b3 07       	cpc	r27, r19
    8512:	e4 07       	cpc	r30, r20
    8514:	f5 07       	cpc	r31, r21
    8516:	20 f0       	brcs	.+8      	; 0x8520 <__udivmodsi4_ep>
    8518:	a2 1b       	sub	r26, r18
    851a:	b3 0b       	sbc	r27, r19
    851c:	e4 0b       	sbc	r30, r20
    851e:	f5 0b       	sbc	r31, r21

00008520 <__udivmodsi4_ep>:
    8520:	66 1f       	adc	r22, r22
    8522:	77 1f       	adc	r23, r23
    8524:	88 1f       	adc	r24, r24
    8526:	99 1f       	adc	r25, r25
    8528:	1a 94       	dec	r1
    852a:	69 f7       	brne	.-38     	; 0x8506 <__udivmodsi4_loop>
    852c:	60 95       	com	r22
    852e:	70 95       	com	r23
    8530:	80 95       	com	r24
    8532:	90 95       	com	r25
    8534:	9b 01       	movw	r18, r22
    8536:	ac 01       	movw	r20, r24
    8538:	bd 01       	movw	r22, r26
    853a:	cf 01       	movw	r24, r30
    853c:	08 95       	ret

0000853e <__prologue_saves__>:
    853e:	2f 92       	push	r2
    8540:	3f 92       	push	r3
    8542:	4f 92       	push	r4
    8544:	5f 92       	push	r5
    8546:	6f 92       	push	r6
    8548:	7f 92       	push	r7
    854a:	8f 92       	push	r8
    854c:	9f 92       	push	r9
    854e:	af 92       	push	r10
    8550:	bf 92       	push	r11
    8552:	cf 92       	push	r12
    8554:	df 92       	push	r13
    8556:	ef 92       	push	r14
    8558:	ff 92       	push	r15
    855a:	0f 93       	push	r16
    855c:	1f 93       	push	r17
    855e:	cf 93       	push	r28
    8560:	df 93       	push	r29
    8562:	cd b7       	in	r28, 0x3d	; 61
    8564:	de b7       	in	r29, 0x3e	; 62
    8566:	ca 1b       	sub	r28, r26
    8568:	db 0b       	sbc	r29, r27
    856a:	0f b6       	in	r0, 0x3f	; 63
    856c:	f8 94       	cli
    856e:	de bf       	out	0x3e, r29	; 62
    8570:	0f be       	out	0x3f, r0	; 63
    8572:	cd bf       	out	0x3d, r28	; 61
    8574:	09 94       	ijmp

00008576 <__epilogue_restores__>:
    8576:	2a 88       	ldd	r2, Y+18	; 0x12
    8578:	39 88       	ldd	r3, Y+17	; 0x11
    857a:	48 88       	ldd	r4, Y+16	; 0x10
    857c:	5f 84       	ldd	r5, Y+15	; 0x0f
    857e:	6e 84       	ldd	r6, Y+14	; 0x0e
    8580:	7d 84       	ldd	r7, Y+13	; 0x0d
    8582:	8c 84       	ldd	r8, Y+12	; 0x0c
    8584:	9b 84       	ldd	r9, Y+11	; 0x0b
    8586:	aa 84       	ldd	r10, Y+10	; 0x0a
    8588:	b9 84       	ldd	r11, Y+9	; 0x09
    858a:	c8 84       	ldd	r12, Y+8	; 0x08
    858c:	df 80       	ldd	r13, Y+7	; 0x07
    858e:	ee 80       	ldd	r14, Y+6	; 0x06
    8590:	fd 80       	ldd	r15, Y+5	; 0x05
    8592:	0c 81       	ldd	r16, Y+4	; 0x04
    8594:	1b 81       	ldd	r17, Y+3	; 0x03
    8596:	aa 81       	ldd	r26, Y+2	; 0x02
    8598:	b9 81       	ldd	r27, Y+1	; 0x01
    859a:	ce 0f       	add	r28, r30
    859c:	d1 1d       	adc	r29, r1
    859e:	0f b6       	in	r0, 0x3f	; 63
    85a0:	f8 94       	cli
    85a2:	de bf       	out	0x3e, r29	; 62
    85a4:	0f be       	out	0x3f, r0	; 63
    85a6:	cd bf       	out	0x3d, r28	; 61
    85a8:	ed 01       	movw	r28, r26
    85aa:	08 95       	ret

000085ac <memcpy>:
    85ac:	fb 01       	movw	r30, r22
    85ae:	dc 01       	movw	r26, r24
    85b0:	02 c0       	rjmp	.+4      	; 0x85b6 <memcpy+0xa>
    85b2:	01 90       	ld	r0, Z+
    85b4:	0d 92       	st	X+, r0
    85b6:	41 50       	subi	r20, 0x01	; 1
    85b8:	50 40       	sbci	r21, 0x00	; 0
    85ba:	d8 f7       	brcc	.-10     	; 0x85b2 <memcpy+0x6>
    85bc:	08 95       	ret

000085be <memset>:
    85be:	dc 01       	movw	r26, r24
    85c0:	01 c0       	rjmp	.+2      	; 0x85c4 <memset+0x6>
    85c2:	6d 93       	st	X+, r22
    85c4:	41 50       	subi	r20, 0x01	; 1
    85c6:	50 40       	sbci	r21, 0x00	; 0
    85c8:	e0 f7       	brcc	.-8      	; 0x85c2 <memset+0x4>
    85ca:	08 95       	ret

000085cc <_exit>:
    85cc:	f8 94       	cli

000085ce <__stop_program>:
    85ce:	ff cf       	rjmp	.-2      	; 0x85ce <__stop_program>
